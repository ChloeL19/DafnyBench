

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_bst --seed 42 --base_model_name ./my_dpo_model 


To complete all experiments, 0 minutes and 0 seconds elapsed.




========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_bst --seed 42 --base_model_name ./my_dpo_model 


[2024-01-12 14:00:39,673] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.

SCORE
1.0
['// (1) Define the ADT for a tree of natural numbers.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.

SCORE
1.0
['// (2) Define a predicate that checks whether a given tree is a binary search tree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool

SCORE
1.0
['function IsBST(t: Tree, lower: nat, upper: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
10 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.

SCORE
1.0
['// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
19 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(19,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>

   |
20 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(20,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)

   |
21 |     if value < tval then Node(Insert(left, value), tval, right)
   |                                                                ^

ex.dfy(21,63): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then Node(Insert(left, value), tval, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))

   |
22 |     else if value > tval then Node(left, tval, Insert(right, value))
   |                                                                     ^

ex.dfy(22,68): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > tval then Node(left, tval, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t

   |
23 |     else t
   |           ^

ex.dfy(23,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.

SCORE
1.0
['// (4) Define a predicate that checks whether a given tree contains a given element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool

SCORE
1.0
['function Contains(t: Tree, value: nat): bool\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t

   |
29 |   match t
   |          ^

ex.dfy(29,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false

   |
30 |   case Empty => false
   |                      ^

ex.dfy(30,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>

   |
31 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(31,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)

   |
32 |     if value < tval then Contains(left, value)
   |                                               ^

ex.dfy(32,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)

   |
33 |     else if value > tval then Contains(right, value)
   |                                                     ^

ex.dfy(33,52): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > tval then Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true

   |
34 |     else true
   |              ^

ex.dfy(34,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.

SCORE
1.0
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t

   |
41 |   match t
   |          ^

ex.dfy(41,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>

   |
42 |   case Empty =>
   |                ^

ex.dfy(42,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
43 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(43,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
44 |     if value < tval then
   |                     ^

ex.dfy(44,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
44 |     if value < tval then
   |                     ^

ex.dfy(44,20): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
44 |     if value < tval then
   |                     ^

ex.dfy(44,20): Error: lbrace expected
   |
46 |     else if value > tval then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > tval then
   |                          ^

ex.dfy(46,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
41 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(41,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
43 |   case Empty =>
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
44 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(44,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
   |
46 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(46,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
   |
47 |     else if value > tval then
   |     ^

ex.dfy(47,4): Error: invalid UpdateStmt
   |
47 |     else if value > tval then
   |                          ^

ex.dfy(47,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, tval, right) =>\n']
['    if value < tval then\n']
['      InsertEnsuresContains(left, value)\n']
['    else if value > tval then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases

   |
41 |   // Base cases
   |                ^

ex.dfy(41,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases
  match t
  case Empty =>

   |
43 |   case Empty =>
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
44 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(44,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
   |
46 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(46,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // Base cases
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
   |
47 |     else if value > tval then
   |     ^

ex.dfy(47,4): Error: invalid UpdateStmt
   |
47 |     else if value > tval then
   |                          ^

ex.dfy(47,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100

SCORE
1.0
['requires IsBST(t, 0, 100) // assuming a bound of 0 to 100\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // proof by structural induction on t

   |
42 |   // proof by structural induction on t
   |                                        ^

ex.dfy(42,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // proof by structural induction on t
}

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(32,25): Related location
   |
32 |     if value < tval then Contains(left, value)
   |                          ^^^^^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,30): Related location
   |
33 |     else if value > tval then Contains(right, value)
   |                               ^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
42 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(42,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t

   |
43 |   match t
   |          ^

ex.dfy(43,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
44 |   case Empty =>
   |                ^

ex.dfy(44,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
45 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(45,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
47 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(47,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
48 |     else if value > tval then
   |     ^

ex.dfy(48,4): Error: invalid UpdateStmt
   |
48 |     else if value > tval then
   |                          ^

ex.dfy(48,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.

   |
42 |   // Base cases.
   |                 ^

ex.dfy(42,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Base cases.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {

   |
43 |   if t == Empty {
   |                  ^

ex.dfy(43,17): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  if t == Empty {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {

   |
44 |   } else {
   |           ^

ex.dfy(44,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {

   |
45 |     match t {
   |              ^

ex.dfy(45,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>

   |
46 |       case Node(left, tval, right) =>
   |                                      ^

ex.dfy(46,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {

   |
47 |         if value < tval {
   |                          ^

ex.dfy(47,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        if value < tval {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);

   |
48 |           InsertEnsuresContains(left, value);
   |                                              ^

ex.dfy(48,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['          InsertEnsuresContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);
        } else if value > tval {

   |
49 |         } else if value > tval {
   |                                 ^

ex.dfy(49,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        } else if value > tval {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);
        } else if value > tval {
          InsertEnsuresContains(right, value);

   |
50 |           InsertEnsuresContains(right, value);
   |                                               ^

ex.dfy(50,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['          InsertEnsuresContains(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);
        } else if value > tval {
          InsertEnsuresContains(right, value);
        }

   |
51 |         }
   |          ^

ex.dfy(51,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);
        } else if value > tval {
          InsertEnsuresContains(right, value);
        }
    }

   |
52 |     }
   |      ^

ex.dfy(52,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);
        } else if value > tval {
          InsertEnsuresContains(right, value);
        }
    }
  }

   |
53 |   }
   |    ^

ex.dfy(53,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  // Base cases.
  if t == Empty {
  } else {
    match t {
      case Node(left, tval, right) =>
        if value < tval {
          InsertEnsuresContains(left, value);
        } else if value > tval {
          InsertEnsuresContains(right, value);
        }
    }
  }
}

ex.dfy(48,10): Error: a precondition for this call could not be proved
   |
48 |           InsertEnsuresContains(left, value);
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(39,9): Related location: this is the precondition that could not be proved
   |
39 | requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
   |          ^^^^^^^^^^^^^^^^

ex.dfy(12,4): Related location
   |
12 |     IsBST(right, value, upper)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(50,10): Error: a precondition for this call could not be proved
   |
50 |           InsertEnsuresContains(right, value);
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(39,9): Related location: this is the precondition that could not be proved
   |
39 | requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
   |          ^^^^^^^^^^^^^^^^

ex.dfy(11,4): Related location
   |
11 |     IsBST(left, lower, value) &&
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>

   |
43 |   case Empty =>
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
44 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(44,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
   |
46 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(46,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // assuming a bound of 0 to 100
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
45 |     if value < tval then
   |                     ^

ex.dfy(45,20): Error: lbrace expected
   |
47 |     else if value > tval then
   |     ^

ex.dfy(47,4): Error: invalid UpdateStmt
   |
47 |     else if value > tval then
   |                          ^

ex.dfy(47,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, tval, right) =>\n']
['    if value < tval then\n']
['      InsertEnsuresContains(left, value)\n']
['    else if value > tval then\n']
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
41 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(41,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t

   |
42 |   match t
   |          ^

ex.dfy(42,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
43 |   case Empty =>
   |                ^

ex.dfy(43,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)

   |
44 |     assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
   |                                                                                          ^

ex.dfy(44,89): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
  case Node(left, tval, right) =>

   |
45 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(45,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then
      assert Contains(Insert(left, value), value)

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
47 |       assert Contains(Insert(left, value), value)
   |                                                  ^

ex.dfy(47,49): Error: invalid AssertStmt
2 parse errors detected in ex.dfy

SCORE
None
['      assert Contains(Insert(left, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
    assert value == value; // Base case: Insert(Empty, value) = Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then
      assert Contains(Insert(left, value), value)
    else if value > tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
48 |     else if value > tval then
   |     ^

ex.dfy(48,4): Error: invalid AssertStmt
   |
48 |     else if value > tval then
   |                          ^

ex.dfy(48,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  match t

   |
41 |   match t
   |          ^

ex.dfy(41,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>

   |
42 |   case Empty =>
   |                ^

ex.dfy(42,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
43 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(43,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
44 |     if value < tval then
   |                     ^

ex.dfy(44,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
44 |     if value < tval then
   |                     ^

ex.dfy(44,20): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
44 |     if value < tval then
   |                     ^

ex.dfy(44,20): Error: lbrace expected
   |
46 |     else if value > tval then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > tval then
   |                          ^

ex.dfy(46,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application

SCORE
1.0
['requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
42 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(42,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
}

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(32,25): Related location
   |
32 |     if value < tval then Contains(left, value)
   |                          ^^^^^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,30): Related location
   |
33 |     else if value > tval then Contains(right, value)
   |                               ^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t

   |
43 |   match t
   |          ^

ex.dfy(43,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
44 |   case Empty =>
   |                ^

ex.dfy(44,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
45 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(45,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
47 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(47,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
48 |     else if value > tval then
   |     ^

ex.dfy(48,4): Error: invalid UpdateStmt
   |
48 |     else if value > tval then
   |                          ^

ex.dfy(48,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.

   |
42 |   // Proof by induction on the structure of the tree t.
   |                                                        ^

ex.dfy(42,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by induction on the structure of the tree t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.
  match t

   |
43 |   match t
   |          ^

ex.dfy(43,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.
  match t
  case Empty =>

   |
44 |   case Empty =>
   |                ^

ex.dfy(44,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.
  match t
  case Empty =>
  case Node(left, tval, right) =>

   |
45 |   case Node(left, tval, right) =>
   |                                  ^

ex.dfy(45,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < tval then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
47 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(47,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // Proof by induction on the structure of the tree t.
  match t
  case Empty =>
  case Node(left, tval, right) =>
    if value < tval then
      InsertEnsuresContains(left, value)
    else if value > tval then

   |
46 |     if value < tval then
   |                     ^

ex.dfy(46,20): Error: lbrace expected
   |
48 |     else if value > tval then
   |     ^

ex.dfy(48,4): Error: invalid UpdateStmt
   |
48 |     else if value > tval then
   |                          ^

ex.dfy(48,25): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > tval then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // base case: if t is Empty, then Insert returns a new Node with value

   |
42 |   // base case: if t is Empty, then Insert returns a new Node with value
   |                                                                         ^

ex.dfy(42,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // base case: if t is Empty, then Insert returns a new Node with value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // base case: if t is Empty, then Insert returns a new Node with value
  // inductive case: recursively call the lemma on left or right subtree based on value comparison with tval

   |
43 |   // inductive case: recursively call the lemma on left or right subtree based on value comparison with tval
   |                                                                                                             ^

ex.dfy(43,108): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // inductive case: recursively call the lemma on left or right subtree based on value comparison with tval\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires IsBST(t, 0, 100) // or whatever bounds are appropriate for your application
ensures Contains(Insert(t, value), value)
{
  // base case: if t is Empty, then Insert returns a new Node with value
  // inductive case: recursively call the lemma on left or right subtree based on value comparison with tval
}

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(32,25): Related location
   |
32 |     if value < tval then Contains(left, value)
   |                          ^^^^^^^^^^^^^^^^^^^^^

ex.dfy(41,0): Error: a postcondition could not be proved on this return path
   |
41 | {
   | ^

ex.dfy(40,8): Related location: this is the postcondition that could not be proved
   |
40 | ensures Contains(Insert(t, value), value)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(33,30): Related location
   |
33 |     else if value > tval then Contains(right, value)
   |                               ^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['\n']
['// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
41 | {
   |  ^

ex.dfy(41,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` #include "stdafx.h"

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include "stdafx.h"\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
```

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` <?php

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesIsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package org.apache.flink.table.planner.plan.nodes.exec.stream;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.flink.table.planner.plan.nodes.exec.stream;\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
```

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` import {

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import {\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package com.example.android.miwok;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package com.google.cloud.spanner.pgadapter;

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,8): Related location: this is the postcondition that could not be proved
   |
47 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.google.cloud.spanner.pgadapter;\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...

   |
41 |   // ...
   |         ^

ex.dfy(41,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.

SCORE
1.0
['// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)

SCORE
1.0
['  requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ...

   |
49 |   // ...
   |         ^

ex.dfy(49,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // ...\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers.
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate that checks whether a given tree is a binary search tree.
function IsBST(t: Tree, lower: nat, upper: nat): bool
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function that inserts an element into a binary search tree while preserving the BST property.
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, tval, right) =>
    if value < tval then Node(Insert(left, value), tval, right)
    else if value > tval then Node(left, tval, Insert(right, value))
    else t
}

// (4) Define a predicate that checks whether a given tree contains a given element.
function Contains(t: Tree, value: nat): bool
{
  match t
  case Empty => false
  case Node(left, tval, right) =>
    if value < tval then Contains(left, value)
    else if value > tval then Contains(right, value)
    else true
}

// (5) Define a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element.
lemma InsertEnsuresContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  // ...
}

// (6) Define a lemma about the insert function that checks the BST property continues to hold after insertion.
lemma InsertPreservesBST(t: Tree, value: nat, lower: nat, upper: nat)
  requires IsBST(t, lower, upper)
  ensures IsBST(Insert(t, value), lower, upper)
{
  // ...
}

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= lower && value <= upper &&
   |     ^^^^^^^^^^^^^^

ex.dfy(48,0): Error: a postcondition could not be proved on this return path
   |
48 | {
   | ^

ex.dfy(47,10): Related location: this is the postcondition that could not be proved
   |
47 |   ensures IsBST(Insert(t, value), lower, upper)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,22): Related location
   |
10 |     value >= lower && value <= upper &&
   |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  // ...\n']
['}\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // ...\n']
['}\n']
['{\n']
['  // ...\n']
['}\n']
['  requires IsBST(t, lower, upper)\n']
['  ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['  // ...\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 149
number of gen nodes: 75 (including leaves: 23)
number of back nodes: 74 (including leaves: 52)

expansion count: 124 (including failed: 50)

cache stats {'hit': 158, 'miss': 166}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601]

Trial calls: [324]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 324 calls, Max: 324 calls, Average: 324.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601]

Trial calls: [324]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 324 calls, Max: 324 calls, Average: 324.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&

   |
10 |     lower <= v <= upper &&
   |                           ^

ex.dfy(10,26): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    lower <= v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&

   |
11 |     IsBST(left, lower, v) &&
   |                             ^

ex.dfy(11,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)

   |
12 |     IsBST(right, v, upper)
   |                           ^

ex.dfy(12,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST

SCORE
1.0
['// (3) Function for inserting element into BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)

   |
17 |   requires IsBST(t, 0, max_nat)
   |                        ^^^^^^^

ex.dfy(17,23): Error: unresolved identifier: max_nat
1 resolution/type errors detected in ex.dfy

SCORE
None
['  requires IsBST(t, 0, max_nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)

   |
17 |   requires IsBST(t, 0, max_nat)
   |                        ^^^^^^^

ex.dfy(17,23): Error: unresolved identifier: max_nat
   |
18 |   ensures IsBST(t, 0, max_nat)
   |                       ^^^^^^^

ex.dfy(18,22): Error: unresolved identifier: max_nat
2 resolution/type errors detected in ex.dfy

SCORE
None
['  ensures IsBST(t, 0, max_nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t

   |
20 |   match t
   |          ^

ex.dfy(20,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Empty => Node(Empty, v, Empty)

   |
21 |   case Empty => Node(Empty, v, Empty)
   |                                      ^

ex.dfy(21,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>

   |
22 |   case Node(left, w, right) =>
   |                               ^

ex.dfy(22,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {

   |
23 |     if v < w {
   |              ^

ex.dfy(23,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)

   |
23 |     if v < w {
   |              ^

ex.dfy(23,13): Error: then expected
   |
24 |       Node(Insert(left, v), w, right)
   |                                      ^

ex.dfy(24,37): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
  requires IsBST(t, 0, max_nat)
  ensures IsBST(t, 0, max_nat)
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)
    } else if v > w {

   |
23 |     if v < w {
   |              ^

ex.dfy(23,13): Error: then expected
   |
25 |     } else if v > w {
   |                     ^

ex.dfy(25,20): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)

   |
19 |   case Empty => Node(Empty, v, Empty)
   |                                      ^

ex.dfy(19,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>

   |
20 |   case Node(left, w, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
   |
22 |       Node(Insert(left, v), w, right)
   |                                      ^

ex.dfy(22,37): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)
    } else if v > w {

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
   |
23 |     } else if v > w {
   |                     ^

ex.dfy(23,20): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if v > w {\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree

SCORE
1.0
['// (3) Function to insert an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)

   |
19 |   case Empty => Node(Empty, v, Empty)
   |                                      ^

ex.dfy(19,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>

   |
20 |   case Node(left, w, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
   |
22 |       Node(Insert(left, v), w, right)
   |                                      ^

ex.dfy(22,37): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)
    } else if v > w {

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
   |
23 |     } else if v > w {
   |                     ^

ex.dfy(23,20): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if v > w {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)

   |
19 |   case Empty => Node(Empty, v, Empty)
   |                                      ^

ex.dfy(19,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>

   |
20 |   case Node(left, w, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
   |
22 |       Node(Insert(left, v), w, right)
   |                                      ^

ex.dfy(22,37): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    lower <= v <= upper &&
    IsBST(left, lower, v) &&
    IsBST(right, v, upper)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(left, w, right) =>
    if v < w {
      Node(Insert(left, v), w, right)
    } else if v > w {

   |
21 |     if v < w {
   |              ^

ex.dfy(21,13): Error: then expected
   |
23 |     } else if v > w {
   |                     ^

ex.dfy(23,20): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if v > w {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, v, Empty)\n']
['  case Node(left, w, right) =>\n']
['    if v < w {\n']
['      Node(Insert(left, v), w, right)\n']
['    } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
10 |     v >= min && v <= max &&
   |                            ^

ex.dfy(10,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    (left == Empty || IsBST(left, min, v - 1)) &&

   |
11 |     (left == Empty || IsBST(left, min, v - 1)) &&
   |                                                  ^

ex.dfy(11,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (left == Empty || IsBST(left, min, v - 1)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    (left == Empty || IsBST(left, min, v - 1)) &&
    (right == Empty || IsBST(right, v + 1, max))

   |
12 |     (right == Empty || IsBST(right, v + 1, max))
   |                                                 ^

ex.dfy(12,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (right == Empty || IsBST(right, v + 1, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Empty => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    (left == Empty || IsBST(left, min, v - 1)) &&
    (right == Empty || IsBST(right, v + 1, max))
}

ex.dfy(11,41): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |     (left == Empty || IsBST(left, min, v - 1)) &&
   |                                          ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  match t\n']
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&

  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                                    ^

ex.dfy(9,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) => v >= lower && v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&

   |
10 |                         IsBST(l, lower, v) &&
   |                                              ^

ex.dfy(10,45): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['                        IsBST(l, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)

   |
11 |                         IsBST(r, v, upper)
   |                                           ^

ex.dfy(11,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                        IsBST(r, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree

SCORE
1.0
['// (3) Function to insert an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{

   |
16 | {
   |  ^

ex.dfy(16,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t

   |
17 |   match t
   |          ^

ex.dfy(17,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)

   |
18 |   case Empty => Node(Empty, v, Empty)
   |                                      ^

ex.dfy(18,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>

   |
19 |   case Node(l, w, r) =>
   |                        ^

ex.dfy(19,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)

   |
20 |     if v < w then Node(Insert(l, v), w, r)
   |                                           ^

ex.dfy(20,42): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if v < w then Node(Insert(l, v), w, r)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))

   |
21 |     else if v > w then Node(l, w, Insert(r, v))
   |                                                ^

ex.dfy(21,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if v > w then Node(l, w, Insert(r, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t

   |
22 |     else t
   |           ^

ex.dfy(22,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element

SCORE
1.0
['// (4) Predicate to check if a tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{

   |
27 | {
   |  ^

ex.dfy(27,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t

   |
28 |   match t
   |          ^

ex.dfy(28,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false

   |
29 |   case Empty => false
   |                      ^

ex.dfy(29,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>

   |
30 |   case Node(l, w, r) =>
   |                        ^

ex.dfy(30,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, w, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)

   |
31 |     v == w || Contains(l, v) || Contains(r, v)
   |                                               ^

ex.dfy(31,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == w || Contains(l, v) || Contains(r, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)

SCORE
1.0
['ensures Contains(Insert(t, v), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{

   |
38 | {
   |  ^

ex.dfy(38,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
```

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package com.example.android.trackmysleepquality.sleeptracker

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.trackmysleepquality.sleeptracker\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` import { Component, OnInit } from '@angular/core';

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Component, OnInit } from '@angular/core';\n"]
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package com.example.android.miwok;

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
```

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` 

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \n']
['{\n']
['}\n']
['```\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` #include "pch.h"

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include "pch.h"\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` import {

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import {\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package com.example.android.miwok;

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` import React, { useState } from 'react'

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import React, { useState } from 'react'\n"]
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package com.github.mrbean35.admiralbulldog.sounds

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.github.mrbean35.admiralbulldog.sounds\n']
['{\n']
['}\n']
['```\n']
['lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` package com.jc.gulimall.product.service.impl;

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.jc.gulimall.product.service.impl;\n']
['ensures Contains(Insert(t, v), v)\n']
['{\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, v), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` import React from "react";

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import React from "react";\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
```

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` <?php

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                        IsBST(l, lower, v) &&
                        IsBST(r, v, upper)
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t
  case Empty => Node(Empty, v, Empty)
  case Node(l, w, r) =>
    if v < w then Node(Insert(l, v), w, r)
    else if v > w then Node(l, w, Insert(r, v))
    else t
}

// (4) Predicate to check if a tree contains a given element
predicate Contains(t: Tree, v: nat)
{
  match t
  case Empty => false
  case Node(l, w, r) =>
    v == w || Contains(l, v) || Contains(r, v)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, v: nat)
requires true
ensures Contains(Insert(t, v), v)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, v: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, v), lower, upper)
{
}
``` import {

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,24): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^^^^^^^^^^

ex.dfy(45,0): Error: a postcondition could not be proved on this return path
   |
45 | {
   | ^

ex.dfy(44,8): Related location: this is the postcondition that could not be proved
   |
44 | ensures IsBST(Insert(t, v), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,38): Related location
  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                       ^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import {\n']
['lemma InsertMaintainsIsBST(t: Tree, v: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
["``` import { Component, OnInit } from '@angular/core';\n"]
['ensures IsBST(Insert(t, v), lower, upper)\n']
['{\n']
['}\n']
['``` #include "pch.h"\n']
['{\n']
['}\n']
['```\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 177
number of gen nodes: 89 (including leaves: 29)
number of back nodes: 88 (including leaves: 60)

expansion count: 151 (including failed: 63)

cache stats {'hit': 241, 'miss': 123}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602]

Trial calls: [324, 364]


Time Statistics:

  Min: 601.00 sec, Max: 602.00 sec, Average: 601.50 sec, Standard Deviation: 0.50 sec

Call Statistics:

  Min: 324 calls, Max: 364 calls, Average: 344.00 calls, Standard Deviation: 20.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602]

Trial calls: [324, 364]


Time Statistics:

  Min: 601.00 sec, Max: 602.00 sec, Average: 601.50 sec, Standard Deviation: 0.50 sec

Call Statistics:

  Min: 324 calls, Max: 364 calls, Average: 344.00 calls, Standard Deviation: 20.00 calls

Trial  3
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

SCORE
1.0
['datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    match t

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    match t
    case Leaf => true

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    match t
    case Leaf => true
    case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(l, v, r) => v >= min && v <= max && IsBST(l, min, v - 1) && IsBST(r, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{

  |
5 | {
  |  ^

ex.dfy(5,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {

  |
6 |     match t {
  |              ^

ex.dfy(6,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>

  |
7 |         case Node(left, value, right) =>
  |                                         ^

ex.dfy(7,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>
            IsBST(left, min, value) &&

  |
8 |             IsBST(left, min, value) &&
  |                                       ^

ex.dfy(8,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>
            IsBST(left, min, value) &&
            min <= value && value <= max &&

  |
9 |             min <= value && value <= max &&
  |                                            ^

ex.dfy(9,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            min <= value && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>
            IsBST(left, min, value) &&
            min <= value && value <= max &&
            IsBST(right, value, max)

   |
10 |             IsBST(right, value, max)
   |                                     ^

ex.dfy(10,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>
            IsBST(left, min, value) &&
            min <= value && value <= max &&
            IsBST(right, value, max)
        case Leaf => true

   |
11 |         case Leaf => true
   |                          ^

ex.dfy(11,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>
            IsBST(left, min, value) &&
            min <= value && value <= max &&
            IsBST(right, value, max)
        case Leaf => true
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Node(left, value, right) =>
            IsBST(left, min, value) &&
            min <= value && value <= max &&
            IsBST(right, value, max)
        case Leaf => true
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{

  |
5 | {
  |  ^

ex.dfy(5,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {

  |
6 |     match t {
  |              ^

ex.dfy(6,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>

  |
7 |         case Node(l, v, r) =>
  |                              ^

ex.dfy(7,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>
            v >= lo && v <= hi &&

  |
8 |             v >= lo && v <= hi &&
  |                                  ^

ex.dfy(8,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            v >= lo && v <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>
            v >= lo && v <= hi &&
            IsBST(l, lo, v) &&

  |
9 |             IsBST(l, lo, v) &&
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(l, lo, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>
            v >= lo && v <= hi &&
            IsBST(l, lo, v) &&
            IsBST(r, v, hi)

   |
10 |             IsBST(r, v, hi)
   |                            ^

ex.dfy(10,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(r, v, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>
            v >= lo && v <= hi &&
            IsBST(l, lo, v) &&
            IsBST(r, v, hi)
        case Leaf => true

   |
11 |         case Leaf => true
   |                          ^

ex.dfy(11,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>
            v >= lo && v <= hi &&
            IsBST(l, lo, v) &&
            IsBST(r, v, hi)
        case Leaf => true
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Node(l, v, r) =>
            v >= lo && v <= hi &&
            IsBST(l, lo, v) &&
            IsBST(r, v, hi)
        case Leaf => true
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
  match t

  |
4 |   match t
  |   ^

ex.dfy(4,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
  match t
  case Leaf => true

  |
4 |   match t
  |   ^

ex.dfy(4,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lo: nat, hi: nat) 
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
4 |   match t
  |   ^

ex.dfy(4,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
5 |   match t
  |          ^

ex.dfy(5,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>

  |
6 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(6,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&

  |
7 |     IsBST(left, lower, value) &&
  |                                 ^

ex.dfy(7,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&

  |
8 |     lower <= value && value < upper &&
  |                                       ^

ex.dfy(8,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)

  |
9 |     IsBST(right, value, upper)
  |                               ^

ex.dfy(9,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true

   |
10 |   case Leaf => true
   |                    ^

ex.dfy(10,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t

   |
15 |   match t
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>

   |
16 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(16,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : (value == v) ? t

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : (value == v) ? t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : (value == v) ? t
                          : Node(left, v, Insert(right, value))

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                          : Node(left, v, Insert(right, value))\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : Node(left, v, Insert(right, value))

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
             : Node(left, v, Insert(right, value))
  case Leaf => Node(Leaf, value, Leaf)

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Leaf => Node(Leaf, value, Leaf)\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['             : Node(left, v, Insert(right, value))\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['              : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Node(left, value, right) =>
    IsBST(left, lower, value) &&
    lower <= value && value < upper &&
    IsBST(right, value, upper)
  case Leaf => true
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Node(left, v, right) =>
    (value < v) ? Node(Insert(left, value), v, right)
              : Node(left, v, Insert(right, value))
  case Leaf => Node(Leaf, value, Leaf)

   |
17 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(17,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Leaf => Node(Leaf, value, Leaf)\n']
['\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['             : Node(left, v, Insert(right, value))\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['              : Node(left, v, Insert(right, value))\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['{\n']
['  match t\n']
['  case Node(left, v, right) =>\n']
['    (value < v) ? Node(Insert(left, value), v, right)\n']
['             : Node(left, v, Insert(right, value))\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
    match t

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
    match t
    case Leaf => true

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat)
    match t
    case Leaf => true
    case Node(l, v, r) =>

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(l, v, r) =>\n']
['    reads t\n']
['{\n']
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true

  |
7 |         case Leaf => true
  |                          ^

ex.dfy(7,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true
        case Node(left, value, right) => 

  |
8 |         case Node(left, value, right) =>
  |                                         ^

ex.dfy(8,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true
        case Node(left, value, right) => 
            value >= min && value <= max &&

  |
9 |             value >= min && value <= max &&
  |                                            ^

ex.dfy(9,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true
        case Node(left, value, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value) && 

   |
10 |             IsBST(left, min, value) &&
   |                                       ^

ex.dfy(10,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, min, value) && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true
        case Node(left, value, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value) && 
            IsBST(right, value, max)

   |
11 |             IsBST(right, value, max)
   |                                     ^

ex.dfy(11,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true
        case Node(left, value, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value) && 
            IsBST(right, value, max)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Leaf => true
        case Node(left, value, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value) && 
            IsBST(right, value, max)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree

SCORE
1.0
['// (1) Define an ADT for a tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST

SCORE
1.0
['// (2) Define a predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true

  |
8 |   case Leaf => true
  |                    ^

ex.dfy(8,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= lo && v <= hi &&

   |
10 |     v >= lo && v <= hi &&
   |                          ^

ex.dfy(10,25): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= lo && v <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= lo && v <= hi &&
    IsBST(left, lo, v - 1) &&

   |
11 |     IsBST(left, lo, v - 1) &&
   |                              ^

ex.dfy(11,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lo, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= lo && v <= hi &&
    IsBST(left, lo, v - 1) &&
    IsBST(right, v + 1, hi)

   |
12 |     IsBST(right, v + 1, hi)
   |                            ^

ex.dfy(12,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v + 1, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= lo && v <= hi &&
    IsBST(left, lo, v - 1) &&
    IsBST(right, v + 1, hi)
}

ex.dfy(11,22): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |     IsBST(left, lo, v - 1) &&
   |                       ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t
  case Leaf => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true

  |
8 |   case Leaf => true
  |                    ^

ex.dfy(8,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
10 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element

SCORE
1.0
['// (3) Define a function for inserting an element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
19 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(19,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree

SCORE
1.0
['// (3) Define a function to insert an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
19 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(19,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['\n']
['// (3) Define a function for inserting an element\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['// (2) Define a predicate for BST\n']
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
['{\n']
['  match t\n']
['  case Leaf => true\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&

   |
10 |     value > lower &&
   |                     ^

ex.dfy(10,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value > lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&

   |
11 |     value <= upper &&
   |                      ^

ex.dfy(11,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&

   |
12 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
13 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(13,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Define a function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
20 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(20,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
21 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(21,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
   |
23 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(23,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
   |
24 |     } else if value > v {
   |                         ^

ex.dfy(24,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element

SCORE
1.0
['// (3) Define a function to insert an element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
20 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(20,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
21 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(21,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
   |
23 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(23,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function to insert an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
   |
24 |     } else if value > v {
   |                         ^

ex.dfy(24,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element

SCORE
1.0
['// (3) Define a function for inserting an element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
19 |   match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
20 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(20,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
21 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(21,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
   |
23 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(23,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define an ADT for a tree
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Define a predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value > lower &&
    value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Define a function for inserting an element
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
22 |     if value < v {
   |                  ^

ex.dfy(22,17): Error: then expected
   |
24 |     } else if value > v {
   |                         ^

ex.dfy(24,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['  match t\n']
['  case Leaf => true\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t

  |
5 |   match t
  |          ^

ex.dfy(5,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true

  |
6 |   case Leaf => true
  |                    ^

ex.dfy(6,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 

  |
7 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(7,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&

  |
8 |     value >= lower && value <= upper &&
  |                                        ^

ex.dfy(8,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

  |
9 |     IsBST(left, lower, value) &&
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
10 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(10,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t

   |
15 |   match t
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
16 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(16,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
17 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(17,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
18 |     if value < v {
   |                  ^

ex.dfy(18,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
18 |     if value < v {
   |                  ^

ex.dfy(18,17): Error: then expected
   |
19 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(19,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
18 |     if value < v {
   |                  ^

ex.dfy(18,17): Error: then expected
   |
20 |     } else if value > v {
   |                         ^

ex.dfy(20,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
18 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(18,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
19 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(19,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
20 |     else t
   |           ^

ex.dfy(20,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t

   |
25 |   match t
   |          ^

ex.dfy(25,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false

   |
26 |   case Leaf => false
   |                     ^

ex.dfy(26,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 

   |
27 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(27,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)

   |
28 |     v == value || Contains(left, value) || Contains(right, value)
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == value || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)

SCORE
1.0
["lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)

SCORE
1.0
["requires t' == Insert(t, value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true

SCORE
1.0
["ensures Contains(t', value) == true\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Leaf => 

   |
36 |   case Leaf =>
   |               ^

ex.dfy(36,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Leaf => 
  case Node(left, v, right) => 

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Leaf => 
  case Node(left, v, right) => 
    if value < v then 

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Leaf => 
  case Node(left, v, right) => 
    if value < v then 
      InsertPreservesContains(left, value, left')

   |
38 |     if value < v then 
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesContains(left, value, left')
   |                                                  ^

ex.dfy(39,49): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["      InsertPreservesContains(left, value, left')\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Node(left: Tree, value: nat, right: Tree) | Leaf

predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t
  case Leaf => true
  case Node(left, value, right) => 
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) => 
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Leaf => 
  case Node(left, v, right) => 
    if value < v then 
      InsertPreservesContains(left, value, left')
    else if value > v then 

   |
38 |     if value < v then 
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then \n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 111
number of gen nodes: 56 (including leaves: 18)
number of back nodes: 55 (including leaves: 38)

expansion count: 97 (including failed: 42)

cache stats {'hit': 194, 'miss': 179}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608]

Trial calls: [324, 364, 373]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.67 sec, Standard Deviation: 3.09 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 353.67 calls, Standard Deviation: 21.30 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608]

Trial calls: [324, 364, 373]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.67 sec, Standard Deviation: 3.09 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 353.67 calls, Standard Deviation: 21.30 calls

Trial  4
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   match t

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   match t
   case Leaf => true

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   match t
   case Leaf => true
   case Node(l, v, r) => v > lower && v < upper && IsBST(l, lower, v) && IsBST(r, v, upper)

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['   case Node(l, v, r) => v > lower && v < upper && IsBST(l, lower, v) && IsBST(r, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Leaf => true

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Leaf => true
    case Node(left, v, right) =>

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t

  |
6 |    reads t
  |          ^

ex.dfy(6,9): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['   reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {

  |
8 |   match t {
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true

  |
9 |     case Leaf => true
  |                      ^

ex.dfy(9,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 

   |
10 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value >= min && value <= max &&

   |
11 |       value >= min && value <= max &&
   |                                      ^

ex.dfy(11,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value >= min && value <= max &&
      IsBST(left, min, value) &&

   |
12 |       IsBST(left, min, value) &&
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value >= min && value <= max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)

   |
13 |       IsBST(right, value, max)
   |                               ^

ex.dfy(13,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value >= min && value <= max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   reads t
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value >= min && value <= max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

  |
6 |    reads t
  |          ^

ex.dfy(6,9): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
  match t
  case Leaf => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
  match t
  case Leaf => true
  case Node(left, v, right) => 

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree

SCORE
1.0
['// (2) Predicate for checking if a tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{ \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true

  |
8 |   case Leaf => true
  |                    ^

ex.dfy(8,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&

   |
10 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
12 |     IsBST(right, value, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{ \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
19 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(19,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) => 

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) => 
    (value < v) ? Node(Insert(left, value), v, right)

   |
21 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(21,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) => 
    (value < v) ? Node(Insert(left, value), v, right)
             : Node(left, v, Insert(right, value))

   |
21 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(21,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) => 
    (value < v) ? Node(Insert(left, value), v, right)
             : Node(left, v, Insert(right, value))
}

   |
21 |     (value < v) ? Node(Insert(left, value), v, right)
   |                 ^

ex.dfy(21,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{ \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)

   |
19 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(19,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
21 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(21,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
22 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(22,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
23 |     else t
   |           ^

ex.dfy(23,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element

SCORE
1.0
['// (4) Predicate for checking if a tree contains a given element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t

   |
29 |   match t
   |          ^

ex.dfy(29,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false

   |
30 |   case Leaf => false
   |                     ^

ex.dfy(30,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>

   |
31 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(31,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)

   |
32 |     v == value || Contains(left, value) || Contains(right, value)
   |                                                                  ^

ex.dfy(32,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == value || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element

SCORE
1.0
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
39 | {
   |  ^

ex.dfy(39,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion

SCORE
1.0
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Component, OnInit } from '@angular/core';

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Component, OnInit } from '@angular/core';\n"]
['{\n']
['}\n']
['```\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` <?php

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #include "pch.h"

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include "pch.h"\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.hadoop.hbase.regionserver;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.hadoop.hbase.regionserver;\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package com.google.android.gms.internal.ads;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.google.android.gms.internal.ads;\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['``` <?php\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.hadoop.hbase.io.hfile;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.hadoop.hbase.io.hfile;\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` ﻿using System;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \ufeffusing System;\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)

SCORE
1.0
['lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)

SCORE
1.0
['requires IsBST(t, min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)

SCORE
1.0
['ensures IsBST(Insert(t, value), min, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { createSelector } from 'reselect';

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { createSelector } from 'reselect';\n"]
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #ifndef MESH_H

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #ifndef MESH_H\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t

   |
40 |   match t
   |          ^

ex.dfy(40,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Leaf => ()

   |
41 |   case Leaf => ()
   |                  ^

ex.dfy(41,17): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => ()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Leaf => ()
  case Node(left, v, right) =>

   |
42 |   case Node(left, v, right) =>
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |   case Leaf => ()
   |                ^

ex.dfy(41,15): Error: missing semicolon at end of statement
   |
42 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(42,30): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Leaf => ()
  case Node(left, v, right) =>
    if value < v then 

   |
42 |   case Node(left, v, right) =>
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |   case Leaf => ()
   |                ^

ex.dfy(41,15): Error: missing semicolon at end of statement
   |
43 |     if value < v then
   |                  ^

ex.dfy(43,17): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    if value < v then \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Leaf => ()
  case Node(left, v, right) =>
    if value < v then 
      InsertEnsuresContains(left, value)

   |
42 |   case Node(left, v, right) =>
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |   case Leaf => ()
   |                ^

ex.dfy(41,15): Error: missing semicolon at end of statement
   |
43 |     if value < v then 
   |                  ^

ex.dfy(43,17): Error: lbrace expected
   |
44 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(44,40): Error: invalid UpdateStmt
4 parse errors detected in ex.dfy

SCORE
-1.0
['      InsertEnsuresContains(left, value)\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
40 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(40,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t

   |
41 |   match t
   |          ^

ex.dfy(41,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Leaf =>

   |
42 |   case Leaf =>
   |               ^

ex.dfy(42,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Leaf =>
  case Node(left, v, right) =>

   |
43 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(43,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Leaf =>
  case Node(left, v, right) =>
    if value < v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Leaf =>
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Leaf =>
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)
    else if value > v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
46 |     else if value > v then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > v then
   |                       ^

ex.dfy(46,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['requires true\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Injectable } from '@angular/core';

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Injectable } from '@angular/core';\n"]
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` 

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \n']
['lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.camel.component.file.remote;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.camel.component.file.remote;\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #include <iostream>

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #include <iostream>\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertMaintainsIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import { Component } from '@angular/core';

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import { Component } from '@angular/core';\n"]
['{\n']
['}\n']
['```\n']
['// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
['requires true\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t

   |
40 |   // Proof by structural induction on t
   |                                        ^

ex.dfy(40,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  match t

   |
41 |   match t
   |          ^

ex.dfy(41,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  match t
  case Leaf =>

   |
42 |   case Leaf =>
   |               ^

ex.dfy(42,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  match t
  case Leaf =>
  case Node(left, v, right) =>

   |
43 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(43,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  match t
  case Leaf =>
  case Node(left, v, right) =>
    if value < v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  match t
  case Leaf =>
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
45 |       InsertEnsuresContains(left, value)
   |                                         ^

ex.dfy(45,40): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t
  match t
  case Leaf =>
  case Node(left, v, right) =>
    if value < v then
      InsertEnsuresContains(left, value)
    else if value > v then

   |
44 |     if value < v then
   |                  ^

ex.dfy(44,17): Error: lbrace expected
   |
46 |     else if value > v then
   |     ^

ex.dfy(46,4): Error: invalid UpdateStmt
   |
46 |     else if value > v then
   |                       ^

ex.dfy(46,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Leaf => ()\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Leaf => ()
  case Node(left, v, right) =>
    if value < v then InsertEnsuresContains(left, value)

   |
42 |   case Node(left, v, right) =>
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |   case Leaf => ()
   |                ^

ex.dfy(41,15): Error: missing semicolon at end of statement
   |
43 |     if value < v then InsertEnsuresContains(left, value)
   |                  ^

ex.dfy(43,17): Error: lbrace expected
   |
43 |     if value < v then InsertEnsuresContains(left, value)
   |                                                         ^

ex.dfy(43,56): Error: invalid UpdateStmt
4 parse errors detected in ex.dfy

SCORE
None
['    if value < v then InsertEnsuresContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Leaf => ()
  case Node(left, v, right) =>
    if value < v then InsertEnsuresContains(left, value)
    else if value > v then InsertEnsuresContains(right, value)

   |
42 |   case Node(left, v, right) =>
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |   case Leaf => ()
   |                ^

ex.dfy(41,15): Error: missing semicolon at end of statement
   |
43 |     if value < v then InsertEnsuresContains(left, value)
   |                  ^

ex.dfy(43,17): Error: lbrace expected
   |
44 |     else if value > v then InsertEnsuresContains(right, value)
   |     ^

ex.dfy(44,4): Error: invalid UpdateStmt
   |
44 |     else if value > v then InsertEnsuresContains(right, value)
   |                       ^

ex.dfy(44,22): Error: lbrace expected
   |
44 |     else if value > v then InsertEnsuresContains(right, value)
   |                                                               ^

ex.dfy(44,62): Error: invalid UpdateStmt
6 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then InsertEnsuresContains(right, value)\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
['}\n']
['\n']
['// (6) Lemma about the insert function that checks the BST property continues to hold after insertion\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` import {

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` import {\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package com.example.android.miwok;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.android.miwok;\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package com.github.yamamotoj.singlemoduleapp.package04

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.github.yamamotoj.singlemoduleapp.package04\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
```

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.camel.component.file;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.camel.component.file;\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` 

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \n']
['{\n']
['}\n']
['``` <?php\n']
['lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)\n']
['requires IsBST(t, min, max)\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` #ifndef __ELASTOS_DROID_APP_CINSTRUMENTATION_H__

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` #ifndef __ELASTOS_DROID_APP_CINSTRUMENTATION_H__\n']
['{\n']
['}\n']
['``` <?php\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  case Leaf => true
  case Node(left, value, right) => 
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{ 
  match t 
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

// (4) Predicate for checking if a tree contains a given element
predicate Contains(t: Tree, value: nat)
{
  match t
  case Leaf => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

// (5) Lemma about the insert function that ensures the tree resulting from inserting an element contains that element
lemma InsertEnsuresContains(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
}

// (6) Lemma about the insert function that checks the BST property continues to hold after insertion
lemma InsertPreservesIsBST(t: Tree, value: nat, min: nat, max: nat)
requires IsBST(t, min, max)
ensures IsBST(Insert(t, value), min, max)
{
}
``` package org.apache.hadoop.hive.ql.optimizer.physical;

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,4): Related location
   |
10 |     value >= min && value <= max &&
   |     ^^^^^^^^^^^^

ex.dfy(46,0): Error: a postcondition could not be proved on this return path
   |
46 | {
   | ^

ex.dfy(45,8): Related location: this is the postcondition that could not be proved
   |
45 | ensures IsBST(Insert(t, value), min, max)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,20): Related location
   |
10 |     value >= min && value <= max &&
   |                     ^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package org.apache.hadoop.hive.ql.optimizer.physical;\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), min, max)\n']
['{\n']
['}\n']
['``` <?php\n']
['{\n']
['}\n']
['```\n']
['lemma InsertEnsuresContains(t: Tree, value: nat)\n']
['requires true\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 187
number of gen nodes: 94 (including leaves: 30)
number of back nodes: 93 (including leaves: 64)

expansion count: 158 (including failed: 65)

cache stats {'hit': 202, 'miss': 136}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601]

Trial calls: [324, 364, 373, 338]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.00 sec, Standard Deviation: 2.92 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 349.75 calls, Standard Deviation: 19.65 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601]

Trial calls: [324, 364, 373, 338]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.00 sec, Standard Deviation: 2.92 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 349.75 calls, Standard Deviation: 19.65 calls

Trial  5
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
5 |   match t
  |          ^

ex.dfy(5,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true

  |
6 |   case Empty => true
  |                     ^

ex.dfy(6,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
7 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(7,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

  |
8 |     value >= lower && value <= upper &&
  |                                        ^

ex.dfy(8,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

  |
9 |     IsBST(left, lower, value) &&
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
10 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(10,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{

   |
14 | {
   |  ^

ex.dfy(14,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t

   |
15 |   match t
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
16 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(16,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>

   |
17 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(17,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>
    if value < nodeValue {

   |
18 |     if value < nodeValue {
   |                          ^

ex.dfy(18,25): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>
    if value < nodeValue {
      Node(Insert(left, value), nodeValue, right)

   |
18 |     if value < nodeValue {
   |                          ^

ex.dfy(18,25): Error: then expected
   |
19 |       Node(Insert(left, value), nodeValue, right)
   |                                                  ^

ex.dfy(19,49): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>
    if value < nodeValue {
      Node(Insert(left, value), nodeValue, right)
    } else if value > nodeValue {

   |
18 |     if value < nodeValue {
   |                          ^

ex.dfy(18,25): Error: then expected
   |
20 |     } else if value > nodeValue {
   |                                 ^

ex.dfy(20,32): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > nodeValue {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
17 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(17,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)

   |
18 |     if value < v then Node(Insert(left, value), v, right)
   |                                                          ^

ex.dfy(18,57): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))

   |
19 |     else if value > v then Node(left, v, Insert(right, value))
   |                                                               ^

ex.dfy(19,62): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['    else if value > v then Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t

   |
20 |     else t
   |           ^

ex.dfy(20,10): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    else t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)

SCORE
1.0
['predicate Contains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t

   |
25 |   match t
   |          ^

ex.dfy(25,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false

   |
26 |   case Empty => false
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>

   |
27 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(27,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)

   |
28 |     v == value || Contains(left, value) || Contains(right, value)
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    v == value || Contains(left, value) || Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesMembership

   |
31 | lemma InsertPreservesMembership
   |                                ^

ex.dfy(31,31): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['lemma InsertPreservesMembership\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesMembership
  ensures Contains(Insert(t, value), value) == true

   |
32 |   ensures Contains(Insert(t, value), value) == true
   |   ^

ex.dfy(32,2): Error: invalid MethodDecl
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Contains(Insert(t, value), value) == true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesMembership
  ensures Contains(Insert(t, value), value) == true
{

   |
32 |   ensures Contains(Insert(t, value), value) == true
   |   ^

ex.dfy(32,2): Error: invalid MethodDecl
   |
33 | {
   |  ^

ex.dfy(33,1): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesMembership
  ensures Contains(Insert(t, value), value) == true
{
  // Proof omitted (use structural induction on t)

   |
32 |   ensures Contains(Insert(t, value), value) == true
   |   ^

ex.dfy(32,2): Error: invalid MethodDecl
   |
34 |   // Proof omitted (use structural induction on t)
   |                                                   ^

ex.dfy(34,50): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  // Proof omitted (use structural induction on t)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)

SCORE
1.0
["lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)

SCORE
1.0
["requires Contains(t, value) ==> Contains(t', value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>

   |
36 |   case Empty =>
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?left')

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesContains(left, value, ?left')
   |                                                   ^

ex.dfy(39,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["      InsertPreservesContains(left, value, ?left')\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?left')
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, left)

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesContains(left, value, left)
   |                                                 ^

ex.dfy(39,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesContains(left, value, left)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, left)
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
["      InsertPreservesContains(left, value, ?left')\n"]
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
["      InsertPreservesContains(left, value, ?left')\n"]
['    else if value > v then\n']
["requires Contains(t, value) ==> Contains(t', value)\n"]
['ensures Contains(Insert(t, value), value)\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
["      InsertPreservesContains(left, value, ?left')\n"]
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
["      InsertPreservesContains(left, value, ?left')\n"]
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?t'')

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesContains(left, value, ?t'')
   |                                                 ^

ex.dfy(39,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["      InsertPreservesContains(left, value, ?t'')\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires Contains(t, value) ==> Contains(t', value)
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?t'')
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesValue(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true

SCORE
1.0
['requires true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>

   |
36 |   case Empty =>
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value)

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesValue(left, value)
   |                                        ^

ex.dfy(39,39): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesValue(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value)
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
['      InsertPreservesValue(left, value)\n']
['    else if value > v then\n']
['ensures Contains(Insert(t, value), value)\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.

   |
35 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(35,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t

   |
36 |   match t
   |          ^

ex.dfy(36,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>

   |
37 |   case Empty =>
   |                ^

ex.dfy(37,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, v, right) =>

   |
38 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(38,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then

   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value)

   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
   |
40 |       InsertPreservesValue(left, value)
   |                                        ^

ex.dfy(40,39): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesValue(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value)
    else if value > v then

   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
   |
41 |     else if value > v then
   |     ^

ex.dfy(41,4): Error: invalid UpdateStmt
   |
41 |     else if value > v then
   |                       ^

ex.dfy(41,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  // Proof by structural induction on t.\n']
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty => () // Base case: empty tree, value is inserted.

   |
37 |   case Empty => () // Base case: empty tree, value is inserted.
   |                                                                ^

ex.dfy(37,63): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => () // Base case: empty tree, value is inserted.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty => () // Base case: empty tree, value is inserted.
  case Node(left, v, right) =>

   |
38 |   case Node(left, v, right) =>
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |   case Empty => () // Base case: empty tree, value is inserted.
   |                 ^

ex.dfy(37,16): Error: missing semicolon at end of statement
   |
38 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(38,30): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty => () // Base case: empty tree, value is inserted.
  case Node(left, v, right) =>
    if value < v then

   |
38 |   case Node(left, v, right) =>
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |   case Empty => () // Base case: empty tree, value is inserted.
   |                 ^

ex.dfy(37,16): Error: missing semicolon at end of statement
   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires true
ensures Contains(Insert(t, value), value)
{
  // Proof by structural induction on t.
  match t
  case Empty => () // Base case: empty tree, value is inserted.
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value) // Recursive case: value is in the left subtree.

   |
38 |   case Node(left, v, right) =>
   |   ^

ex.dfy(38,2): Error: invalid Suffix
   |
37 |   case Empty => () // Base case: empty tree, value is inserted.
   |                 ^

ex.dfy(37,16): Error: missing semicolon at end of statement
   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
   |
40 |       InsertPreservesValue(left, value) // Recursive case: value is in the left subtree.
   |                                                                                         ^

ex.dfy(40,88): Error: invalid UpdateStmt
4 parse errors detected in ex.dfy

SCORE
-1.0
['      InsertPreservesValue(left, value) // Recursive case: value is in the left subtree.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)

SCORE
1.0
['requires Contains(t, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)

SCORE
1.0
['ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t

   |
35 |   // Proof by cases on the structure of t
   |                                          ^

ex.dfy(35,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by cases on the structure of t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t
  match t

   |
36 |   match t
   |          ^

ex.dfy(36,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t
  match t
  case Empty =>

   |
37 |   case Empty =>
   |                ^

ex.dfy(37,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t
  match t
  case Empty =>
  case Node(left, v, right) =>

   |
38 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(38,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then

   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value)

   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
   |
40 |       InsertPreservesValue(left, value)
   |                                        ^

ex.dfy(40,39): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesValue(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
  // Proof by cases on the structure of t
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesValue(left, value)
    else if value > v then

   |
39 |     if value < v then
   |                  ^

ex.dfy(39,17): Error: lbrace expected
   |
41 |     else if value > v then
   |     ^

ex.dfy(41,4): Error: invalid UpdateStmt
   |
41 |     else if value > v then
   |                       ^

ex.dfy(41,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)

SCORE
1.0
['ensures IsBST(Insert(t, value), lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{

   |
40 | {
   |  ^

ex.dfy(40,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
```

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['```\n']
['{\n']
['}\n']
['```\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` <?php

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` <?php\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
['```\n']
['lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)\n']
['requires IsBST(t, lower, upper)\n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` import React from 'react';

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
["``` import React from 'react';\n"]
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` 

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` \n']
['ensures IsBST(Insert(t, value), lower, upper)\n']
['{\n']
['}\n']
['```\n']
['{\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesValue(t: Tree, value: nat)
requires Contains(t, value)
ensures Contains(Insert(t, value), value)
{
}

lemma InsertMaintainsBST(t: Tree, value: nat, lower: nat, upper: nat)
requires IsBST(t, lower, upper)
ensures IsBST(Insert(t, value), lower, upper)
{
}
``` package com.example.myapplication.view.activity

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^

ex.dfy(40,0): Error: a postcondition could not be proved on this return path
   |
40 | {
   | ^

ex.dfy(39,8): Related location: this is the postcondition that could not be proved
   |
39 | ensures IsBST(Insert(t, value), lower, upper)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['``` package com.example.myapplication.view.activity\n']
["lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)

SCORE
1.0
["requires t' == Insert(t, value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)

SCORE
1.0
["ensures Contains(t', value) == (Contains(t, value) || value == value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>

   |
36 |   case Empty =>
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?left')

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesContains(left, value, ?left')
   |                                                   ^

ex.dfy(39,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["      InsertPreservesContains(left, value, ?left')\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?left')
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);

   |
37 |     assert t' == Node(Empty, value, Empty);
   |                                            ^

ex.dfy(37,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert t' == Node(Empty, value, Empty);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value) == true;

   |
38 |     assert Contains(t', value) == true;
   |                                        ^

ex.dfy(38,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert Contains(t', value) == true;\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value) == true;
  case Node(left, v, right) =>

   |
39 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(39,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value) == true;
  case Node(left, v, right) =>
    if value < v then

   |
40 |     if value < v then
   |                  ^

ex.dfy(40,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value) == true;
  case Node(left, v, right) =>
    if value < v then
      assert t' == Node(Insert(left, value), v, right);

   |
40 |     if value < v then
   |                  ^

ex.dfy(40,17): Error: lbrace expected
   |
41 |       assert t' == Node(Insert(left, value), v, right);
   |                                                        ^

ex.dfy(41,55): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
["      assert t' == Node(Insert(left, value), v, right);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == (Contains(t, value) || value == value)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value) == true;
  case Node(left, v, right) =>
    if value < v then
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesContains(left, value, Insert(left, value));

   |
40 |     if value < v then
   |                  ^

ex.dfy(40,17): Error: lbrace expected
   |
42 |       InsertPreservesContains(left, value, Insert(left, value));
   |                                                                 ^

ex.dfy(42,64): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      InsertPreservesContains(left, value, Insert(left, value));\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true

SCORE
1.0
["ensures Contains(t', value) == true\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty => 

   |
36 |   case Empty =>
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty => 
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty => 
  case Node(left, v, right) =>
    if value < v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty => 
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?left')

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesContains(left, value, ?left')
   |                                                   ^

ex.dfy(39,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["      InsertPreservesContains(left, value, ?left')\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty => 
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesContains(left, value, ?left')
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>

   |
36 |   case Empty =>
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;

   |
37 |     assert t == Empty;
   |                       ^

ex.dfy(37,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert t == Empty;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);

   |
38 |     assert t' == Node(Empty, value, Empty);
   |                                            ^

ex.dfy(38,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert t' == Node(Empty, value, Empty);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(Node(Empty, value, Empty), value) == true;

   |
39 |     assert Contains(Node(Empty, value, Empty), value) == true;
   |                                                               ^

ex.dfy(39,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert Contains(Node(Empty, value, Empty), value) == true;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(Node(Empty, value, Empty), value) == true;
  case Node(left, v, right) =>

   |
40 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(40,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(Node(Empty, value, Empty), value) == true;
  case Node(left, v, right) =>
    if value < v then

   |
41 |     if value < v then
   |                  ^

ex.dfy(41,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(Node(Empty, value, Empty), value) == true;
  case Node(left, v, right) =>
    if value < v then
      assert t' == Node(Insert(left, value), v, right);

   |
41 |     if value < v then
   |                  ^

ex.dfy(41,17): Error: lbrace expected
   |
42 |       assert t' == Node(Insert(left, value), v, right);
   |                                                        ^

ex.dfy(42,55): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
["      assert t' == Node(Insert(left, value), v, right);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesContains(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value) == true
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(Node(Empty, value, Empty), value) == true;
  case Node(left, v, right) =>
    if value < v then
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesContains(left, value, Insert(left, value));

   |
41 |     if value < v then
   |                  ^

ex.dfy(41,17): Error: lbrace expected
   |
43 |       InsertPreservesContains(left, value, Insert(left, value));
   |                                                                 ^

ex.dfy(43,64): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      InsertPreservesContains(left, value, Insert(left, value));\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
['  case Node(left, v, right) =>\n']
['    if value < v then\n']
['      InsertPreservesValue(left, value)\n']
['    else if value > v then\n']
['predicate Contains(t: Tree, value: nat)\n']
['{\n']
['  match t\n']
['  case Empty => false\n']
['  case Node(left, v, right) =>\n']
['    v == value || Contains(left, value) || Contains(right, value)\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)

SCORE
1.0
["lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)

SCORE
1.0
["requires t' == Insert(t, value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)

SCORE
1.0
["ensures Contains(t', value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{

   |
34 | {
   |  ^

ex.dfy(34,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t

   |
35 |   match t
   |          ^

ex.dfy(35,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>

   |
36 |   case Empty =>
   |                ^

ex.dfy(36,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>

   |
37 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(37,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesElement(left, value, left')

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
39 |       InsertPreservesElement(left, value, left')
   |                                                 ^

ex.dfy(39,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
["      InsertPreservesElement(left, value, left')\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
  case Node(left, v, right) =>
    if value < v then
      InsertPreservesElement(left, value, left')
    else if value > v then

   |
38 |     if value < v then
   |                  ^

ex.dfy(38,17): Error: lbrace expected
   |
40 |     else if value > v then
   |     ^

ex.dfy(40,4): Error: invalid UpdateStmt
   |
40 |     else if value > v then
   |                       ^

ex.dfy(40,22): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    else if value > v then\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;

   |
37 |     assert t == Empty;
   |                       ^

ex.dfy(37,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    assert t == Empty;\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);

   |
38 |     assert t' == Node(Empty, value, Empty);
   |                                            ^

ex.dfy(38,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert t' == Node(Empty, value, Empty);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);

   |
39 |     assert Contains(t', value);
   |                                ^

ex.dfy(39,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert Contains(t', value);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>

   |
40 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(40,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {

   |
41 |     if value < v {
   |                   ^

ex.dfy(41,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);

   |
42 |       assert t' == Node(Insert(left, value), v, right);
   |                                                        ^

ex.dfy(42,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert t' == Node(Insert(left, value), v, right);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));

   |
43 |       InsertPreservesElement(left, value, Insert(left, value));
   |                                                                ^

ex.dfy(43,63): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesElement(left, value, Insert(left, value));\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {

   |
44 |     } else if value > v {
   |                          ^

ex.dfy(44,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));

   |
45 |       assert t' == Node(left, v, Insert(right, value));
   |                                                        ^

ex.dfy(45,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert t' == Node(left, v, Insert(right, value));\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));

   |
46 |       InsertPreservesElement(right, value, Insert(right, value));
   |                                                                  ^

ex.dfy(46,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertPreservesElement(right, value, Insert(right, value));\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {

   |
47 |     } else {
   |             ^

ex.dfy(47,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;

   |
48 |       assert t' == t;
   |                      ^

ex.dfy(48,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert t' == t;\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);

   |
49 |       assert Contains(t', value);
   |                                  ^

ex.dfy(49,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert Contains(t', value);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }

   |
50 |     }
   |      ^

ex.dfy(50,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)

SCORE
1.0
["lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)

SCORE
1.0
["requires t' == Insert(t, value)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)

SCORE
1.0
['requires IsBST(t, lower, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)

SCORE
1.0
["ensures IsBST(t', lower, upper)\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{

   |
57 | {
   |  ^

ex.dfy(57,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t

   |
58 |   match t
   |          ^

ex.dfy(58,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>

   |
59 |   case Empty =>
   |                ^

ex.dfy(59,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);

   |
60 |     assert t' == Node(Empty, value, Empty);
   |                                            ^

ex.dfy(60,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert t' == Node(Empty, value, Empty);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);

   |
61 |     assert IsBST(t', lower, upper);
   |                                    ^

ex.dfy(61,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["    assert IsBST(t', lower, upper);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>

   |
62 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(62,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {

   |
63 |     if value < v {
   |                   ^

ex.dfy(63,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);

   |
64 |       assert t' == Node(Insert(left, value), v, right);
   |                                                        ^

ex.dfy(64,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert t' == Node(Insert(left, value), v, right);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);

   |
65 |       InsertMaintainsBST(left, value, Insert(left, value), lower, v);
   |                                                                      ^

ex.dfy(65,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(left, value, Insert(left, value), lower, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {

   |
66 |     } else if value > v {
   |                          ^

ex.dfy(66,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));

   |
67 |       assert t' == Node(left, v, Insert(right, value));
   |                                                        ^

ex.dfy(67,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert t' == Node(left, v, Insert(right, value));\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertMaintainsBST(right, value, Insert(right, value), v, upper);

   |
68 |       InsertMaintainsBST(right, value, Insert(right, value), v, upper);
   |                                                                        ^

ex.dfy(68,71): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      InsertMaintainsBST(right, value, Insert(right, value), v, upper);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertMaintainsBST(right, value, Insert(right, value), v, upper);
    } else {

   |
69 |     } else {
   |             ^

ex.dfy(69,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    } else {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertMaintainsBST(right, value, Insert(right, value), v, upper);
    } else {
      assert t' == t;

   |
70 |       assert t' == t;
   |                      ^

ex.dfy(70,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert t' == t;\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertMaintainsBST(right, value, Insert(right, value), v, upper);
    } else {
      assert t' == t;
      assert IsBST(t', lower, upper);

   |
71 |       assert IsBST(t', lower, upper);
   |                                      ^

ex.dfy(71,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
["      assert IsBST(t', lower, upper);\n"]
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertMaintainsBST(right, value, Insert(right, value), v, upper);
    } else {
      assert t' == t;
      assert IsBST(t', lower, upper);
    }

   |
72 |     }
   |      ^

ex.dfy(72,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v then Node(Insert(left, value), v, right)
    else if value > v then Node(left, v, Insert(right, value))
    else t
}

predicate Contains(t: Tree, value: nat)
{
  match t
  case Empty => false
  case Node(left, v, right) =>
    v == value || Contains(left, value) || Contains(right, value)
}

lemma InsertPreservesElement(t: Tree, value: nat, t': Tree)
requires t' == Insert(t, value)
ensures Contains(t', value)
{
  match t
  case Empty =>
    assert t == Empty;
    assert t' == Node(Empty, value, Empty);
    assert Contains(t', value);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertPreservesElement(left, value, Insert(left, value));
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertPreservesElement(right, value, Insert(right, value));
    } else {
      assert t' == t;
      assert Contains(t', value);
    }
}

lemma InsertMaintainsBST(t: Tree, value: nat, t': Tree, lower: nat, upper: nat)
requires t' == Insert(t, value)
requires IsBST(t, lower, upper)
ensures IsBST(t', lower, upper)
{
  match t
  case Empty =>
    assert t' == Node(Empty, value, Empty);
    assert IsBST(t', lower, upper);
  case Node(left, v, right) =>
    if value < v {
      assert t' == Node(Insert(left, value), v, right);
      InsertMaintainsBST(left, value, Insert(left, value), lower, v);
    } else if value > v {
      assert t' == Node(left, v, Insert(right, value));
      InsertMaintainsBST(right, value, Insert(right, value), v, upper);
    } else {
      assert t' == t;
      assert IsBST(t', lower, upper);
    }
}

ex.dfy(61,11): Error: assertion might not hold
   |
61 |     assert IsBST(t', lower, upper);
   |            ^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,22): Related location
  |
8 |     value >= lower && value <= upper &&
  |                       ^^^^^^^^^^^^^^

ex.dfy(61,11): Error: assertion might not hold
   |
61 |     assert IsBST(t', lower, upper);
   |            ^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,4): Related location
  |
8 |     value >= lower && value <= upper &&
  |     ^^^^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
["    assert t' == Node(Empty, value, Empty);\n"]
["    assert IsBST(t', lower, upper);\n"]
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
["      assert t' == Node(Insert(left, value), v, right);\n"]
['      InsertMaintainsBST(left, value, Insert(left, value), lower, v);\n']
['    } else if value > v {\n']
["      assert t' == Node(left, v, Insert(right, value));\n"]
['      InsertMaintainsBST(right, value, Insert(right, value), v, upper);\n']
['    } else {\n']
["      assert t' == t;\n"]
["      assert IsBST(t', lower, upper);\n"]
['    }\n']
['}\n']
["ensures IsBST(t', lower, upper)\n"]
['{\n']
['  match t\n']
['  case Empty =>\n']
["    assert t' == Node(Empty, value, Empty);\n"]
["    assert IsBST(t', lower, upper);\n"]
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
["      assert t' == Node(Insert(left, value), v, right);\n"]
['      InsertMaintainsBST(left, value, Insert(left, value), lower, v);\n']
['    } else if value > v {\n']
["      assert t' == Node(left, v, Insert(right, value));\n"]
['      InsertMaintainsBST(right, value, Insert(right, value), v, upper);\n']
['    } else {\n']
["      assert t' == t;\n"]
["      assert IsBST(t', lower, upper);\n"]
['    }\n']
['}\n']
['{\n']
['  match t\n']
['  case Empty =>\n']
["    assert t' == Node(Empty, value, Empty);\n"]
["    assert IsBST(t', lower, upper);\n"]
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
["      assert t' == Node(Insert(left, value), v, right);\n"]
['      InsertMaintainsBST(left, value, Insert(left, value), lower, v);\n']
['    } else if value > v {\n']
["      assert t' == Node(left, v, Insert(right, value));\n"]
['      InsertMaintainsBST(right, value, Insert(right, value), v, upper);\n']
['    } else {\n']
["      assert t' == t;\n"]
["      assert IsBST(t', lower, upper);\n"]
['    }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 107
number of gen nodes: 54 (including leaves: 14)
number of back nodes: 53 (including leaves: 40)

expansion count: 88 (including failed: 35)

cache stats {'hit': 167, 'miss': 173}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607]

Trial calls: [324, 364, 373, 338, 340]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.80 sec, Standard Deviation: 3.06 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 347.80 calls, Standard Deviation: 18.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607]

Trial calls: [324, 364, 373, 338, 340]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.80 sec, Standard Deviation: 3.06 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 347.80 calls, Standard Deviation: 18.00 calls

Trial  6
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{

  |
5 | {
  |  ^

ex.dfy(5,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {

  |
6 |     match t {
  |              ^

ex.dfy(6,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true

  |
7 |         case Empty => true
  |                           ^

ex.dfy(7,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(l, v, r) => v >= lo && v <= hi && IsBST(l, lo, v) && IsBST(r, v, hi)

  |
8 |         case Node(l, v, r) => v >= lo && v <= hi && IsBST(l, lo, v) && IsBST(r, v, hi)
  |                                                                                       ^

ex.dfy(8,86): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(l, v, r) => v >= lo && v <= hi && IsBST(l, lo, v) && IsBST(r, v, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(l, v, r) => v >= lo && v <= hi && IsBST(l, lo, v) && IsBST(r, v, hi)
    }

  |
9 |     }
  |      ^

ex.dfy(9,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(l, v, r) => v >= lo && v <= hi && IsBST(l, lo, v) && IsBST(r, v, hi)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['    reads t\n']
['{\n']
['    match t {\n']
['        case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(l, v, r) => lo < v && v < hi && IsBST(l, lo, v) && IsBST(r, v, hi)

  |
8 |         case Node(l, v, r) => lo < v && v < hi && IsBST(l, lo, v) && IsBST(r, v, hi)
  |                                                                                     ^

ex.dfy(8,84): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(l, v, r) => lo < v && v < hi && IsBST(l, lo, v) && IsBST(r, v, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(l, v, r) => lo < v && v < hi && IsBST(l, lo, v) && IsBST(r, v, hi)
    }

  |
9 |     }
  |      ^

ex.dfy(9,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(l, v, r) => lo < v && v < hi && IsBST(l, lo, v) && IsBST(r, v, hi)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{

  |
5 | {
  |  ^

ex.dfy(5,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {

  |
6 |     match t {
  |              ^

ex.dfy(6,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true

  |
7 |         case Empty => true
  |                           ^

ex.dfy(7,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>

  |
8 |         case Node(left, value, right) =>
  |                                         ^

ex.dfy(8,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lower <= value && value < upper &&

  |
9 |             lower <= value && value < upper &&
  |                                               ^

ex.dfy(9,46): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lower <= value && value < upper &&
            IsBST(left, lower, value) &&

   |
10 |             IsBST(left, lower, value) &&
   |                                         ^

ex.dfy(10,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lower <= value && value < upper &&
            IsBST(left, lower, value) &&
            IsBST(right, value, upper)

   |
11 |             IsBST(right, value, upper)
   |                                       ^

ex.dfy(11,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lower <= value && value < upper &&
            IsBST(left, lower, value) &&
            IsBST(right, value, upper)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lower <= value && value < upper &&
            IsBST(left, lower, value) &&
            IsBST(right, value, upper)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
4 |   match t
  |   ^

ex.dfy(4,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Empty => true

  |
4 |   match t
  |   ^

ex.dfy(4,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Empty => true
  case Node(left, value, right) => 

  |
4 |   match t
  |   ^

ex.dfy(4,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) => \n']
['\n']
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
['    reads t\n']
['{\n']
['    match t {\n']
['        case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 

  |
8 |         case Node(left, value, right) =>
  |                                         ^

ex.dfy(8,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 
            IsBST(left, lower, value) && 

  |
9 |             IsBST(left, lower, value) &&
  |                                         ^

ex.dfy(9,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, lower, value) && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 
            IsBST(left, lower, value) && 
            value <= upper && 

   |
10 |             value <= upper &&
   |                              ^

ex.dfy(10,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            value <= upper && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 
            IsBST(left, lower, value) && 
            value <= upper && 
            value >= lower && 

   |
11 |             value >= lower &&
   |                              ^

ex.dfy(11,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            value >= lower && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 
            IsBST(left, lower, value) && 
            value <= upper && 
            value >= lower && 
            IsBST(right, value, upper)

   |
12 |             IsBST(right, value, upper)
   |                                       ^

ex.dfy(12,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 
            IsBST(left, lower, value) && 
            value <= upper && 
            value >= lower && 
            IsBST(right, value, upper)
    }

   |
13 |     }
   |      ^

ex.dfy(13,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) => 
            IsBST(left, lower, value) && 
            value <= upper && 
            value >= lower && 
            IsBST(right, value, upper)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Empty => true

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Empty => true
    case Node(left, value, right) => 

  |
4 |     match t
  |     ^

ex.dfy(4,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, value, right) => \n']
['    reads t\n']
['{\n']
['    match t {\n']
['        case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>

  |
8 |         case Node(left, value, right) =>
  |                                         ^

ex.dfy(8,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            value >= lo && value <= hi &&

  |
9 |             value >= lo && value <= hi &&
  |                                          ^

ex.dfy(9,41): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            value >= lo && value <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            value >= lo && value <= hi &&
            IsBST(left, lo, value) &&

   |
10 |             IsBST(left, lo, value) &&
   |                                      ^

ex.dfy(10,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            value >= lo && value <= hi &&
            IsBST(left, lo, value) &&
            IsBST(right, value, hi)

   |
11 |             IsBST(right, value, hi)
   |                                    ^

ex.dfy(11,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            value >= lo && value <= hi &&
            IsBST(left, lo, value) &&
            IsBST(right, value, hi)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            value >= lo && value <= hi &&
            IsBST(left, lo, value) &&
            IsBST(right, value, hi)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree

SCORE
1.0
['// (1) Define the tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

SCORE
1.0
['datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST

SCORE
1.0
['// (2) Define the predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
  match t
  case Node(value, left, right) =>

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
  match t
  case Node(value, left, right) =>
    value <= max && value >= min &&

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    value <= max && value >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t
   case Null => true

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t
   case Null => true
   case Node(v, left, right) =>

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['   case Node(v, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t

  |
6 |    reads t
  |          ^

ex.dfy(6,9): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['   reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {

  |
8 |    match t {
  |             ^

ex.dfy(8,12): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['   match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>

  |
9 |       case Node(value, left, right) =>
  |                                       ^

ex.dfy(9,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>
         value <= upper && value >= lower &&

   |
10 |          value <= upper && value >= lower &&
   |                                             ^

ex.dfy(10,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['         value <= upper && value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>
         value <= upper && value >= lower &&
         IsBST(left, lower, value) &&

   |
11 |          IsBST(left, lower, value) &&
   |                                      ^

ex.dfy(11,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['         IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>
         value <= upper && value >= lower &&
         IsBST(left, lower, value) &&
         IsBST(right, value, upper)

   |
12 |          IsBST(right, value, upper)
   |                                    ^

ex.dfy(12,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['         IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>
         value <= upper && value >= lower &&
         IsBST(left, lower, value) &&
         IsBST(right, value, upper)
      case Null => true

   |
13 |       case Null => true
   |                        ^

ex.dfy(13,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>
         value <= upper && value >= lower &&
         IsBST(left, lower, value) &&
         IsBST(right, value, upper)
      case Null => true
   }

   |
14 |    }
   |     ^

ex.dfy(14,4): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['   }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
   reads t
{
   match t {
      case Node(value, left, right) =>
         value <= upper && value >= lower &&
         IsBST(left, lower, value) &&
         IsBST(right, value, upper)
      case Null => true
   }
}

  |
6 |    reads t
  |          ^

ex.dfy(6,9): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
6 |   match t {
  |            ^

ex.dfy(6,11): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Node(value, left, right) => 

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Node(value, left, right) =>
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Node(value, left, right) => 
      value <= upper && value >= lower &&

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Node(value, left, right) => 
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
-1.0
['      value <= upper && value >= lower &&\n']
['// (2) Define the predicate for BST\n']
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Node(value, left, right) => 

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Node(value, left, right) => 
        lower <= value <= upper &&

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['        lower <= value <= upper &&\n']
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Node(v, left, right) => 

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(v, left, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Node(v, left, right) => 
        v >= lower && v < upper &&

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['        v >= lower && v < upper &&\n']
['   match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t
   case Node(value, left, right) => 

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   case Node(value, left, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t
   case Node(value, left, right) => 
      value <= max && value >= min &&

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['      value <= max && value >= min &&\n']
['predicate IsBST(t: Tree, lo: nat, hi: nat) \n']
['    reads t\n']
['{\n']
['    match t {\n']
['        case Empty => true\n']
['        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lo <= value && value < hi &&

  |
9 |             lo <= value && value < hi &&
  |                                         ^

ex.dfy(9,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            lo <= value && value < hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lo <= value && value < hi &&
            IsBST(left, lo, value) &&

   |
10 |             IsBST(left, lo, value) &&
   |                                      ^

ex.dfy(10,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lo <= value && value < hi &&
            IsBST(left, lo, value) &&
            IsBST(right, value, hi)

   |
11 |             IsBST(right, value, hi)
   |                                    ^

ex.dfy(11,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lo <= value && value < hi &&
            IsBST(left, lo, value) &&
            IsBST(right, value, hi)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
    reads t
{
    match t {
        case Empty => true
        case Node(left, value, right) =>
            lo <= value && value < hi &&
            IsBST(left, lo, value) &&
            IsBST(right, value, hi)
    }
}

  |
4 |     reads t
  |           ^

ex.dfy(4,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
['// (2) Define the predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 

SCORE
1.0
['predicate IsBST(t: Tree, min: int, max: int) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t

  |
6 |     reads t
  |           ^

ex.dfy(6,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {

  |
8 |     match t {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true

  |
9 |         case Null => true
  |                          ^

ex.dfy(9,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true
        case Node(value, left, right) => 

   |
10 |         case Node(value, left, right) =>
   |                                         ^

ex.dfy(10,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(value, left, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true
        case Node(value, left, right) => 
            value >= min && value <= max &&

   |
11 |             value >= min && value <= max &&
   |                                            ^

ex.dfy(11,43): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true
        case Node(value, left, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value - 1) &&

   |
12 |             IsBST(left, min, value - 1) &&
   |                                           ^

ex.dfy(12,42): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true
        case Node(value, left, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value - 1) &&
            IsBST(right, value + 1, max)

   |
13 |             IsBST(right, value + 1, max)
   |                                         ^

ex.dfy(13,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true
        case Node(value, left, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value - 1) &&
            IsBST(right, value + 1, max)
    }

   |
14 |     }
   |      ^

ex.dfy(14,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
    reads t
{
    match t {
        case Null => true
        case Node(value, left, right) => 
            value >= min && value <= max &&
            IsBST(left, min, value - 1) &&
            IsBST(right, value + 1, max)
    }
}

  |
6 |     reads t
  |           ^

ex.dfy(6,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {

  |
8 |   match t {
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true

  |
9 |     case Null => true
  |                      ^

ex.dfy(9,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true
    case Node(value, left, right) =>

   |
10 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true
    case Node(value, left, right) =>
      min < value && value < max &&

   |
11 |       min < value && value < max &&
   |                                    ^

ex.dfy(11,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      min < value && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true
    case Node(value, left, right) =>
      min < value && value < max &&
      IsBST(left, min, value) &&

   |
12 |       IsBST(left, min, value) &&
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true
    case Node(value, left, right) =>
      min < value && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)

   |
13 |       IsBST(right, value, max)
   |                               ^

ex.dfy(13,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true
    case Node(value, left, right) =>
      min < value && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, min: int, max: int) 
  reads t
{
  match t {
    case Null => true
    case Node(value, left, right) =>
      min < value && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

  |
6 |   reads t
  |         ^

ex.dfy(6,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Null => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Null => true
  case Node(value, left, right) => 

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(value, left, right) => \n']
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Null => true

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Null => true
    case Node(value, left, right) => 

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(value, left, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{

  |
4 | {
  |  ^

ex.dfy(4,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {

  |
5 |   match t {
  |            ^

ex.dfy(5,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true

  |
6 |     case Empty => true
  |                       ^

ex.dfy(6,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>

  |
7 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(7,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      v >= lo && v <= hi &&

  |
8 |       v >= lo && v <= hi &&
  |                            ^

ex.dfy(8,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      v >= lo && v <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      v >= lo && v <= hi &&
      IsBST(left, lo, v - 1) &&

  |
9 |       IsBST(left, lo, v - 1) &&
  |                                ^

ex.dfy(9,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lo, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      v >= lo && v <= hi &&
      IsBST(left, lo, v - 1) &&
      IsBST(right, v + 1, hi)

   |
10 |       IsBST(right, v + 1, hi)
   |                              ^

ex.dfy(10,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, v + 1, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      v >= lo && v <= hi &&
      IsBST(left, lo, v - 1) &&
      IsBST(right, v + 1, hi)
  }

   |
11 |   }
   |    ^

ex.dfy(11,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

predicate IsBST(t: Tree, lo: nat, hi: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      v >= lo && v <= hi &&
      IsBST(left, lo, v - 1) &&
      IsBST(right, v + 1, hi)
  }
}

ex.dfy(9,24): Error: value does not satisfy the subset constraints of 'nat'
  |
9 |       IsBST(left, lo, v - 1) &&
  |                         ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true

  |
8 |     case Null => true
  |                      ^

ex.dfy(8,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&

  |
9 |     case Node(v, left, right) => v >= lower && v < upper &&
  |                                                            ^

ex.dfy(9,59): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(v, left, right) => v >= lower && v < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&

   |
10 |                                 IsBST(left, lower, v) &&
   |                                                         ^

ex.dfy(10,56): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['                                IsBST(left, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)

   |
11 |                                 IsBST(right, v, upper)
   |                                                       ^

ex.dfy(11,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                                IsBST(right, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function

SCORE
1.0
['// (3) Define the insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {

   |
18 |   match t {
   |            ^

ex.dfy(18,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)

   |
19 |     case Null => Node(v, Null, Null)
   |                                     ^

ex.dfy(19,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => Node(v, Null, Null)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>

   |
20 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(20,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value

   |
21 |       (if v < value
   |                    ^

ex.dfy(21,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      (if v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)

   |
22 |        then Node(value, Insert(left, v), right)
   |                                                ^

ex.dfy(22,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       then Node(value, Insert(left, v), right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value

   |
23 |        else if v > value
   |                         ^

ex.dfy(23,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['       else if v > value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))

   |
24 |             then Node(value, left, Insert(right, v))
   |                                                     ^

ex.dfy(24,52): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            then Node(value, left, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)

   |
25 |             else t)
   |                    ^

ex.dfy(25,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else t)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }

   |
26 |   }
   |    ^

ex.dfy(26,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element

SCORE
1.0
['// (4) Define the predicate for containing an element\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)

SCORE
1.0
['predicate Contains(t: Tree, v: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{

   |
31 | {
   |  ^

ex.dfy(31,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {

   |
32 |   match t {
   |            ^

ex.dfy(32,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false

   |
33 |     case Null => false
   |                       ^

ex.dfy(33,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>

   |
34 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(34,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value

   |
35 |       (if v < value
   |                    ^

ex.dfy(35,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      (if v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)

   |
36 |        then Contains(left, v)
   |                              ^

ex.dfy(36,29): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       then Contains(left, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value

   |
37 |        else if v > value
   |                         ^

ex.dfy(37,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['       else if v > value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)

   |
38 |             then Contains(right, v)
   |                                    ^

ex.dfy(38,35): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            then Contains(right, v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)

   |
39 |             else true)
   |                       ^

ex.dfy(39,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            else true)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }

   |
40 |   }
   |    ^

ex.dfy(40,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion

SCORE
1.0
['// (5) Define the lemma for insertion\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)

SCORE
1.0
['  requires Contains(t, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Contains(Insert(t, v), (v == w ? v : w))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))
{

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))
{
  match t {

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)

SCORE
1.0
['  ensures Contains(Insert(t, v), w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {

   |
48 |   match t {
   |            ^

ex.dfy(48,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>

   |
49 |     case Null =>
   |                 ^

ex.dfy(49,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>

   |
50 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(50,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value

   |
51 |       (if v < value
   |                    ^

ex.dfy(51,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      (if v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)

   |
52 |        then InsertPreservesContains(left, v, w)
   |                                                ^

ex.dfy(52,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       then InsertPreservesContains(left, v, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value

   |
53 |        else if v > value
   |                         ^

ex.dfy(53,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['       else if v > value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)

   |
54 |             then InsertPreservesContains(right, v, w)
   |                                                      ^

ex.dfy(54,53): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            then InsertPreservesContains(right, v, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})

   |
55 |             else {})
   |                     ^

ex.dfy(55,20): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['            else {})\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}


   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}

// (6) Define the lemma for BST property

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Define the lemma for BST property\n']
['{\n']
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()

   |
49 |     case Null => ()
   |                    ^

ex.dfy(49,19): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => ()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()
    case Node(value, left, right) =>

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
50 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(50,36): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()
    case Node(value, left, right) =>
      (if v < value

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
51 |       (if v < value
   |                    ^

ex.dfy(51,19): Error: then expected
3 parse errors detected in ex.dfy

SCORE
None
['      (if v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
52 |        then InsertPreservesContains(left, v, w)
   |                                                ^

ex.dfy(52,47): Error: else expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['       then InsertPreservesContains(left, v, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));

SCORE
1.0
['  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
{

   |
45 |   ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
   |                                                                  ^

ex.dfy(45,65): Warning: deprecated style: a semi-colon is not needed here
   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
{
  match t {

   |
45 |   ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
   |                                                                  ^

ex.dfy(45,65): Warning: deprecated style: a semi-colon is not needed here
   |
47 |   match t {
   |            ^

ex.dfy(47,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match t {\n']
['{\n']
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)

SCORE
1.0
['lemma InsertPreservesElement(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v

SCORE
1.0
['  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{

   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  // Proof by structural induction on t.

   |
47 |   // Proof by structural induction on t.
   |                                         ^

ex.dfy(47,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Proof by structural induction on t.\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  // Proof by structural induction on t.
  match t {

   |
48 |   match t {
   |            ^

ex.dfy(48,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  // Proof by structural induction on t.
  match t {
    case Null => ()

   |
49 |     case Null => ()
   |                    ^

ex.dfy(49,19): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => ()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  // Proof by structural induction on t.
  match t {
    case Null => ()
    case Node(value, left, right) =>

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
50 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(50,36): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  // Proof by structural induction on t.
  match t {
    case Null => ()
    case Node(value, left, right) =>
      if v < value {

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
51 |       if v < value {
   |                     ^

ex.dfy(51,20): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['      if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  // Proof by structural induction on t.
  match t {
    case Null => ()
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesElement(left, v, w);

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
52 |         InsertPreservesElement(left, v, w);
   |                                            ^

ex.dfy(52,43): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        InsertPreservesElement(left, v, w);\n']
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  match t {

   |
47 |   match t {
   |            ^

ex.dfy(47,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  match t {
    case Null => ()

   |
48 |     case Null => ()
   |                    ^

ex.dfy(48,19): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => ()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  match t {
    case Null => ()
    case Node(value, left, right) =>

   |
49 |     case Node(value, left, right) =>
   |     ^

ex.dfy(49,4): Error: invalid Suffix
   |
48 |     case Null => ()
   |                  ^

ex.dfy(48,17): Error: missing semicolon at end of statement
   |
49 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(49,36): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  match t {
    case Null => ()
    case Node(value, left, right) =>
      if v < value {

   |
49 |     case Node(value, left, right) =>
   |     ^

ex.dfy(49,4): Error: invalid Suffix
   |
48 |     case Null => ()
   |                  ^

ex.dfy(48,17): Error: missing semicolon at end of statement
   |
50 |       if v < value {
   |                     ^

ex.dfy(50,20): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['      if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, w), v) <==> Contains(t, v) || w == v
{
  match t {
    case Null => ()
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesElement(left, v, w);

   |
49 |     case Node(value, left, right) =>
   |     ^

ex.dfy(49,4): Error: invalid Suffix
   |
48 |     case Null => ()
   |                  ^

ex.dfy(48,17): Error: missing semicolon at end of statement
   |
51 |         InsertPreservesElement(left, v, w);
   |                                            ^

ex.dfy(51,43): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['        InsertPreservesElement(left, v, w);\n']
['  ensures Contains(Insert(t, v), w)\n']
['{\n']
['  match t {\n']
['    case Null =>\n']
['    case Node(value, left, right) =>\n']
['      (if v < value\n']
['       then InsertPreservesContains(left, v, w)\n']
['       else if v > value\n']
['            then InsertPreservesContains(right, v, w)\n']
['            else {})\n']
['  }\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}

// (6) Define the lemma for BST preservation

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Define the lemma for BST preservation\n']
['{\n']
['  match t {\n']
['    case Null =>\n']
['    case Node(value, left, right) =>\n']
['      (if v < value\n']
['       then InsertPreservesContains(left, v, w)\n']
['       else if v > value\n']
['            then InsertPreservesContains(right, v, w)\n']
['            else {})\n']
['  }\n']
['}\n']
['\n']
['// (6) Define the lemma for BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership

SCORE
1.0
['// (5) Lemma about the insert function preserving containership\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)

SCORE
1.0
['lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)

SCORE
1.0
['  requires Contains(t, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Contains(Insert(t, v), (v == w ? v : w))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))
{

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))
{
  match t {

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)

SCORE
1.0
['  ensures Contains(Insert(t, v), w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {

   |
48 |   match t {
   |            ^

ex.dfy(48,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>

   |
49 |     case Null =>
   |                 ^

ex.dfy(49,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>

   |
50 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(50,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {

   |
51 |       if v < value {
   |                     ^

ex.dfy(51,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesContainership(left, v, w);

   |
52 |         InsertPreservesContainership(left, v, w);
   |                                                  ^

ex.dfy(52,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesContainership(left, v, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesContainership(left, v, w);
      } else if v > value {

   |
53 |       } else if v > value {
   |                            ^

ex.dfy(53,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if v > value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesContainership(left, v, w);
      } else if v > value {
        InsertPreservesContainership(right, v, w);

   |
54 |         InsertPreservesContainership(right, v, w);
   |                                                   ^

ex.dfy(54,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesContainership(right, v, w);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesContainership(left, v, w);
      } else if v > value {
        InsertPreservesContainership(right, v, w);
      }

   |
55 |       }
   |        ^

ex.dfy(55,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesContainership(left, v, w);
      } else if v > value {
        InsertPreservesContainership(right, v, w);
      }
  }

   |
56 |   }
   |    ^

ex.dfy(56,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      if v < value {
        InsertPreservesContainership(left, v, w);
      } else if v > value {
        InsertPreservesContainership(right, v, w);
      }
  }
}

ex.dfy(52,8): Error: a precondition for this call could not be proved
   |
52 |         InsertPreservesContainership(left, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(45,11): Related location: this is the precondition that could not be proved
   |
45 |   requires Contains(t, w)
   |            ^^^^^^^^^^^^^^

ex.dfy(36,12): Related location
   |
36 |        then Contains(left, v)
   |             ^^^^^^^^^^^^^^^^^

ex.dfy(52,8): Error: a precondition for this call could not be proved
   |
52 |         InsertPreservesContainership(left, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(45,11): Related location: this is the precondition that could not be proved
   |
45 |   requires Contains(t, w)
   |            ^^^^^^^^^^^^^^

ex.dfy(38,17): Related location
   |
38 |             then Contains(right, v)
   |                  ^^^^^^^^^^^^^^^^^^

ex.dfy(54,8): Error: a precondition for this call could not be proved
   |
54 |         InsertPreservesContainership(right, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(45,11): Related location: this is the precondition that could not be proved
   |
45 |   requires Contains(t, w)
   |            ^^^^^^^^^^^^^^

ex.dfy(36,12): Related location
   |
36 |        then Contains(left, v)
   |             ^^^^^^^^^^^^^^^^^

ex.dfy(54,8): Error: a precondition for this call could not be proved
   |
54 |         InsertPreservesContainership(right, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(45,11): Related location: this is the precondition that could not be proved
   |
45 |   requires Contains(t, w)
   |            ^^^^^^^^^^^^^^

ex.dfy(38,17): Related location
   |
38 |             then Contains(right, v)
   |                  ^^^^^^^^^^^^^^^^^^

ex.dfy(54,8): Error: a precondition for this call could not be proved
   |
54 |         InsertPreservesContainership(right, v, w);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(45,11): Related location: this is the precondition that could not be proved
   |
45 |   requires Contains(t, w)
   |            ^^^^^^^^^^^^^^

ex.dfy(33,17): Related location
   |
33 |     case Null => false
   |                  ^^^^^


Dafny program verifier finished with 3 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()

   |
49 |     case Null => ()
   |                    ^

ex.dfy(49,19): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Null => ()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()
    case Node(value, left, right) =>

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
50 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(50,36): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()
    case Node(value, left, right) =>
      (if v < value

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
51 |       (if v < value
   |                    ^

ex.dfy(51,19): Error: then expected
3 parse errors detected in ex.dfy

SCORE
None
['      (if v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null => ()
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContainership(left, v, w)

   |
50 |     case Node(value, left, right) =>
   |     ^

ex.dfy(50,4): Error: invalid Suffix
   |
49 |     case Null => ()
   |                  ^

ex.dfy(49,17): Error: missing semicolon at end of statement
   |
52 |        then InsertPreservesContainership(left, v, w)
   |                                                     ^

ex.dfy(52,52): Error: else expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['       then InsertPreservesContainership(left, v, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)

   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(t, w) == Contains(Insert(t, v), w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)
}

   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)
}


   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma about the insert function preserving containership
lemma InsertPreservesContainership(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)
}

// (6) Lemma about the insert function preserving BST

   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma about the insert function preserving BST\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property

SCORE
1.0
['// (5) Lemma for insert function without BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)

SCORE
1.0
['  requires Contains(t, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['  ensures Contains(Insert(t, v), (v == w ? v : w))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))
{

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), (v == w ? v : w))
{
  match t {

   |
46 |   ensures Contains(Insert(t, v), (v == w ? v : w))
   |                                          ^

ex.dfy(46,41): Error: closeparen expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)

SCORE
1.0
['  ensures Contains(Insert(t, v), w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {

   |
48 |   match t {
   |            ^

ex.dfy(48,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>

   |
49 |     case Null =>
   |                 ^

ex.dfy(49,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Null =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>

   |
50 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(50,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value

   |
51 |       (if v < value
   |                    ^

ex.dfy(51,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      (if v < value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)

   |
52 |        then InsertPreservesContains(left, v, w)
   |                                                ^

ex.dfy(52,47): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['       then InsertPreservesContains(left, v, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value

   |
53 |        else if v > value
   |                         ^

ex.dfy(53,24): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['       else if v > value\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)

   |
54 |             then InsertPreservesContains(right, v, w)
   |                                                      ^

ex.dfy(54,53): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['            then InsertPreservesContains(right, v, w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})

   |
55 |             else {})
   |                     ^

ex.dfy(55,20): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['            else {})\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}


   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}

// (6) Lemma for insert function with BST property

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma for insert function with BST property\n']
['{\n']
['  match t {\n']
['    case Null =>\n']
['    case Node(value, left, right) =>\n']
['      (if v < value\n']
['       then InsertPreservesContains(left, v, w)\n']
['       else if v > value\n']
['            then InsertPreservesContains(right, v, w)\n']
['            else {})\n']
['  }\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  requires Contains(t, w)
  ensures Contains(Insert(t, v), w)
{
  match t {
    case Null =>
    case Node(value, left, right) =>
      (if v < value
       then InsertPreservesContains(left, v, w)
       else if v > value
            then InsertPreservesContains(right, v, w)
            else {})
  }
}

// (6) Lemma for insert function maintaining BST property

   |
56 |   }
   |   ^

ex.dfy(56,2): Error: invalid Suffix
   |
51 |       (if v < value
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma for insert function maintaining BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));

SCORE
1.0
['  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
{

   |
45 |   ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
   |                                                                  ^

ex.dfy(45,65): Warning: deprecated style: a semi-colon is not needed here
   |
46 | {
   |  ^

ex.dfy(46,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
  ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
{
  match t {

   |
45 |   ensures Contains(Insert(t, v), w) == (v == w || Contains(t, w));
   |                                                                  ^

ex.dfy(45,65): Warning: deprecated style: a semi-colon is not needed here
   |
47 |   match t {
   |            ^

ex.dfy(47,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  match t {\n']
['{\n']
['  match t {\n']
['lemma InsertPreservesContains(t: Tree, v: nat, w: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
{

   |
45 | {
   |  ^

ex.dfy(45,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)

   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  Contains(t, w) == Contains(Insert(t, v), w)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)
}

   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)
}


   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Lemma for insert function without BST property
lemma InsertPreservesContains(t: Tree, v: nat, w: nat)
{
  Contains(t, w) == Contains(Insert(t, v), w)
}

// (6) Lemma for insert function with BST property

   |
46 |   Contains(t, w) == Contains(Insert(t, v), w)
   |                  ^

ex.dfy(46,17): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['// (6) Lemma for insert function with BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, v) ==> Contains(Insert(t, w), v)

SCORE
1.0
['requires Contains(t, v) ==> Contains(Insert(t, w), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, v) ==> Contains(Insert(t, w), v)
ensures Contains(t, v) ==> Contains(Insert(t, w), v)

SCORE
1.0
['ensures Contains(t, v) ==> Contains(Insert(t, w), v)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, v) ==> Contains(Insert(t, w), v)
ensures Contains(t, v) ==> Contains(Insert(t, w), v)
{

   |
47 | {
   |  ^

ex.dfy(47,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the tree
datatype Tree = Node(value: nat, left: Tree, right: Tree) | Null

// (2) Define the predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t {
    case Null => true
    case Node(v, left, right) => v >= lower && v < upper &&
                                IsBST(left, lower, v) &&
                                IsBST(right, v, upper)
  }
}

// (3) Define the insert function
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Null => Node(v, Null, Null)
    case Node(value, left, right) =>
      (if v < value
       then Node(value, Insert(left, v), right)
       else if v > value
            then Node(value, left, Insert(right, v))
            else t)
  }
}

// (4) Define the predicate for containing an element
predicate Contains(t: Tree, v: nat)
{
  match t {
    case Null => false
    case Node(value, left, right) =>
      (if v < value
       then Contains(left, v)
       else if v > value
            then Contains(right, v)
            else true)
  }
}

// (5) Define the lemma for insertion
lemma InsertPreservesElement(t: Tree, v: nat, w: nat)
requires Contains(t, v) ==> Contains(Insert(t, w), v)
ensures Contains(t, v) ==> Contains(Insert(t, w), v)
{
}

SCORE
1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 105
number of gen nodes: 53 (including leaves: 18)
number of back nodes: 52 (including leaves: 35)

expansion count: 91 (including failed: 39)

cache stats {'hit': 77, 'miss': 255}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605]

Trial calls: [324, 364, 373, 338, 340, 332]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 604.00 sec, Standard Deviation: 2.83 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 345.17 calls, Standard Deviation: 17.46 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605]

Trial calls: [324, 364, 373, 338, 340, 332]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 604.00 sec, Standard Deviation: 2.83 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 345.17 calls, Standard Deviation: 17.46 calls

Trial  7
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true

  |
8 |   case Nil => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
10 |     v >= min && v <= max &&
   |                            ^

ex.dfy(10,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    (left == Nil || IsBST(left, min, v - 1)) &&

   |
11 |     (left == Nil || IsBST(left, min, v - 1)) &&
   |                                                ^

ex.dfy(11,47): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    (left == Nil || IsBST(left, min, v - 1)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    (left == Nil || IsBST(left, min, v - 1)) &&
    (right == Nil || IsBST(right, v + 1, max))

   |
12 |     (right == Nil || IsBST(right, v + 1, max))
   |                                               ^

ex.dfy(12,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    (right == Nil || IsBST(right, v + 1, max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    (left == Nil || IsBST(left, min, v - 1)) &&
    (right == Nil || IsBST(right, v + 1, max))
}

ex.dfy(11,39): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |     (left == Nil || IsBST(left, min, v - 1)) &&
   |                                        ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Nil => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Nil => true
  case Node(left, v, right) =>

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t
   case Nil => true

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['   case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
   match t
   case Nil => true
   case Node(left, v, right) => 

  |
6 |    match t
  |    ^

ex.dfy(6,3): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['   case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{ \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 

  |
8 |   {
  |    ^

ex.dfy(8,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true

  |
9 |     case Nil => true
  |                     ^

ex.dfy(9,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true
    case Node(left, v, right) =>

   |
10 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(10,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true
    case Node(left, v, right) =>
      v >= min && v <= max &&

   |
11 |       v >= min && v <= max &&
   |                              ^

ex.dfy(11,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true
    case Node(left, v, right) =>
      v >= min && v <= max &&
      (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&

   |
12 |       (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&
   |                                                               ^

ex.dfy(12,62): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true
    case Node(left, v, right) =>
      v >= min && v <= max &&
      (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&
      (right == Nil || (IsBST(right, v + 1, max) && v < max))

   |
13 |       (right == Nil || (IsBST(right, v + 1, max) && v < max))
   |                                                              ^

ex.dfy(13,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (right == Nil || (IsBST(right, v + 1, max) && v < max))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true
    case Node(left, v, right) =>
      v >= min && v <= max &&
      (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&
      (right == Nil || (IsBST(right, v + 1, max) && v < max))
  } 

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  } \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{ 
  match t 
  { 
    case Nil => true
    case Node(left, v, right) =>
      v >= min && v <= max &&
      (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&
      (right == Nil || (IsBST(right, v + 1, max) && v < max))
  } 
}

ex.dfy(12,42): Error: value does not satisfy the subset constraints of 'nat'
   |
12 |       (left == Nil || (IsBST(left, min, v - 1) && v > min)) &&
   |                                           ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
6 |   match t {
  |            ^

ex.dfy(6,11): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Nil => true

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['    case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Nil => true
    case Node(left, v, right) => 

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, v, right) => \n']
['  match t {\n']
['    case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Nil => true
    case Node(l, v, r) => 

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(l, v, r) => \n']
['{\n']
['  match t\n']
['  case Nil => true\n']
['  case Node(left, v, right) =>\n']
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&

   |
11 |     IsBST(left, min, v - 1) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&
    IsBST(right, v + 1, max)

   |
12 |     IsBST(right, v + 1, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&
    IsBST(right, v + 1, max)
}

ex.dfy(11,23): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |     IsBST(left, min, v - 1) &&
   |                        ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST

SCORE
1.0
['// (2) Predicate for checking if a given tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true

  |
8 |     case Nil => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 

  |
9 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&

   |
10 |       v >= min && v <= max &&
   |                              ^

ex.dfy(10,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&

   |
11 |       IsBST(left, min, v) &&
   |                             ^

ex.dfy(11,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)

   |
12 |       IsBST(right, v, max)
   |                           ^

ex.dfy(12,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)

   |
20 |     case Nil => Node(Nil, v, Nil)
   |                                  ^

ex.dfy(20,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |         Node(Insert(left, v), w, right)
   |                                        ^

ex.dfy(23,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)
      } else if v > w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else if v > w {
   |                       ^

ex.dfy(24,22): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)

   |
20 |     case Nil => Node(Nil, v, Nil)
   |                                  ^

ex.dfy(20,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      if v < w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      if v < w {
        Node(Insert(left, v), w, right)

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |         Node(Insert(left, v), w, right)
   |                                        ^

ex.dfy(23,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      if v < w {
        Node(Insert(left, v), w, right)
      } else if v > w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else if v > w {
   |                       ^

ex.dfy(24,22): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |         Node(Insert(left, v), w, right)
   |                                        ^

ex.dfy(23,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)
      } else if v > w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else if v > w {
   |                       ^

ex.dfy(24,22): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)

   |
20 |     case Nil => Node(Nil, v, Nil)
   |                                  ^

ex.dfy(20,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w { Node(Insert(left, v), w, right) }

   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                ^

ex.dfy(22,15): Error: then expected
   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                                                   ^

ex.dfy(22,50): Error: else expected
2 parse errors detected in ex.dfy

SCORE
None
['      if v < w { Node(Insert(left, v), w, right) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w { Node(Insert(left, v), w, right) }
      else if v > w { Node(left, w, Insert(right, v)) }

   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |       else if v > w { Node(left, w, Insert(right, v)) }
   |                     ^

ex.dfy(23,20): Error: then expected
   |
23 |       else if v > w { Node(left, w, Insert(right, v)) }
   |                                                        ^

ex.dfy(23,55): Error: else expected
3 parse errors detected in ex.dfy

SCORE
None
['      else if v > w { Node(left, w, Insert(right, v)) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w { Node(Insert(left, v), w, right) }
      else if v > w { Node(left, w, Insert(right, v)) }
      else { t }

   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |       else if v > w { Node(left, w, Insert(right, v)) }
   |                     ^

ex.dfy(23,20): Error: then expected
   |
24 |       else { t }
   |                 ^

ex.dfy(24,16): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      else { t }\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |         Node(Insert(left, v), w, right)
   |                                        ^

ex.dfy(23,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)
      } else if v > w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else if v > w {
   |                       ^

ex.dfy(24,22): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if v > w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{ match t

   |
18 | { match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)

   |
19 |   { case Nil => Node(Nil, v, Nil)
   |                                  ^

ex.dfy(19,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>

   |
20 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)

   |
21 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v <= w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
21 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
21 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['\n']
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t

   |
18 | { match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)

   |
19 |   { case Nil => Node(Nil, v, Nil)
   |                                  ^

ex.dfy(19,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 

   |
20 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)

   |
21 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v < w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
21 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
21 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)

   |
20 |     case Nil => Node(Nil, v, Nil)
   |                                  ^

ex.dfy(20,33): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Nil => Node(Nil, v, Nil)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v < w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
{
  match t {
    case Nil => true
    case Node(left, v, right) => 
      v >= min && v <= max &&
      IsBST(left, min, v) &&
      IsBST(right, v, max)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Nil => Node(Nil, v, Nil)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Nil => Node(Nil, v, Nil)\n']
['    case Node(left, w, right) =>\n']
['      if v < w { Node(Insert(left, v), w, right) }\n']
['      else if v > w { Node(left, w, Insert(right, v)) }\n']
['      else { t }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
    match tree {

  |
6 |     match tree {
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
  |
6 |     match tree {
  |                 ^

ex.dfy(6,16): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['    match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
    match tree {
        case Nil => true

  |
6 |     match tree {
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
  |
7 |         case Nil => true
  |         ^

ex.dfy(7,8): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['        case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
    match tree {
        case Nil => true
        case Node(left, value, right) =>

  |
6 |     match tree {
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
  |
7 |         case Nil => true
  |         ^

ex.dfy(7,8): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
-1.0
['        case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree {

  |
6 |   match tree {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
6 |   match tree {
  |               ^

ex.dfy(6,14): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree {
    case Nil => true

  |
6 |   match tree {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['    case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree {
    case Nil => true
    case Node(left, value, right) => 

  |
6 |   match tree {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree

SCORE
1.0
['// (2) Predicate for checking if a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lo: nat, hi: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t
  case Leaf => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
['  match t\n']
['  case Leaf => true\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree
  case Leaf => true

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree
  case Leaf => true
  case Node(left, value, right) => 

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) => \n']
['  match tree\n']
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree
  case Leaf => true
  case Node(left, value, right) =>

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Leaf => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
['  match t\n']
['  case Leaf => true\n']
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
6 |   match t {
  |            ^

ex.dfy(6,11): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Nil => true

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['    case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t {
    case Nil => true
    case Node(l, v, r) => 

  |
6 |   match t {
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
  |
7 |     case Nil => true
  |     ^

ex.dfy(7,4): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(l, v, r) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers

SCORE
1.0
['// (1) Define the ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty

SCORE
1.0
['  | Empty\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

SCORE
1.0
['  | Node(value: nat, left: Tree, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Define a predicate to check if a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {

   |
10 |   match t {
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true

   |
11 |     case Empty => true
   |                       ^

ex.dfy(11,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>

   |
12 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value <= max &&

   |
13 |       value >= min && value <= max &&
   |                                      ^

ex.dfy(13,37): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value <= max &&
      IsBST(left, min, value) &&

   |
14 |       IsBST(left, min, value) &&
   |                                 ^

ex.dfy(14,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value <= max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)

   |
15 |       IsBST(right, value, max)
   |                               ^

ex.dfy(15,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value <= max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }

   |
16 |   }
   |    ^

ex.dfy(16,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value <= max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  reads t\n']
['{\n']
['  match t {\n']
['    case Empty => true\n']
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value <= max &&

   |
13 |       value <= max &&
   |                      ^

ex.dfy(13,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value <= max &&
      value >= min &&

   |
14 |       value >= min &&
   |                      ^

ex.dfy(14,21): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= min &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value <= max &&
      value >= min &&
      IsBST(left, min, value - 1) &&

   |
15 |       IsBST(left, min, value - 1) &&
   |                                     ^

ex.dfy(15,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value <= max &&
      value >= min &&
      IsBST(left, min, value - 1) &&
      IsBST(right, value + 1, max)

   |
16 |       IsBST(right, value + 1, max)
   |                                   ^

ex.dfy(16,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value <= max &&
      value >= min &&
      IsBST(left, min, value - 1) &&
      IsBST(right, value + 1, max)
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, min: nat, max: nat) 
  reads t
{
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value <= max &&
      value >= min &&
      IsBST(left, min, value - 1) &&
      IsBST(right, value + 1, max)
  }
}

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {

  |
7 | function IsBST(t: Tree, min: nat, max: nat): bool {
  |                                                    ^

ex.dfy(7,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function IsBST(t: Tree, min: nat, max: nat): bool {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {

  |
8 |   match t {
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true

  |
9 |     case Empty => true
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>

   |
10 |     case Node(value, left, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(value, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&

   |
11 |       value >= min && value < max &&
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= min && value < max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&

   |
12 |       IsBST(left, min, value) &&
   |                                 ^

ex.dfy(12,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)

   |
13 |       IsBST(right, value, max)
   |                               ^

ex.dfy(13,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Define a function to insert an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {

   |
18 | function Insert(t: Tree, value: nat): Tree {
   |                                             ^

ex.dfy(18,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Insert(t: Tree, value: nat): Tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)

   |
20 |     case Empty => Node(value, Empty, Empty)
   |                                            ^

ex.dfy(20,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(value, Empty, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>

   |
21 |     case Node(v, left, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(v, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if (value < v) {

   |
22 |       if (value < v) {
   |                      ^

ex.dfy(22,21): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if (value < v) {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if (value < v) {
        Node(v, Insert(left, value), right)

   |
22 |       if (value < v) {
   |                      ^

ex.dfy(22,21): Error: then expected
   |
23 |         Node(v, Insert(left, value), right)
   |                                            ^

ex.dfy(23,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(v, Insert(left, value), right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if (value < v) {
        Node(v, Insert(left, value), right)
      } else if (value > v) {

   |
22 |       if (value < v) {
   |                      ^

ex.dfy(22,21): Error: then expected
   |
24 |       } else if (value > v) {
   |                             ^

ex.dfy(24,28): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if (value > v) {\n']
['function Insert(t: Tree, value: nat): Tree {\n']
['  match t {\n']
['    case Empty => Node(value, Empty, Empty)\n']
['    case Node(v, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if value < v {

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if value < v {
        Node(v, Insert(left, value), right)

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
   |
23 |         Node(v, Insert(left, value), right)
   |                                            ^

ex.dfy(23,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(v, Insert(left, value), right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if value < v {
        Node(v, Insert(left, value), right)
      } else if value > v {

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
   |
24 |       } else if value > v {
   |                           ^

ex.dfy(24,26): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > v {\n']
['// (3) Define a function to insert an element into a binary search tree while preserving the BST property\n']
['function Insert(t: Tree, value: nat): Tree {\n']
['  match t {\n']
['    case Empty => Node(value, Empty, Empty)\n']
['    case Node(v, left, right) =>\n']
['      if value < v {\n']
['        Node(v, Insert(left, value), right)\n']
['      } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree {\n']
['  match t {\n']
['    case Empty => Node(value, Empty, Empty)\n']
['    case Node(v, left, right) =>\n']
['      if value < v {\n']
['        Node(v, Insert(left, value), right)\n']
['      } else if value > v {\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree

SCORE
1.0
['// (3) Define a function to insert an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {

   |
18 | function Insert(t: Tree, value: nat): Tree {
   |                                             ^

ex.dfy(18,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Insert(t: Tree, value: nat): Tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)

   |
20 |     case Empty => Node(value, Empty, Empty)
   |                                            ^

ex.dfy(20,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(value, Empty, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>

   |
21 |     case Node(v, left, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(v, left, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if value < v {

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if value < v {
        Node(v, Insert(left, value), right)

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
   |
23 |         Node(v, Insert(left, value), right)
   |                                            ^

ex.dfy(23,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(v, Insert(left, value), right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate to check if a given tree is a binary search tree (BST)
function IsBST(t: Tree, min: nat, max: nat): bool {
  match t {
    case Empty => true
    case Node(value, left, right) =>
      value >= min && value < max &&
      IsBST(left, min, value) &&
      IsBST(right, value, max)
  }
}

// (3) Define a function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Empty => Node(value, Empty, Empty)
    case Node(v, left, right) =>
      if value < v {
        Node(v, Insert(left, value), right)
      } else if value > v {

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
   |
24 |       } else if value > v {
   |                           ^

ex.dfy(24,26): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree {\n']
['  match t {\n']
['    case Empty => Node(value, Empty, Empty)\n']
['    case Node(v, left, right) =>\n']
['      if value < v {\n']
['        Node(v, Insert(left, value), right)\n']
['      } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree {\n']
['  match t {\n']
['    case Empty => Node(value, Empty, Empty)\n']
['    case Node(v, left, right) =>\n']
['      if value < v {\n']
['        Node(v, Insert(left, value), right)\n']
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate for binary search tree

SCORE
1.0
['// (2) Define a predicate for binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate for binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate for binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate for binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Empty => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate for binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Empty => true
  case Node(value, left, right) => 

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(value, left, right) => \n']
['  match t\n']
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) Define the ADT for a tree of natural numbers
datatype Tree =
  | Empty
  | Node(value: nat, left: Tree, right: Tree)

// (2) Define a predicate for binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Empty => true
  case Node(value, left, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(value, left, right) =>\n']
['  reads t\n']
['{\n']
['  match t {\n']
['    case Empty => true\n']
['    case Node(value, left, right) =>\n']
['      value >= min && value <= max &&\n']
['      IsBST(left, min, value) &&\n']
['      IsBST(right, value, max)\n']
['  }\n']
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t

  |
6 |     reads t
  |           ^

ex.dfy(6,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {

  |
8 |     match t {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true

  |
9 |         case Nil => true
  |                         ^

ex.dfy(9,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true
        case Node(left, v, right) => 

   |
10 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true
        case Node(left, v, right) => 
            v >= min && v <= max &&

   |
11 |             v >= min && v <= max &&
   |                                    ^

ex.dfy(11,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true
        case Node(left, v, right) => 
            v >= min && v <= max &&
            IsBST(left, min, v) &&

   |
12 |             IsBST(left, min, v) &&
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true
        case Node(left, v, right) => 
            v >= min && v <= max &&
            IsBST(left, min, v) &&
            IsBST(right, v, max)

   |
13 |             IsBST(right, v, max)
   |                                 ^

ex.dfy(13,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true
        case Node(left, v, right) => 
            v >= min && v <= max &&
            IsBST(left, min, v) &&
            IsBST(right, v, max)
    }

   |
14 |     }
   |      ^

ex.dfy(14,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat) 
    reads t
{
    match t {
        case Nil => true
        case Node(left, v, right) => 
            v >= min && v <= max &&
            IsBST(left, min, v) &&
            IsBST(right, v, max)
    }
}

  |
6 |     reads t
  |           ^

ex.dfy(6,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['  match t\n']
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(t: Tree, lo: nat, hi: nat)
  match t
  case Leaf => true
  case Node(left, value, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST

SCORE
1.0
['// (2) Predicate for whether a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true

  |
8 |   case Nil => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>

  |
9 |   case Node(l, v, r) =>
  |                        ^

ex.dfy(9,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&

   |
10 |     v >= min && v <= max &&
   |                            ^

ex.dfy(10,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&

   |
11 |     IsBST(l, min, v) &&
   |                        ^

ex.dfy(11,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(l, min, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)

   |
12 |     IsBST(r, v, max)
   |                     ^

ex.dfy(12,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(r, v, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Function to insert an element into a BST

SCORE
1.0
['// (3) Function to insert an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Nil | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Nil => true
  case Node(l, v, r) =>
    v >= min && v <= max &&
    IsBST(l, min, v) &&
    IsBST(r, v, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 105
number of gen nodes: 53 (including leaves: 20)
number of back nodes: 52 (including leaves: 33)

expansion count: 95 (including failed: 43)

cache stats {'hit': 115, 'miss': 216}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603]

Trial calls: [324, 364, 373, 338, 340, 332, 331]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.86 sec, Standard Deviation: 2.64 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 343.14 calls, Standard Deviation: 16.91 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603]

Trial calls: [324, 364, 373, 338, 340, 332, 331]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.86 sec, Standard Deviation: 2.64 sec

Call Statistics:

  Min: 324 calls, Max: 373 calls, Average: 343.14 calls, Standard Deviation: 16.91 calls

Trial  8
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =

  |
1 | datatype Tree =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
1 | datatype Tree =
  |          ^^^^

ex.dfy(1,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)

SCORE
1.0
['// (2)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {

  |
6 | predicate IsBST(t: Tree, lo: nat, hi: nat) {
  |                                             ^

ex.dfy(6,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate IsBST(t: Tree, lo: nat, hi: nat) {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>

  |
8 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(8,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&

  |
9 |       IsBST(left, lo, value) &&
  |                                ^

ex.dfy(9,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&

   |
10 |       value <= hi &&
   |                     ^

ex.dfy(10,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value <= hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&

   |
11 |       value >= lo &&
   |                     ^

ex.dfy(11,20): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= lo &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)

   |
12 |       IsBST(right, value, hi)
   |                              ^

ex.dfy(12,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true

   |
13 |     case Leaf => true
   |                      ^

ex.dfy(13,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)

SCORE
1.0
['// (3)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {

   |
18 | function Insert(t: Tree, value: nat): Tree {
   |                                             ^

ex.dfy(18,44): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Insert(t: Tree, value: nat): Tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>

   |
20 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then

   |
21 |       (if value < v then
   |                         ^

ex.dfy(21,24): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      (if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)

   |
22 |          Node(Insert(left, value), v, right)
   |                                             ^

ex.dfy(22,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['         Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then

   |
23 |        else if value > v then
   |                              ^

ex.dfy(23,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['       else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))

   |
24 |          Node(left, v, Insert(right, value))
   |                                             ^

ex.dfy(24,44): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['         Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else

   |
25 |        else
   |            ^

ex.dfy(25,11): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['       else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)

   |
26 |          t)
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['         t)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)

   |
27 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(27,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }

   |
28 |   }
   |    ^

ex.dfy(28,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)

SCORE
1.0
['// (4)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {

   |
32 | predicate Contains(t: Tree, value: nat) {
   |                                          ^

ex.dfy(32,41): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate Contains(t: Tree, value: nat) {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {

   |
33 |   match t {
   |            ^

ex.dfy(33,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>

   |
34 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(34,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then

   |
35 |       (if value < v then
   |                         ^

ex.dfy(35,24): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      (if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)

   |
36 |          Contains(left, value)
   |                               ^

ex.dfy(36,30): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['         Contains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then

   |
37 |        else if value > v then
   |                              ^

ex.dfy(37,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['       else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)

   |
38 |          Contains(right, value)
   |                                ^

ex.dfy(38,31): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['         Contains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else

   |
39 |        else
   |            ^

ex.dfy(39,11): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['       else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)

   |
40 |          true)
   |               ^

ex.dfy(40,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['         true)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false

   |
41 |     case Leaf => false
   |                       ^

ex.dfy(41,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => false\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }

   |
42 |   }
   |    ^

ex.dfy(42,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)

SCORE
1.0
['// (5)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesContains(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {

   |
49 |   match t {
   |            ^

ex.dfy(49,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>

   |
50 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(50,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v then {

   |
51 |       if value < v then {
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
51 |       if value < v then {
   |                          ^

ex.dfy(51,25): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      if value < v then {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v then {
        InsertPreservesContains(left, value);

   |
51 |       if value < v then {
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
52 |         InsertPreservesContains(left, value);
   |                                              ^

ex.dfy(52,45): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesContains(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v then {
        InsertPreservesContains(left, value);
      } else if value > v then {

   |
51 |       if value < v then {
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
53 |       } else if value > v then {
   |         ^

ex.dfy(53,8): Error: this symbol not expected in CaseStmt
   |
53 |       } else if value > v then {
   |                           ^

ex.dfy(53,26): Error: lbrace expected
   |
53 |       } else if value > v then {
   |                                 ^

ex.dfy(53,32): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > v then {\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then

   |
51 |       (if value < v then
   |                         ^

ex.dfy(51,24): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      (if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)

   |
52 |          InsertPreservesContains(left, value)
   |                                              ^

ex.dfy(52,45): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['         InsertPreservesContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then

   |
53 |        else if value > v then
   |                              ^

ex.dfy(53,29): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['       else if value > v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)

   |
54 |          InsertPreservesContains(right, value)
   |                                               ^

ex.dfy(54,46): Error: else expected
1 parse errors detected in ex.dfy

SCORE
None
['         InsertPreservesContains(right, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else

   |
55 |        else
   |            ^

ex.dfy(55,11): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['       else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         *)

   |
56 |          *)
   |          ^

ex.dfy(56,9): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['         *)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         *)
    case Leaf =>

   |
56 |          *)
   |          ^

ex.dfy(56,9): Error: invalid UnaryExpression
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
   |
57 |     case Leaf =>
   |                 ^

ex.dfy(57,16): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         *)
    case Leaf =>
  }

   |
56 |          *)
   |          ^

ex.dfy(56,9): Error: invalid UnaryExpression
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
   |
58 |   }
   |    ^

ex.dfy(58,3): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['  ensures Contains(Insert(t, value), value)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      (if value < v then\n']
['         InsertPreservesContains(left, value)\n']
['       else if value > v then\n']
['         InsertPreservesContains(right, value)\n']
['       else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         assert Contains(Node(left, v, right), value))

   |
56 |          assert Contains(Node(left, v, right), value))
   |                                                      ^

ex.dfy(56,53): Error: invalid AssertStmt
1 parse errors detected in ex.dfy

SCORE
None
['         assert Contains(Node(left, v, right), value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         assert Contains(Node(left, v, right), value))
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value)

   |
56 |          assert Contains(Node(left, v, right), value))
   |                                                      ^

ex.dfy(56,53): Error: invalid AssertStmt
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
   |
57 |     case Leaf => assert Contains(Node(Leaf, value, Leaf), value)
   |                                                                 ^

ex.dfy(57,64): Error: invalid AssertStmt
3 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => assert Contains(Node(Leaf, value, Leaf), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         assert Contains(Node(left, v, right), value))
    case Leaf => assert Contains(Node(Leaf, value, Leaf), value)
  }

   |
56 |          assert Contains(Node(left, v, right), value))
   |                                                      ^

ex.dfy(56,53): Error: invalid AssertStmt
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
   |
57 |     case Leaf => assert Contains(Node(Leaf, value, Leaf), value)
   |                                                                ^

ex.dfy(57,63): Error: expected either 'by' or a semicolon following the assert expression
   |
58 |   }
   |    ^

ex.dfy(58,3): Error: rbrace expected
4 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      (if value < v then\n']
['         InsertPreservesContains(left, value)\n']
['       else if value > v then\n']
['         InsertPreservesContains(right, value)\n']
['       else\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         Contains(t, value))

   |
56 |          Contains(t, value))
   |                             ^

ex.dfy(56,28): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['         Contains(t, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         Contains(t, value))
    case Leaf =>

   |
57 |     case Leaf =>
   |     ^

ex.dfy(57,4): Error: invalid Suffix
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
   |
57 |     case Leaf =>
   |                 ^

ex.dfy(57,16): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['    case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         Contains(t, value))
    case Leaf =>
  }

   |
57 |     case Leaf =>
   |     ^

ex.dfy(57,4): Error: invalid Suffix
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
   |
58 |   }
   |    ^

ex.dfy(58,3): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      (if value < v then
         InsertPreservesContains(left, value)
       else if value > v then
         InsertPreservesContains(right, value)
       else
         Contains(t, value))
    case Leaf =>
  }
}

   |
57 |     case Leaf =>
   |     ^

ex.dfy(57,4): Error: invalid Suffix
   |
51 |       (if value < v then
   |       ^

ex.dfy(51,6): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)

SCORE
1.0
['lemma InsertPreservesValue(t: Tree, value: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)

SCORE
1.0
['  ensures Contains(Insert(t, value), value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{

   |
48 | {
   |  ^

ex.dfy(48,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {

   |
49 |   match t {
   |            ^

ex.dfy(49,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>

   |
50 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(50,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {

   |
51 |       if value < v {
   |                     ^

ex.dfy(51,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);

   |
52 |         InsertPreservesValue(left, value);
   |                                           ^

ex.dfy(52,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesValue(left, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {

   |
53 |       } else if value > v {
   |                            ^

ex.dfy(53,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);

   |
54 |         InsertPreservesValue(right, value);
   |                                            ^

ex.dfy(54,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesValue(right, value);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }

   |
55 |       }
   |        ^

ex.dfy(55,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>

   |
56 |     case Leaf =>
   |                 ^

ex.dfy(56,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }

   |
57 |   }
   |    ^

ex.dfy(57,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)

SCORE
1.0
['// (6)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)

SCORE
1.0
['lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)

SCORE
1.0
['  requires IsBST(t, lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)

SCORE
1.0
['  ensures IsBST(Insert(t, value), lo, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{

   |
64 | {
   |  ^

ex.dfy(64,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {

   |
65 |   match t {
   |            ^

ex.dfy(65,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>

   |
66 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(66,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {

   |
67 |       if value < v {
   |                     ^

ex.dfy(67,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);

   |
68 |         InsertMaintainsBST(left, value, lo, v);
   |                                                ^

ex.dfy(68,47): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsBST(left, value, lo, v);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);
      } else if value > v {

   |
69 |       } else if value > v {
   |                            ^

ex.dfy(69,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, hi);

   |
70 |         InsertMaintainsBST(right, value, v, hi);
   |                                                 ^

ex.dfy(70,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        InsertMaintainsBST(right, value, v, hi);\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, hi);
      }

   |
71 |       }
   |        ^

ex.dfy(71,7): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, hi);
      }
    case Leaf =>

   |
72 |     case Leaf =>
   |                 ^

ex.dfy(72,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, hi);
      }
    case Leaf =>
  }

   |
73 |   }
   |    ^

ex.dfy(73,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesValue(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertPreservesValue(left, value);
      } else if value > v {
        InsertPreservesValue(right, value);
      }
    case Leaf =>
  }
}

// (6)
lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)
  requires IsBST(t, lo, hi)
  ensures IsBST(Insert(t, value), lo, hi)
{
  match t {
    case Node(left, v, right) =>
      if value < v {
        InsertMaintainsBST(left, value, lo, v);
      } else if value > v {
        InsertMaintainsBST(right, value, v, hi);
      }
    case Leaf =>
  }
}

ex.dfy(72,4): Error: a postcondition could not be proved on this return path
   |
72 |     case Leaf =>
   |     ^^^^

ex.dfy(63,10): Related location: this is the postcondition that could not be proved
   |
63 |   ensures IsBST(Insert(t, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(10,6): Related location
   |
10 |       value <= hi &&
   |       ^^^^^^^^^^^

ex.dfy(72,4): Error: a postcondition could not be proved on this return path
   |
72 |     case Leaf =>
   |     ^^^^

ex.dfy(63,10): Related location: this is the postcondition that could not be proved
   |
63 |   ensures IsBST(Insert(t, value), lo, hi)
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ex.dfy(11,6): Related location
   |
11 |       value >= lo &&
   |       ^^^^^^^^^^^


Dafny program verifier finished with 4 verified, 2 errors

SCORE
-1.0
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  requires IsBST(t, lo, hi)\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(t, lo, hi)\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['\n']
['// (6)\n']
['lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(t, lo, hi)\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  requires IsBST(t, lo, hi)\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v then

   |
51 |       if value < v then
   |                    ^

ex.dfy(51,19): Error: lbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v then\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v then
        InsertPreservesContains(left, value)

   |
51 |       if value < v then
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
52 |         InsertPreservesContains(left, value)
   |                                             ^

ex.dfy(52,44): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['        InsertPreservesContains(left, value)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf

// (2)
predicate IsBST(t: Tree, lo: nat, hi: nat) {
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      value <= hi &&
      value >= lo &&
      IsBST(right, value, hi)
    case Leaf => true
  }
}

// (3)
function Insert(t: Tree, value: nat): Tree {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Node(Insert(left, value), v, right)
       else if value > v then
         Node(left, v, Insert(right, value))
       else
         t)
    case Leaf => Node(Leaf, value, Leaf)
  }
}

// (4)
predicate Contains(t: Tree, value: nat) {
  match t {
    case Node(left, v, right) =>
      (if value < v then
         Contains(left, value)
       else if value > v then
         Contains(right, value)
       else
         true)
    case Leaf => false
  }
}

// (5)
lemma InsertPreservesContains(t: Tree, value: nat)
  ensures Contains(Insert(t, value), value)
{
  match t {
    case Node(left, v, right) =>
      if value < v then
        InsertPreservesContains(left, value)
      else if value > v then

   |
51 |       if value < v then
   |                    ^

ex.dfy(51,19): Error: lbrace expected
   |
53 |       else if value > v then
   |       ^

ex.dfy(53,6): Error: invalid UpdateStmt
   |
53 |       else if value > v then
   |                         ^

ex.dfy(53,24): Error: lbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      else if value > v then\n']
['// (6)\n']
['lemma InsertMaintainsBST(t: Tree, value: nat, lo: nat, hi: nat)\n']
['  requires IsBST(t, lo, hi)\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
['  ensures IsBST(Insert(t, value), lo, hi)\n']
['{\n']
['  match t {\n']
['    case Node(left, v, right) =>\n']
['      if value < v {\n']
['        InsertMaintainsBST(left, value, lo, v);\n']
['      } else if value > v {\n']
['        InsertMaintainsBST(right, value, v, hi);\n']
['      }\n']
['    case Leaf =>\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 89
number of gen nodes: 45 (including leaves: 13)
number of back nodes: 44 (including leaves: 32)

expansion count: 72 (including failed: 28)

cache stats {'hit': 286, 'miss': 100}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603, 606]

Trial calls: [324, 364, 373, 338, 340, 332, 331, 386]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 604.12 sec, Standard Deviation: 2.57 sec

Call Statistics:

  Min: 324 calls, Max: 386 calls, Average: 348.50 calls, Standard Deviation: 21.24 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603, 606]

Trial calls: [324, 364, 373, 338, 340, 332, 331, 386]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 604.12 sec, Standard Deviation: 2.57 sec

Call Statistics:

  Min: 324 calls, Max: 386 calls, Average: 348.50 calls, Standard Deviation: 21.24 calls

Trial  9
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true

  |
8 |   case Empty => true
  |                     ^

ex.dfy(8,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&

   |
10 |     value >= lower && value <= upper &&
   |                                        ^

ex.dfy(10,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&

   |
11 |     IsBST(left, lower, value) &&
   |                                 ^

ex.dfy(11,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)

   |
12 |     IsBST(right, value, upper)
   |                               ^

ex.dfy(12,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST

SCORE
1.0
['// (3) Function for inserting element in BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
19 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(19,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>

   |
20 |   case Node(left, nodeValue, right) =>
   |                                       ^

ex.dfy(20,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>
    if value < nodeValue {

   |
21 |     if value < nodeValue {
   |                          ^

ex.dfy(21,25): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>
    if value < nodeValue {
      Node(Insert(left, value), nodeValue, right)

   |
21 |     if value < nodeValue {
   |                          ^

ex.dfy(21,25): Error: then expected
   |
22 |       Node(Insert(left, value), nodeValue, right)
   |                                                  ^

ex.dfy(22,49): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, nodeValue, right) =>
    if value < nodeValue {
      Node(Insert(left, value), nodeValue, right)
    } else if value > nodeValue {

   |
21 |     if value < nodeValue {
   |                          ^

ex.dfy(21,25): Error: then expected
   |
23 |     } else if value > nodeValue {
   |                                 ^

ex.dfy(23,32): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST

SCORE
1.0
['// (3) Function to insert element into BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
19 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(19,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)

   |
17 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(17,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  requires IsBST(t, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)
  ensures IsBST(t, 0, nat.MaxInt)

   |
17 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(17,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  ensures IsBST(t, 0, nat.MaxInt)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element in BST
function Insert(t: Tree, value: nat): Tree
  requires IsBST(t, 0, nat.MaxInt)
  ensures IsBST(t, 0, nat.MaxInt)
  ensures IsBST(result, 0, nat.MaxInt)

   |
17 |   requires IsBST(t, 0, nat.MaxInt)
   |                        ^

ex.dfy(17,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
-1.0
['  ensures IsBST(result, 0, nat.MaxInt)\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST

SCORE
1.0
['// (3) Function for inserting element into BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)

   |
19 |   case Empty => Node(Empty, value, Empty)
   |                                          ^

ex.dfy(19,41): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function for inserting element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, t_value, right) =>

   |
20 |   case Node(left, t_value, right) =>
   |                                     ^

ex.dfy(20,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, t_value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, t_value, right) =>
    if value < t_value {

   |
21 |     if value < t_value {
   |                        ^

ex.dfy(21,23): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < t_value {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, t_value, right) =>
    if value < t_value {
      Node(Insert(left, value), t_value, right)

   |
21 |     if value < t_value {
   |                        ^

ex.dfy(21,23): Error: then expected
   |
22 |       Node(Insert(left, value), t_value, right)
   |                                                ^

ex.dfy(22,47): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), t_value, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(left, value, right) =>
    value >= lower && value <= upper &&
    IsBST(left, lower, value) &&
    IsBST(right, value, upper)
}

// (3) Function to insert element into BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Empty => Node(Empty, value, Empty)
  case Node(left, t_value, right) =>
    if value < t_value {
      Node(Insert(left, value), t_value, right)
    } else if value > t_value {

   |
21 |     if value < t_value {
   |                        ^

ex.dfy(21,23): Error: then expected
   |
23 |     } else if value > t_value {
   |                               ^

ex.dfy(23,30): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > t_value {\n']
['{\n']
['  match t\n']
['  case Empty => Node(Empty, value, Empty)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 

  |
6 |     reads t
  |           ^

ex.dfy(6,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['    reads t \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{

  |
7 | {
  |  ^

ex.dfy(7,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {

  |
8 |     match t {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true

  |
9 |         case Empty => true
  |                           ^

ex.dfy(9,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true
        case Node(left, v, right) => 

   |
10 |         case Node(left, v, right) =>
   |                                     ^

ex.dfy(10,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['        case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true
        case Node(left, v, right) => 
            v >= lower && v <= upper &&

   |
11 |             v >= lower && v <= upper &&
   |                                        ^

ex.dfy(11,39): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            v >= lower && v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true
        case Node(left, v, right) => 
            v >= lower && v <= upper &&
            IsBST(left, lower, v) && 

   |
12 |             IsBST(left, lower, v) &&
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(left, lower, v) && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true
        case Node(left, v, right) => 
            v >= lower && v <= upper &&
            IsBST(left, lower, v) && 
            IsBST(right, v, upper)

   |
13 |             IsBST(right, v, upper)
   |                                   ^

ex.dfy(13,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            IsBST(right, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true
        case Node(left, v, right) => 
            v >= lower && v <= upper &&
            IsBST(left, lower, v) && 
            IsBST(right, v, upper)
    }

   |
14 |     }
   |      ^

ex.dfy(14,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    reads t 
{
    match t {
        case Empty => true
        case Node(left, v, right) => 
            v >= lower && v <= upper &&
            IsBST(left, lower, v) && 
            IsBST(right, v, upper)
    }
}

  |
6 |     reads t 
  |           ^

ex.dfy(6,10): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match t\n']
['  case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&

  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                                                    ^

ex.dfy(9,51): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(l, v, r) => v >= lower && v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                       IsBST(l, lower, v - 1) &&

   |
10 |                        IsBST(l, lower, v - 1) &&
   |                                                 ^

ex.dfy(10,48): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['                       IsBST(l, lower, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                       IsBST(l, lower, v - 1) &&
                       IsBST(r, v + 1, upper)

   |
11 |                        IsBST(r, v + 1, upper)
   |                                              ^

ex.dfy(11,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                       IsBST(r, v + 1, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat)
{
  match t
  case Empty => true
  case Node(l, v, r) => v >= lower && v <= upper &&
                       IsBST(l, lower, v - 1) &&
                       IsBST(r, v + 1, upper)
}

  |
9 |   case Node(l, v, r) => v >= lower && v <= upper &&
  |                         ^

ex.dfy(9,24): Warning: unusual indentation in case expression (which ends at line 11, column 45); do you perhaps need parentheses?
ex.dfy(10,41): Error: value does not satisfy the subset constraints of 'nat'
   |
10 |                        IsBST(l, lower, v - 1) &&
   |                                          ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree

SCORE
1.0
['// (2) Predicate for checking if a tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true

  |
8 |     case Empty => true
  |                       ^

ex.dfy(8,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>

  |
9 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&

   |
10 |       lower <= v && v < upper &&
   |                                 ^

ex.dfy(10,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      lower <= v && v < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&

   |
11 |       IsBST(left, lower, v) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)

   |
12 |       IsBST(right, v, upper)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)

   |
20 |     case Empty => Node(Empty, v, Empty)
   |                                        ^

ex.dfy(20,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |         Node(Insert(left, v), w, right)
   |                                        ^

ex.dfy(23,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)
      } else if v > w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else if v > w {
   |                       ^

ex.dfy(24,22): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)
      } else {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else {
   |               ^

ex.dfy(24,14): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else {\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v < w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)
           : (v > w) ? Node(left, w, Insert(right, v))

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['           : (v > w) ? Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)
           : (v > w) ? Node(left, w, Insert(right, v))
                    : t

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['                    : t\n']
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t

   |
18 | { match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)

   |
19 |   { case Empty => Node(Empty, v, Empty)
   |                                        ^

ex.dfy(19,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, x, right) =>

   |
20 |     case Node(left, x, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, x, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, x, right) =>
      (v <= x) ? Node(Insert(left, v), x, right)

   |
21 |       (v <= x) ? Node(Insert(left, v), x, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v <= x) ? Node(Insert(left, v), x, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, x, right) =>
      (v <= x) ? Node(Insert(left, v), x, right)
             : Node(left, x, Insert(right, v))

   |
21 |       (v <= x) ? Node(Insert(left, v), x, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, x, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, x, right) =>
      (v <= x) ? Node(Insert(left, v), x, right)
             : Node(left, x, Insert(right, v))
  }

   |
21 |       (v <= x) ? Node(Insert(left, v), x, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{ match t\n']
['  { case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>

   |
20 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)

   |
21 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v < w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
21 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
21 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(21,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
['\n']
['// (3) Function for inserting an element into a binary search tree\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
['      (v < w) ? Node(Insert(left, v), w, right)\n']
['           : (v > w) ? Node(left, w, Insert(right, v))\n']
['                    : t\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
['      (v < w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['function Insert(t: Tree, v: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
['      if v < w {\n']
['        Node(Insert(left, v), w, right)\n']
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w { Node(Insert(left, v), w, right) }

   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                ^

ex.dfy(22,15): Error: then expected
   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                                                   ^

ex.dfy(22,50): Error: else expected
2 parse errors detected in ex.dfy

SCORE
None
['      if v < w { Node(Insert(left, v), w, right) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w { Node(Insert(left, v), w, right) }
      else if v > w { Node(left, w, Insert(right, v)) }

   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |       else if v > w { Node(left, w, Insert(right, v)) }
   |                     ^

ex.dfy(23,20): Error: then expected
   |
23 |       else if v > w { Node(left, w, Insert(right, v)) }
   |                                                        ^

ex.dfy(23,55): Error: else expected
3 parse errors detected in ex.dfy

SCORE
None
['      else if v > w { Node(left, w, Insert(right, v)) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) =>
      lower <= v && v < upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, v: nat): Tree
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w { Node(Insert(left, v), w, right) }
      else if v > w { Node(left, w, Insert(right, v)) }
      else { t }

   |
22 |       if v < w { Node(Insert(left, v), w, right) }
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |       else if v > w { Node(left, w, Insert(right, v)) }
   |                     ^

ex.dfy(23,20): Error: then expected
   |
24 |       else { t }
   |                 ^

ex.dfy(24,16): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      else { t }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true

  |
8 |     case Empty => true
  |                       ^

ex.dfy(8,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 

  |
9 |     case Node(left, v, right) =>
  |                                 ^

ex.dfy(9,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&

   |
10 |       v >= lower && v <= upper &&
   |                                  ^

ex.dfy(10,33): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      v >= lower && v <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&

   |
11 |       IsBST(left, lower, v) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, v) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)

   |
12 |       IsBST(right, v, upper)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, v, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST

SCORE
1.0
['// (3) Insert element into BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)

   |
20 |     case Empty => Node(Empty, v, Empty)
   |                                        ^

ex.dfy(20,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v < w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v < w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
22 |       (v < w) ? Node(Insert(left, v), w, right)
   |               ^

ex.dfy(22,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v <= w) ? Node(Insert(left, v), w, right)

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v <= w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['function Insert(t: Tree, v: nat): Tree \n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
['    case Node(left, w, right) => \n']
['      (v < w) ? Node(Insert(left, v), w, right)\n']
['             : Node(left, w, Insert(right, v))\n']
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{ match t

   |
18 | { match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)

   |
19 |   { case Empty => Node(Empty, v, Empty)
   |                                        ^

ex.dfy(19,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>

   |
20 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(20,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)

   |
21 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v <= w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
21 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{ match t
  { case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
21 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function

SCORE
1.0
['// (3) Insert function\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, v: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)

   |
20 |     case Empty => Node(Empty, v, Empty)
   |                                        ^

ex.dfy(20,39): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if v < w {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
23 |         Node(Insert(left, v), w, right)
   |                                        ^

ex.dfy(23,39): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      if v < w {
        Node(Insert(left, v), w, right)
      } else if v > w {

   |
22 |       if v < w {
   |                ^

ex.dfy(22,15): Error: then expected
   |
24 |       } else if v > w {
   |                       ^

ex.dfy(24,22): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if v > w {\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))
  }

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert function
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) => 
      (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))
  }
}

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right) : Node(left, w, Insert(right, v))
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['}\n']
['{\n']
['  match t {\n']
['    case Empty => Node(Empty, v, Empty)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>

   |
21 |     case Node(left, w, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, w, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (v <= w) ? Node(Insert(left, v), w, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['             : Node(left, w, Insert(right, v))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Empty => true
    case Node(left, v, right) => 
      v >= lower && v <= upper &&
      IsBST(left, lower, v) &&
      IsBST(right, v, upper)
  }
}

// (3) Insert element into BST
function Insert(t: Tree, v: nat): Tree 
{
  match t {
    case Empty => Node(Empty, v, Empty)
    case Node(left, w, right) =>
      (v <= w) ? Node(Insert(left, v), w, right)
             : Node(left, w, Insert(right, v))
  }

   |
22 |       (v <= w) ? Node(Insert(left, v), w, right)
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)

  |
2 | datatype Tree =
  |          ^^^^

ex.dfy(2,9): Error: because of cyclic dependencies among constructor argument types, no instances of datatype 'Tree' can be constructed
1 resolution/type errors detected in ex.dfy

SCORE
None
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

SCORE
1.0
['  | Leaf()\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper

  |
8 |   reads tree 
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  requires lower <= upper\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {

   |
11 |   match tree {
   |               ^

ex.dfy(11,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true

   |
12 |     case Leaf() => true
   |                        ^

ex.dfy(12,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>

   |
13 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(13,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      value >= lower && value <= upper &&

   |
14 |       value >= lower && value <= upper &&
   |                                          ^

ex.dfy(14,41): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= lower && value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      value >= lower && value <= upper &&
      IsBST(left, lower, value - 1) &&

   |
15 |       IsBST(left, lower, value - 1) &&
   |                                       ^

ex.dfy(15,38): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, value - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      value >= lower && value <= upper &&
      IsBST(left, lower, value - 1) &&
      IsBST(right, value + 1, upper)

   |
16 |       IsBST(right, value + 1, upper)
   |                                     ^

ex.dfy(16,36): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value + 1, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      value >= lower && value <= upper &&
      IsBST(left, lower, value - 1) &&
      IsBST(right, value + 1, upper)
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree 
  requires lower <= upper
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      value >= lower && value <= upper &&
      IsBST(left, lower, value - 1) &&
      IsBST(right, value + 1, upper)
  }
}

  |
8 |   reads tree 
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {

   |
10 |   match tree {
   |               ^

ex.dfy(10,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true

   |
11 |     case Leaf() => true
   |                        ^

ex.dfy(11,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>

   |
12 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(12,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&

   |
13 |       IsBST(left, lower, value) &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      value <= upper &&

   |
14 |       value <= upper &&
   |                        ^

ex.dfy(14,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value <= upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      value <= upper &&
      value >= lower &&

   |
15 |       value >= lower &&
   |                        ^

ex.dfy(15,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value >= lower &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      value <= upper &&
      value >= lower &&
      IsBST(right, value, upper)

   |
16 |       IsBST(right, value, upper)
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      value <= upper &&
      value >= lower &&
      IsBST(right, value, upper)
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      value <= upper &&
      value >= lower &&
      IsBST(right, value, upper)
  }
}

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['predicate IsBST(tree: Tree, lower: nat, upper: nat) \n']
['  reads tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  decreases tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{

   |
10 | {
   |  ^

ex.dfy(10,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {

   |
11 |   match tree {
   |               ^

ex.dfy(11,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match tree {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true

   |
12 |     case Leaf() => true
   |                        ^

ex.dfy(12,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>

   |
13 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(13,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&

   |
14 |       IsBST(left, lower, value) &&
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      lower <= value && value < upper &&

   |
15 |       lower <= value && value < upper &&
   |                                         ^

ex.dfy(15,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      lower <= value && value < upper &&
      IsBST(right, value, upper)

   |
16 |       IsBST(right, value, upper)
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      lower <= value && value < upper &&
      IsBST(right, value, upper)
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  reads tree
  decreases tree
{
  match tree {
    case Leaf() => true
    case Node(left, value, right) =>
      IsBST(left, lower, value) &&
      lower <= value && value < upper &&
      IsBST(right, value, upper)
  }
}

  |
8 |   reads tree
  |         ^^^^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree
  case Leaf() => true

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(tree: Tree, lower: nat, upper: nat) 
  match tree
  case Leaf() => true
  case Node(left, value, right) =>

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
['// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lo: nat, hi: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  match t
  case Leaf() => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  match t
  case Leaf() => true
  case Node(left, v, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 

  |
8 |   reads t
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
None
['  reads t \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{

  |
9 | {
  |  ^

ex.dfy(9,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {

   |
10 |   match t {
   |            ^

ex.dfy(10,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>

   |
11 |     case Node(left, value, right) =>
   |                                     ^

ex.dfy(11,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&

   |
12 |       IsBST(left, lo, value) &&
   |                                ^

ex.dfy(12,31): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lo, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      lo <= value && value < hi &&

   |
13 |       lo <= value && value < hi &&
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      lo <= value && value < hi &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      lo <= value && value < hi &&
      IsBST(right, value, hi)

   |
14 |       IsBST(right, value, hi)
   |                              ^

ex.dfy(14,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, hi)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      lo <= value && value < hi &&
      IsBST(right, value, hi)
    case Leaf() => true

   |
15 |     case Leaf() => true
   |                        ^

ex.dfy(15,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf() => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      lo <= value && value < hi &&
      IsBST(right, value, hi)
    case Leaf() => true
  }

   |
16 |   }
   |    ^

ex.dfy(16,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Node(left: Tree, value: nat, right: Tree)
  | Leaf()

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lo: nat, hi: nat) 
  reads t 
{
  match t {
    case Node(left, value, right) =>
      IsBST(left, lo, value) &&
      lo <= value && value < hi &&
      IsBST(right, value, hi)
    case Leaf() => true
  }
}

  |
8 |   reads t 
  |         ^

ex.dfy(8,8): Error: a reads-clause expression must denote an object, a set/iset/multiset/seq of objects, or a function to a set/iset/multiset/seq of objects (instead got Tree)
1 resolution/type errors detected in ex.dfy

SCORE
-1.0
['}\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Empty | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a binary search tree (BST)\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 95
number of gen nodes: 48 (including leaves: 18)
number of back nodes: 47 (including leaves: 30)

expansion count: 86 (including failed: 39)

cache stats {'hit': 139, 'miss': 209}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603, 606, 603]

Trial calls: [324, 364, 373, 338, 340, 332, 331, 386, 348]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 604.00 sec, Standard Deviation: 2.45 sec

Call Statistics:

  Min: 324 calls, Max: 386 calls, Average: 348.44 calls, Standard Deviation: 20.02 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603, 606, 603]

Trial calls: [324, 364, 373, 338, 340, 332, 331, 386, 348]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 604.00 sec, Standard Deviation: 2.45 sec

Call Statistics:

  Min: 324 calls, Max: 386 calls, Average: 348.44 calls, Standard Deviation: 20.02 calls

Trial  10
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers

SCORE
1.0
['// (1) ADT for a tree of natural numbers\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST

SCORE
1.0
['// (2) Predicate for whether a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true

  |
8 |     case Leaf => true
  |                      ^

ex.dfy(8,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 

   |
10 |       value > lower &&
   |                       ^

ex.dfy(10,22): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value > lower && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 

   |
11 |       value <= upper &&
   |                        ^

ex.dfy(11,23): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      value <= upper && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 

   |
12 |       IsBST(left, lower, value) &&
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, value) && \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)

   |
13 |       IsBST(right, value, upper)
   |                                 ^

ex.dfy(13,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }

   |
14 |   }
   |    ^

ex.dfy(14,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t

   |
19 | { match t
   |          ^

ex.dfy(19,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)

   |
20 |   { case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(20,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) => 

   |
21 |     case Node(left, tval, right) =>
   |                                    ^

ex.dfy(21,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, tval, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) => 
      (value < tval) ? Node(Insert(left, value), tval, right)

   |
22 |       (value < tval) ? Node(Insert(left, value), tval, right)
   |                      ^

ex.dfy(22,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < tval) ? Node(Insert(left, value), tval, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) => 
      (value < tval) ? Node(Insert(left, value), tval, right)
                    : Node(left, tval, Insert(right, value))

   |
22 |       (value < tval) ? Node(Insert(left, value), tval, right)
   |                      ^

ex.dfy(22,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                    : Node(left, tval, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) => 
      (value < tval) ? Node(Insert(left, value), tval, right)
                    : Node(left, tval, Insert(right, value))
  }

   |
22 |       (value < tval) ? Node(Insert(left, value), tval, right)
   |                      ^

ex.dfy(22,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t {

   |
19 | { match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
20 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(20,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 

   |
21 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)

   |
22 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(22,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))

   |
22 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(22,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                  : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{ match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))
  }

   |
22 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(22,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {

   |
20 |   match t {
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
21 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(21,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>

   |
22 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(22,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {

   |
23 |       if value < v {
   |                    ^

ex.dfy(23,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {
        Node(Insert(left, value), v, right)

   |
23 |       if value < v {
   |                    ^

ex.dfy(23,19): Error: then expected
   |
24 |         Node(Insert(left, value), v, right)
   |                                            ^

ex.dfy(24,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {
        Node(Insert(left, value), v, right)
      } else if value > v {

   |
23 |       if value < v {
   |                    ^

ex.dfy(23,19): Error: then expected
   |
25 |       } else if value > v {
   |                           ^

ex.dfy(25,26): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > v {\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 

   |
22 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(22,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                 : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                 : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                 : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['// (3) Function for inserting an element into a BST\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) => \n']
['      (value < v) ? Node(Insert(left, value), v, right)\n']
['                 : Node(left, v, Insert(right, value))\n']
['  }\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) => \n']
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                  : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {

   |
20 |   match t {
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
21 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(21,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>

   |
22 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(22,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {

   |
23 |       if value < v {
   |                    ^

ex.dfy(23,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {
        Node(Insert(left, value), v, right)

   |
23 |       if value < v {
   |                    ^

ex.dfy(23,19): Error: then expected
   |
24 |         Node(Insert(left, value), v, right)
   |                                            ^

ex.dfy(24,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {
        Node(Insert(left, value), v, right)
      } else if value > v {

   |
23 |       if value < v {
   |                    ^

ex.dfy(23,19): Error: then expected
   |
25 |       } else if value > v {
   |                           ^

ex.dfy(25,26): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > v {\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree

SCORE
1.0
['// (3) Function to insert an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {

   |
20 |   match t {
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
21 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(21,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 

   |
22 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(22,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) => \n']
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                  : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{

   |
19 | {
   |  ^

ex.dfy(19,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {

   |
20 |   match t {
   |            ^

ex.dfy(20,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
21 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(21,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 

   |
22 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(22,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                 : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                 : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                 : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right) 

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right) 
                : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right) 
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function to insert an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right) 
                : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right) 
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['function Insert(t: Tree, value: nat): Tree \n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 

   |
22 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(22,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) => \n']
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                  : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) => 
      value > lower && 
      value <= upper && 
      IsBST(left, lower, value) && 
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) => 
      (value < v) ? Node(Insert(left, value), v, right)
                  : Node(left, v, Insert(right, value))
  }

   |
23 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(23,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t

  |
7 |   match t
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true

  |
8 |   case Leaf => true
  |                    ^

ex.dfy(8,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
9 |   case Node(left, v, right) =>
  |                               ^

ex.dfy(9,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&

   |
10 |     v >= min && v <= max &&
   |                            ^

ex.dfy(10,27): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    v >= min && v <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&

   |
11 |     IsBST(left, min, v - 1) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, v - 1) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&
    IsBST(right, v + 1, max)

   |
12 |     IsBST(right, v + 1, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, v + 1, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, v, right) =>
    v >= min && v <= max &&
    IsBST(left, min, v - 1) &&
    IsBST(right, v + 1, max)
}

ex.dfy(11,23): Error: value does not satisfy the subset constraints of 'nat'
   |
11 |     IsBST(left, min, v - 1) &&
   |                        ^


Dafny program verifier finished with 0 verified, 1 error

SCORE
-1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true
  case Node(left, value, right) => 

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)

SCORE
1.0
['// (2) Predicate for checking if a given tree is a binary search tree (BST)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{

  |
6 | {
  |  ^

ex.dfy(6,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {

  |
7 |   match t {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true

  |
8 |     case Leaf => true
  |                      ^

ex.dfy(8,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>

  |
9 |     case Node(left, value, right) =>
  |                                     ^

ex.dfy(9,36): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&

   |
10 |       lower <= value && value < upper &&
   |                                         ^

ex.dfy(10,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      lower <= value && value < upper &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&

   |
11 |       IsBST(left, lower, value) &&
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(left, lower, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)

   |
12 |       IsBST(right, value, upper)
   |                                 ^

ex.dfy(12,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      IsBST(right, value, upper)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property

SCORE
1.0
['// (3) Function for inserting an element into a binary search tree while preserving the BST property\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
20 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(20,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>

   |
21 |     case Node(left, v, right) =>
   |                                 ^

ex.dfy(21,32): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      (value < v) ? Node(Insert(left, value), v, right)

   |
22 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(22,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < v) ? Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      (value < v) ? Node(Insert(left, value), v, right)
                 : Node(left, v, Insert(right, value))

   |
22 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(22,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                 : Node(left, v, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      (value < v) ? Node(Insert(left, value), v, right)
                 : Node(left, v, Insert(right, value))
  }

   |
22 |       (value < v) ? Node(Insert(left, value), v, right)
   |                   ^

ex.dfy(22,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v { Node(Insert(left, value), v, right) }

   |
22 |       if value < v { Node(Insert(left, value), v, right) }
   |                    ^

ex.dfy(22,19): Error: then expected
   |
22 |       if value < v { Node(Insert(left, value), v, right) }
   |                                                           ^

ex.dfy(22,58): Error: else expected
2 parse errors detected in ex.dfy

SCORE
None
['      if value < v { Node(Insert(left, value), v, right) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v { Node(Insert(left, value), v, right) }
      else { Node(left, v, Insert(right, value)) }

   |
22 |       if value < v { Node(Insert(left, value), v, right) }
   |                    ^

ex.dfy(22,19): Error: then expected
   |
23 |       else { Node(left, v, Insert(right, value)) }
   |                                                   ^

ex.dfy(23,50): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      else { Node(left, v, Insert(right, value)) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v { Node(Insert(left, value), v, right) }
      else { Node(left, v, Insert(right, value)) }
  }

   |
22 |       if value < v { Node(Insert(left, value), v, right) }
   |                    ^

ex.dfy(22,19): Error: then expected
   |
24 |   }
   |    ^

ex.dfy(24,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) =>\n']
['      if value < v { Node(Insert(left, value), v, right) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v { Node(Insert(left, value), v, right) }
      else if value > v { Node(left, v, Insert(right, value)) }

   |
22 |       if value < v { Node(Insert(left, value), v, right) }
   |                    ^

ex.dfy(22,19): Error: then expected
   |
23 |       else if value > v { Node(left, v, Insert(right, value)) }
   |                         ^

ex.dfy(23,24): Error: then expected
   |
23 |       else if value > v { Node(left, v, Insert(right, value)) }
   |                                                                ^

ex.dfy(23,63): Error: else expected
3 parse errors detected in ex.dfy

SCORE
None
['      else if value > v { Node(left, v, Insert(right, value)) }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v { Node(Insert(left, value), v, right) }
      else if value > v { Node(left, v, Insert(right, value)) }
      else { t }

   |
22 |       if value < v { Node(Insert(left, value), v, right) }
   |                    ^

ex.dfy(22,19): Error: then expected
   |
23 |       else if value > v { Node(left, v, Insert(right, value)) }
   |                         ^

ex.dfy(23,24): Error: then expected
   |
24 |       else { t }
   |                 ^

ex.dfy(24,16): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['      else { t }\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {
        Node(Insert(left, value), v, right)

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
   |
23 |         Node(Insert(left, value), v, right)
   |                                            ^

ex.dfy(23,43): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree while preserving the BST property
function Insert(t: Tree, value: nat): Tree
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, v, right) =>
      if value < v {
        Node(Insert(left, value), v, right)
      } else if value > v {

   |
22 |       if value < v {
   |                    ^

ex.dfy(22,19): Error: then expected
   |
24 |       } else if value > v {
   |                           ^

ex.dfy(24,26): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree

SCORE
1.0
['// (3) Function for inserting an element into a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{ match t

   |
18 | { match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{ match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)

   |
19 |   { case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(19,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  { case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) =>

   |
20 |     case Node(left, tval, right) =>
   |                                    ^

ex.dfy(20,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, tval, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) =>
      (value < tval) ? Node(Insert(left, value), tval, right)

   |
21 |       (value < tval) ? Node(Insert(left, value), tval, right)
   |                      ^

ex.dfy(21,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      (value < tval) ? Node(Insert(left, value), tval, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) =>
      (value < tval) ? Node(Insert(left, value), tval, right)
                     : Node(left, tval, Insert(right, value))

   |
21 |       (value < tval) ? Node(Insert(left, value), tval, right)
   |                      ^

ex.dfy(21,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['                     : Node(left, tval, Insert(right, value))\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{ match t
  { case Leaf => Node(Leaf, value, Leaf)
    case Node(left, tval, right) =>
      (value < tval) ? Node(Insert(left, value), tval, right)
                     : Node(left, tval, Insert(right, value))
  }

   |
21 |       (value < tval) ? Node(Insert(left, value), tval, right)
   |                      ^

ex.dfy(21,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{

   |
18 | {
   |  ^

ex.dfy(18,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {

   |
19 |   match t {
   |            ^

ex.dfy(19,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)

   |
20 |     case Leaf => Node(Leaf, value, Leaf)
   |                                         ^

ex.dfy(20,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>

   |
21 |     case Node(left, nodeValue, right) =>
   |                                         ^

ex.dfy(21,40): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    case Node(left, nodeValue, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue {

   |
22 |       if value < nodeValue {
   |                            ^

ex.dfy(22,27): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['      if value < nodeValue {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue {
        Node(Insert(left, value), nodeValue, right)

   |
22 |       if value < nodeValue {
   |                            ^

ex.dfy(22,27): Error: then expected
   |
23 |         Node(Insert(left, value), nodeValue, right)
   |                                                    ^

ex.dfy(23,51): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['        Node(Insert(left, value), nodeValue, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree (BST)
predicate IsBST(t: Tree, lower: nat, upper: nat) 
{
  match t {
    case Leaf => true
    case Node(left, value, right) =>
      lower <= value && value < upper &&
      IsBST(left, lower, value) &&
      IsBST(right, value, upper)
  }
}

// (3) Function for inserting an element into a binary search tree
function Insert(t: Tree, value: nat): Tree 
{
  match t {
    case Leaf => Node(Leaf, value, Leaf)
    case Node(left, nodeValue, right) =>
      if value < nodeValue {
        Node(Insert(left, value), nodeValue, right)
      } else if value > nodeValue {

   |
22 |       if value < nodeValue {
   |                            ^

ex.dfy(22,27): Error: then expected
   |
24 |       } else if value > nodeValue {
   |                                   ^

ex.dfy(24,34): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['      } else if value > nodeValue {\n']
['{\n']
['  match t {\n']
['    case Leaf => Node(Leaf, value, Leaf)\n']
['    case Node(left, v, right) =>\n']
['      (value < v) ? Node(Insert(left, value), v, right)\n']
['                 : Node(left, v, Insert(right, value))\n']
['  }\n']
['{\n']
['  match t\n']
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>

  |
9 |   case Node(left, value, right) =>
  |                                   ^

ex.dfy(9,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&

   |
10 |     value >= min && value <= max &&
   |                                    ^

ex.dfy(10,35): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    value >= min && value <= max &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&

   |
11 |     IsBST(left, min, value) &&
   |                               ^

ex.dfy(11,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(left, min, value) &&\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)

   |
12 |     IsBST(right, value, max)
   |                             ^

ex.dfy(12,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    IsBST(right, value, max)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST

SCORE
1.0
['// (3) Function to insert an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
19 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(19,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function to insert an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['function Insert(t: Tree, value: nat): Tree\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST

SCORE
1.0
['// (3) Function for inserting an element into a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree

SCORE
1.0
['function Insert(t: Tree, value: nat): Tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{

   |
17 | {
   |  ^

ex.dfy(17,1): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t

   |
18 |   match t
   |          ^

ex.dfy(18,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)

   |
19 |   case Leaf => Node(Leaf, value, Leaf)
   |                                       ^

ex.dfy(19,38): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => Node(Leaf, value, Leaf)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>

   |
20 |   case Node(left, v, right) =>
   |                               ^

ex.dfy(20,30): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
1 parse errors detected in ex.dfy

SCORE
None
['    if value < v {\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
22 |       Node(Insert(left, value), v, right)
   |                                          ^

ex.dfy(22,41): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['      Node(Insert(left, value), v, right)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for whether a tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
{
  match t
  case Leaf => true
  case Node(left, value, right) =>
    value >= min && value <= max &&
    IsBST(left, min, value) &&
    IsBST(right, value, max)
}

// (3) Function for inserting an element into a BST
function Insert(t: Tree, value: nat): Tree
{
  match t
  case Leaf => Node(Leaf, value, Leaf)
  case Node(left, v, right) =>
    if value < v {
      Node(Insert(left, value), v, right)
    } else if value > v {

   |
21 |     if value < v {
   |                  ^

ex.dfy(21,17): Error: then expected
   |
23 |     } else if value > v {
   |                         ^

ex.dfy(23,24): Error: then expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    } else if value > v {\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST

SCORE
1.0
['// (2) Predicate for BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true
  case Node(left, v, right) => 

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) => \n']
['  match t\n']
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Leaf => true
  case Node(left, value, right) => 

  |
6 |   match t
  |   ^

ex.dfy(6,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) => \n']
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Leaf => true

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Leaf => true
    case Node(left, value, right) => 

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, value, right) => \n']
['    match t\n']
['    case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree = Leaf | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
    match t
    case Leaf => true
    case Node(left, v, right) => 

  |
6 |     match t
  |     ^

ex.dfy(6,4): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Node(left, v, right) => \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =

  |
2 | datatype Tree =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil

SCORE
1.0
['  | Nil\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST

SCORE
1.0
['// (2) Predicate that checks whether a given tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Nil => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Nil => true
  case Node(left, value, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
['  match t\n']
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Nil => true
  case Node(left, v, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: int, max: int) 

SCORE
1.0
['predicate IsBST(t: Tree, min: int, max: int) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: int, max: int) 
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: int, max: int) 
  match t
  case Nil => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: int, max: int) 
  match t
  case Nil => true
  case Node(left, value, right) => 

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) => \n']
['  match t\n']
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate that checks whether a given tree is a BST
predicate IsBST(t: Tree, min: int, max: int) 
  match t
  case Nil => true
  case Node(left, value, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST

SCORE
1.0
['// (2) Predicate for checking if a tree is a BST\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat) \n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Nil => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Nil => true
  case Node(left, value, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
['  match t\n']
['  case Nil => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Nil
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a BST
predicate IsBST(t: Tree, lower: nat, upper: nat) 
  match t
  case Nil => true
  case Node(left, v, right) => 

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) => \n']
['  match t\n']
['  case Nil => true\n']
['  case Node(left, value, right) =>\n']
['{\n']
['  match t\n']
['  case Leaf => Node(Leaf, value, Leaf)\n']
['  case Node(left, v, right) =>\n']
['    if value < v {\n']
['      Node(Insert(left, value), v, right)\n']
['    } else if value > v {\n']
['// (1) ADT for a tree of natural numbers\n']
['datatype Tree =\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf

SCORE
1.0
['  | Leaf\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

SCORE
1.0
['  | Node(left: Tree, value: nat, right: Tree)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree

SCORE
1.0
['// (2) Predicate for checking if a tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(t: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  match t
  case Leaf => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  match t
  case Leaf => true
  case Node(left, v, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, v, right) =>\n']
['  match t\n']
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, lower: nat, upper: nat)
  match t
  case Leaf => true
  case Node(left, value, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)

SCORE
1.0
['predicate IsBST(t: Tree, min: nat, max: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  match t

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match t\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Leaf => true

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a tree is a binary search tree
predicate IsBST(t: Tree, min: nat, max: nat)
  match t
  case Leaf => true
  case Node(left, value, right) =>

  |
8 |   match t
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
['  match t\n']
['  case Leaf => true\n']
['  case Node(left, value, right) =>\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree

SCORE
1.0
['// (2) Predicate for checking if a given tree is a binary search tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)

SCORE
1.0
['predicate IsBST(tree: Tree, lower: nat, upper: nat)\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  match tree

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  match tree\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  match tree
  case Leaf => true

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
None
['  case Leaf => true\n']
TEXT
### Spec: In Dafny, (1) write an ADT for a tree of natural numbers.
Then (2) write a predicate that checks whether a given tree is a binary search tree (BST).
Then (3) write a function that inserts an element into a binary search tree while preserving the BST property.
Then (4) write a predicate that checks whether a given tree contains a given element.
Then (5) write a lemma about the insert function that ensures that the tree resulting from inserting an element contains that element (without requiring nor ensuring the BST property).
Then (6) write another lemma about the insert function that checks the BST property continues to hold after insertion. This lemma should take bounds on the BST, and require that the element to be inserted is within those bounds.
### Hint: For each proof, do not use assertions. Just analyze the structure based on the insert function, and recursively call the lemma to match the recursive calls in the function.
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: do not have `requires` nor `ensures` clauses in the insert function. The lemmas will be proved after the definition; in those lemmas, have `requires` and `ensures` clauses.

```dafny
// (1) ADT for a tree of natural numbers
datatype Tree =
  | Leaf
  | Node(left: Tree, value: nat, right: Tree)

// (2) Predicate for checking if a given tree is a binary search tree
predicate IsBST(tree: Tree, lower: nat, upper: nat)
  match tree
  case Leaf => true
  case Node(left, value, right) =>

  |
8 |   match tree
  |   ^

ex.dfy(8,2): Error: this symbol not expected in FunctionSpec
1 parse errors detected in ex.dfy

SCORE
-1.0
['  case Node(left, value, right) =>\n']
['  match tree\n']
['  case Leaf => true\n']
['  case Node(left, value, right) =>\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 111
number of gen nodes: 56 (including leaves: 20)
number of back nodes: 55 (including leaves: 36)

expansion count: 102 (including failed: 47)

cache stats {'hit': 121, 'miss': 211}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603, 606, 603, 602]

Trial calls: [324, 364, 373, 338, 340, 332, 331, 386, 348, 332]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.80 sec, Standard Deviation: 2.40 sec

Call Statistics:

  Min: 324 calls, Max: 386 calls, Average: 346.80 calls, Standard Deviation: 19.63 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 602, 608, 601, 607, 605, 603, 606, 603, 602]

Trial calls: [324, 364, 373, 338, 340, 332, 331, 386, 348, 332]


Time Statistics:

  Min: 601.00 sec, Max: 608.00 sec, Average: 603.80 sec, Standard Deviation: 2.40 sec

Call Statistics:

  Min: 324 calls, Max: 386 calls, Average: 346.80 calls, Standard Deviation: 19.63 calls

To complete all experiments, 101 minutes and 22 seconds elapsed.


