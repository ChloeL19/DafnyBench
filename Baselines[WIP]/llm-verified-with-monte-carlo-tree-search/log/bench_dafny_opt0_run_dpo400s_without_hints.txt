

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 6 --language Dafny --problem_name problem_opt0 --seed 42 --remove_hints True --base_model_name ./my_dpo_model 


[2024-01-12 12:18:34,949] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)

SCORE
1.0
['datatype Expr = Const(v: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)

SCORE
1.0
['              | Var(n: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
7 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(7,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {

  |
8 |   match e {
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v,

  |
9 |     case Const(v) => v,
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(v) => v,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v,
    case Var(n) => env(n),

  |
9 |     case Const(v) => v,
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(n) => env(n),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v,
    case Var(n) => env(n),
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

  |
9 |     case Const(v) => v,
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {

  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        Const(v) => v,

  |
9 |         Const(v) => v,
  |         ^

ex.dfy(9,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Const(v) => v,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        Const(v) => v,
        Var(n) => env(n),

  |
9 |         Const(v) => v,
  |         ^

ex.dfy(9,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        Var(n) => env(n),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        Const(v) => v,
        Var(n) => env(n),
        Add(e1, e2) => eval(e1, env) + eval(e2, env)

  |
9 |         Const(v) => v,
  |         ^

ex.dfy(9,8): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['        Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
['// Evaluator\n']
['function eval(e: Expr, env: string -> int): int {\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v

  |
9 |     case Const(v) => v
  |                       ^

ex.dfy(9,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)

   |
10 |     case Var(n) => env(n)
   |                          ^

ex.dfy(10,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(n) => env(n)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
11 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(11,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
16 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(16,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {

   |
17 |   match e {
   |            ^

ex.dfy(17,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
18 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
19 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(19,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
20 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(20,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
21 |     case _ => e
   |                ^

ex.dfy(21,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
22 |   }
   |    ^

ex.dfy(22,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics

SCORE
1.0
['// Lemma: optimizer preserves semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
29 |   match e {
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // base case: constants

   |
30 |     case Const(_) => () // base case: constants
   |                                                ^

ex.dfy(30,47): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => () // base case: constants\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // base case: constants
    case Var(_) => ()   // base case: variables

   |
31 |     case Var(_) => ()   // base case: variables
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Const(_) => () // base case: constants
   |                      ^

ex.dfy(30,21): Error: missing semicolon at end of statement
   |
31 |     case Var(_) => ()   // base case: variables
   |                                                ^

ex.dfy(31,47): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()   // base case: variables\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // base case: constants
    case Var(_) => ()   // base case: variables
    case Add(e1, e2) => 

   |
31 |     case Var(_) => ()   // base case: variables
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Const(_) => () // base case: constants
   |                      ^

ex.dfy(30,21): Error: missing semicolon at end of statement
   |
32 |     case Add(e1, e2) =>
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Var(_) => ()   // base case: variables
   |                    ^

ex.dfy(31,19): Error: missing semicolon at end of statement
   |
32 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(32,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // base case: constants
    case Var(_) => ()   // base case: variables
    case Add(e1, e2) => 
      // inductive case: additions

   |
31 |     case Var(_) => ()   // base case: variables
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Const(_) => () // base case: constants
   |                      ^

ex.dfy(30,21): Error: missing semicolon at end of statement
   |
32 |     case Add(e1, e2) => 
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Var(_) => ()   // base case: variables
   |                    ^

ex.dfy(31,19): Error: missing semicolon at end of statement
   |
33 |       // inductive case: additions
   |                                   ^

ex.dfy(33,34): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      // inductive case: additions\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()

   |
30 |     case Const(_) => ()
   |                        ^

ex.dfy(30,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
31 |     case Var(_) => ()
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Const(_) => ()
   |                      ^

ex.dfy(30,21): Error: missing semicolon at end of statement
   |
31 |     case Var(_) => ()
   |                      ^

ex.dfy(31,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
31 |     case Var(_) => ()
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Const(_) => ()
   |                      ^

ex.dfy(30,21): Error: missing semicolon at end of statement
   |
32 |     case Add(e1, e2) =>
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Var(_) => ()
   |                    ^

ex.dfy(31,19): Error: missing semicolon at end of statement
   |
32 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(32,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
31 |     case Var(_) => ()
   |     ^

ex.dfy(31,4): Error: invalid Suffix
   |
30 |     case Const(_) => ()
   |                      ^

ex.dfy(30,21): Error: missing semicolon at end of statement
   |
32 |     case Add(e1, e2) =>
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Var(_) => ()
   |                    ^

ex.dfy(31,19): Error: missing semicolon at end of statement
   |
33 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(33,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e1, env);\n']
['  ensures eval(optimize(e), env) == eval(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>

   |
30 |     case Const(_) =>
   |                     ^

ex.dfy(30,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>

   |
31 |     case Var(_) =>
   |                   ^

ex.dfy(31,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
32 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(32,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
33 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(33,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
34 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }

   |
35 |   }
   |    ^

ex.dfy(35,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int)
              | Var(n: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 37
number of gen nodes: 19 (including leaves: 3)
number of back nodes: 18 (including leaves: 16)

expansion count: 23 (including failed: 5)

cache stats {'hit': 15, 'miss': 52}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134]

Trial calls: [67]


Time Statistics:

  Min: 134.00 sec, Max: 134.00 sec, Average: 134.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 67 calls, Max: 67 calls, Average: 67.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134]

Trial calls: [67]


Time Statistics:

  Min: 134.00 sec, Max: 134.00 sec, Average: 134.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 67 calls, Max: 67 calls, Average: 67.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)

SCORE
1.0
['  | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string => int): int {

  |
8 | function evaluate(e: Expr, env: string => int): int {
  |                                        ^

ex.dfy(8,39): Error: closeparen expected
  |
8 | function evaluate(e: Expr, env: string => int): int {
  |                                                      ^

ex.dfy(8,53): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string => int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string => int): int {
  match e {

  |
8 | function evaluate(e: Expr, env: string => int): int {
  |                                        ^

ex.dfy(8,39): Error: closeparen expected
  |
9 |   match e {
  |            ^

ex.dfy(9,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string => int): int {
  match e {
    case Const(val) => val

  |
8 | function evaluate(e: Expr, env: string => int): int {
  |                                        ^

ex.dfy(8,39): Error: closeparen expected
   |
10 |     case Const(val) => val
   |                           ^

ex.dfy(10,26): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
8 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(8,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {

  |
9 |   match e {
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val

   |
10 |     case Const(val) => val
   |                           ^

ex.dfy(10,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)

   |
11 |     case Var(name) => env(name)
   |                                ^

ex.dfy(11,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
12 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
17 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(17,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {

   |
18 |   match e {
   |            ^

ex.dfy(18,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2

   |
19 |     case Add(Const(0), e2) => e2
   |                                 ^

ex.dfy(19,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1

   |
20 |     case Add(e1, Const(0)) => e1
   |                                 ^

ex.dfy(20,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
21 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(21,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
22 |     case _ => e
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
23 |   }
   |    ^

ex.dfy(23,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics

SCORE
1.0
['// Lemma: optimizer preserves semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerSemantics(e: Expr, env: string -> int) {

   |
27 | lemma OptimizerSemantics(e: Expr, env: string -> int) {
   |                                                        ^

ex.dfy(27,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['lemma OptimizerSemantics(e: Expr, env: string -> int) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)

   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)
}

   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)
}


   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)
}

lemma OptimizerSemantics(e: Expr, env: string -> int) {

   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['lemma OptimizerSemantics(e: Expr, env: string -> int) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) {

   |
27 | lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) {
   |                                                                 ^

ex.dfy(27,64): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) {
  ensure eval(optimize(e), env) == eval(e, env)

   |
28 |   ensure eval(optimize(e), env) == eval(e, env)
   |   ^^^^^^

ex.dfy(28,2): Error: missing semicolon at end of statement
   |
28 |   ensure eval(optimize(e), env) == eval(e, env)
   |                                 ^

ex.dfy(28,32): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  ensure eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) {
  ensure eval(optimize(e), env) == eval(e, env)
}

   |
28 |   ensure eval(optimize(e), env) == eval(e, env)
   |   ^^^^^^

ex.dfy(28,2): Error: missing semicolon at end of statement
   |
28 |   ensure eval(optimize(e), env) == eval(e, env)
   |                                 ^

ex.dfy(28,32): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) {
  ensure eval(optimize(e), env) == eval(e, env)
}
```

   |
28 |   ensure eval(optimize(e), env) == eval(e, env)
   |   ^^^^^^

ex.dfy(28,2): Error: missing semicolon at end of statement
   |
28 |   ensure eval(optimize(e), env) == eval(e, env)
   |                                 ^

ex.dfy(28,32): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
-1.0
['```\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.

SCORE
1.0
['// Lemma: The optimizer preserves the semantics as defined by the evaluation function.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
30 |   match e {
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>

   |
31 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(31,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.

   |
32 |       // The optimization case.
   |                                ^

ex.dfy(32,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The optimization case.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);

   |
33 |       assert eval(optimize(e), env) == eval(e2, env);
   |                                                      ^

ex.dfy(33,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);

   |
34 |       assert eval(e, env) == eval(Add(Const(0), e2), env);
   |                                                           ^

ex.dfy(34,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(Const(0), e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);

   |
35 |       assert eval(e, env) == eval(e2, env);
   |                                            ^

ex.dfy(35,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      

   |
35 |       assert eval(e, env) == eval(e2, env);
   |                                            ^

ex.dfy(35,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>

   |
37 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(37,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.

   |
38 |       // The optimization case.
   |                                ^

ex.dfy(38,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The optimization case.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);

   |
39 |       assert eval(optimize(e), env) == eval(e1, env);
   |                                                      ^

ex.dfy(39,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);

   |
40 |       assert eval(e, env) == eval(Add(e1, Const(0)), env);
   |                                                           ^

ex.dfy(40,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(e1, Const(0)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);

   |
41 |       assert eval(e, env) == eval(e1, env);
   |                                            ^

ex.dfy(41,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      

   |
41 |       assert eval(e, env) == eval(e1, env);
   |                                            ^

ex.dfy(41,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>

   |
43 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(43,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.

   |
44 |       // The recursive case.
   |                             ^

ex.dfy(44,28): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The recursive case.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);

   |
45 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(45,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
46 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(46,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);

   |
47 |       assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
   |                                                                                   ^

ex.dfy(47,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);

   |
48 |       assert eval(e, env) == eval(Add(e1, e2), env);
   |                                                     ^

ex.dfy(48,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);

   |
49 |       assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
   |                                                                         ^

ex.dfy(49,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
      

   |
49 |       assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
   |                                                                         ^

ex.dfy(49,72): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
      
    case _ =>

   |
51 |     case _ =>
   |              ^

ex.dfy(51,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
      
    case _ =>
      // The base cases.

   |
52 |       // The base cases.
   |                         ^

ex.dfy(52,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The base cases.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
      
    case _ =>
      // The base cases.
      assert eval(optimize(e), env) == eval(e, env);

   |
53 |       assert eval(optimize(e), env) == eval(e, env);
   |                                                     ^

ex.dfy(53,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
      
    case _ =>
      // The base cases.
      assert eval(optimize(e), env) == eval(e, env);
  }

   |
54 |   }
   |    ^

ex.dfy(54,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(e, env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      // The optimization case.
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(e, env) == eval(e1, env);
      
    case Add(e1, e2) =>
      // The recursive case.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(e, env) == eval(Add(optimize(e1), optimize(e2)), env);
      
    case _ =>
      // The base cases.
      assert eval(optimize(e), env) == eval(e, env);
  }
}

ex.dfy(31,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(4636,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);

   |
32 |       assert eval(optimize(e), env) == eval(e2, env);
   |                                                      ^

ex.dfy(32,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);

   |
33 |       assert eval(e, env) == eval(Add(Const(0), e2), env);
   |                                                           ^

ex.dfy(33,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(Const(0), e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);

   |
34 |       assert eval(Add(Const(0), e2), env) == eval(e2, env);
   |                                                            ^

ex.dfy(34,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(Add(Const(0), e2), env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      

   |
34 |       assert eval(Add(Const(0), e2), env) == eval(e2, env);
   |                                                            ^

ex.dfy(34,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>

   |
36 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(36,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);

   |
37 |       assert eval(optimize(e), env) == eval(e1, env);
   |                                                      ^

ex.dfy(37,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);

   |
38 |       assert eval(e, env) == eval(Add(e1, Const(0)), env);
   |                                                           ^

ex.dfy(38,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(e1, Const(0)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);

   |
39 |       assert eval(Add(e1, Const(0)), env) == eval(e1, env);
   |                                                            ^

ex.dfy(39,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(Add(e1, Const(0)), env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      

   |
39 |       assert eval(Add(e1, Const(0)), env) == eval(e1, env);
   |                                                            ^

ex.dfy(39,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>

   |
41 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(41,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);

   |
42 |       assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
   |                                                                                   ^

ex.dfy(42,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);

   |
43 |       assert eval(e, env) == eval(Add(e1, e2), env);
   |                                                     ^

ex.dfy(43,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);

   |
44 |       assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
   |                                                                                   ^

ex.dfy(44,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
      

   |
44 |       assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
   |                                                                                   ^

ex.dfy(44,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
      
    case _ =>

   |
46 |     case _ =>
   |              ^

ex.dfy(46,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
      
    case _ =>
      assert eval(optimize(e), env) == eval(e, env);

   |
47 |       assert eval(optimize(e), env) == eval(e, env);
   |                                                     ^

ex.dfy(47,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
      
    case _ =>
      assert eval(optimize(e), env) == eval(e, env);
  }

   |
48 |   }
   |    ^

ex.dfy(48,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(Add(Const(0), e2), env) == eval(e2, env);
      
    case Add(e1, Const(0)) =>
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(Add(e1, Const(0)), env) == eval(e1, env);
      
    case Add(e1, e2) =>
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(Add(optimize(e1), optimize(e2)), env) == eval(Add(e1, e2), env);
      
    case _ =>
      assert eval(optimize(e), env) == eval(e, env);
  }
}

ex.dfy(31,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(4612,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['  ensures eval(optimize(e), env) == eval(e, env)\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
32 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(32,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
33 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(33,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
34 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
35 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(35,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ =>

   |
36 |     case _ =>
   |              ^

ex.dfy(36,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ =>
  }

   |
37 |   }
   |    ^

ex.dfy(37,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ =>
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ =>
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
    case _ =>
  }
}
```


STATS

number of nodes: 37
number of gen nodes: 19 (including leaves: 3)
number of back nodes: 18 (including leaves: 16)

expansion count: 23 (including failed: 5)

cache stats {'hit': 7, 'miss': 94}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226]

Trial calls: [67, 101]


Time Statistics:

  Min: 134.00 sec, Max: 226.00 sec, Average: 180.00 sec, Standard Deviation: 46.00 sec

Call Statistics:

  Min: 67 calls, Max: 101 calls, Average: 84.00 calls, Standard Deviation: 17.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226]

Trial calls: [67, 101]


Time Statistics:

  Min: 134.00 sec, Max: 226.00 sec, Average: 180.00 sec, Standard Deviation: 46.00 sec

Call Statistics:

  Min: 67 calls, Max: 101 calls, Average: 84.00 calls, Standard Deviation: 17.00 calls

Trial  3
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {

  |
5 | function evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(5,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v

  |
7 |     case Const(v) => v
  |                       ^

ex.dfy(7,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)

  |
9 |     case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  |                                                              ^

ex.dfy(9,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics

SCORE
1.0
['// Lemma: Optimizer preserves semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)

SCORE
1.0
['  ensures evaluate(optimize(e), env) == evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>

   |
28 |     case Const(_) =>
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>

   |
29 |     case Var(_) =>
   |                   ^

ex.dfy(29,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
31 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(31,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
32 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(32,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: Optimizer preserves semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures evaluate(optimize(e), env) == evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 1)
number of back nodes: 14 (including leaves: 14)

expansion count: 14 (including failed: 0)

cache stats {'hit': 0, 'miss': 35}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84]

Trial calls: [67, 101, 35]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 148.00 sec, Standard Deviation: 58.81 sec

Call Statistics:

  Min: 35 calls, Max: 101 calls, Average: 67.67 calls, Standard Deviation: 26.95 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84]

Trial calls: [67, 101, 35]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 148.00 sec, Standard Deviation: 58.81 sec

Call Statistics:

  Min: 35 calls, Max: 101 calls, Average: 67.67 calls, Standard Deviation: 26.95 calls

Trial  4
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)

SCORE
1.0
['datatype Expr = Const(i: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)

SCORE
1.0
['             | Var(n: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

SCORE
1.0
['             | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {

  |
5 | function Evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(5,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i

  |
7 |     case Const(i) => i
  |                       ^

ex.dfy(7,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(i) => i\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)

  |
8 |     case Var(n) => env(n)
  |                          ^

ex.dfy(8,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(n) => env(n)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

  |
9 |     case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  |                                                              ^

ex.dfy(9,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {

   |
13 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {

   |
14 |   match e {
   |            ^

ex.dfy(14,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2

   |
15 |     case Add(Const(0), e2) => e2
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1

   |
16 |     case Add(e1, Const(0)) => e1
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
17 |     case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                        ^

ex.dfy(17,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e

   |
18 |     case _ => e
   |                ^

ex.dfy(18,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }

   |
19 |   }
   |    ^

ex.dfy(19,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) => 

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) => 
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) => 
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) => 

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) => 
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['\n']
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizerPreservesSemantics(e1, env);\n']
['\n']
['function Optimize(e: Expr): Expr {\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)

   |
15 |     case Add(Const(0), e2) => Optimize(e2)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)

   |
16 |     case Add(e1, Const(0)) => Optimize(e1)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
17 |     case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                        ^

ex.dfy(17,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e

   |
18 |     case _ => e
   |                ^

ex.dfy(18,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }

   |
19 |   }
   |    ^

ex.dfy(19,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Your proof goes here

   |
25 |   // Your proof goes here
   |                          ^

ex.dfy(25,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  // Your proof goes here\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Your proof goes here
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Your proof goes here
}
```Dafny code:

SCORE
1.0
['```Dafny code:\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int)
             | Var(n: string)
             | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i
    case Var(n) => env(n)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int) 
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  // Your proof goes here
}
```Dafny code:


STATS

number of nodes: 51
number of gen nodes: 26 (including leaves: 7)
number of back nodes: 25 (including leaves: 19)

expansion count: 38 (including failed: 13)

cache stats {'hit': 64, 'miss': 61}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217]

Trial calls: [67, 101, 35, 125]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 165.25 sec, Standard Deviation: 59.05 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 82.00 calls, Standard Deviation: 34.07 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217]

Trial calls: [67, 101, 35, 125]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 165.25 sec, Standard Deviation: 59.05 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 82.00 calls, Standard Deviation: 34.07 calls

Trial  5
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)

SCORE
1.0
['datatype Expr = Const(v: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {

  |
5 | function Evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(5,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v

  |
7 |     case Const(v) => v
  |                       ^

ex.dfy(7,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

  |
9 |     case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  |                                                              ^

ex.dfy(9,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {

   |
13 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {

   |
14 |   match e {
   |            ^

ex.dfy(14,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2

   |
15 |     case Add(Const(0), e2) => e2
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1

   |
16 |     case Add(e1, Const(0)) => e1
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
17 |     case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                        ^

ex.dfy(17,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e

   |
18 |     case _ => e
   |                ^

ex.dfy(18,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }

   |
19 |   }
   |    ^

ex.dfy(19,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>

   |
26 |     case Const(_) =>
   |                     ^

ex.dfy(26,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>

   |
27 |     case Var(_) =>
   |                   ^

ex.dfy(27,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);

   |
30 |       OptimizePreservesSemantics(e2, env);
   |                                           ^

ex.dfy(30,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(v: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 25
number of gen nodes: 13 (including leaves: 1)
number of back nodes: 12 (including leaves: 12)

expansion count: 13 (including failed: 1)

cache stats {'hit': 2, 'miss': 37}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87]

Trial calls: [67, 101, 35, 125, 39]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 149.60 sec, Standard Deviation: 61.39 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 73.40 calls, Standard Deviation: 34.99 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87]

Trial calls: [67, 101, 35, 125, 39]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 149.60 sec, Standard Deviation: 61.39 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 73.40 calls, Standard Deviation: 34.99 calls

Trial  6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {

  |
3 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(3,28): Error: invalid TypeAndToken
  |
3 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                    ^

ex.dfy(3,67): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: function (string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {
  match e {

  |
3 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(3,28): Error: invalid TypeAndToken
  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: function (string) returns (int)): int {
  match e {
    case Const(i) => i,

  |
3 | function Eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(3,28): Error: invalid TypeAndToken
  |
5 |     case Const(i) => i,
  |                       ^

ex.dfy(5,22): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(i) => i,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: function (string) returns (int)): int {

  |
3 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(3,28): Error: invalid TypeAndToken
  |
3 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                                                                    ^

ex.dfy(3,67): Error: invalid UnaryExpression
2 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: function (string) returns (int)): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: function (string) returns (int)): int {
  match e {

  |
3 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(3,28): Error: invalid TypeAndToken
  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function eval(e: Expr, env: function (string) returns (int)): int {
  match e {
    case Const(i) => i,

  |
3 | function eval(e: Expr, env: function (string) returns (int)): int {
  |                             ^

ex.dfy(3,28): Error: invalid TypeAndToken
  |
5 |     case Const(i) => i,
  |                       ^

ex.dfy(5,22): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['    case Const(i) => i,\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
3 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(3,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i,

  |
5 |     case Const(i) => i,
  |                       ^

ex.dfy(5,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(i) => i,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i,
    case Var(n) => env(n),

  |
5 |     case Const(i) => i,
  |                       ^

ex.dfy(5,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(n) => env(n),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(i: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(i) => i,
    case Var(n) => env(n),
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

  |
5 |     case Const(i) => i,
  |                       ^

ex.dfy(5,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
['function Eval(e: Expr, env: string -> int): int {\n']
['  match e {\n']
['    case Const(i) => i,\n']
['    case Var(n) => env(n),\n']
['    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 

SCORE
1.0
['datatype Expr = Const(val: int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 

SCORE
1.0
['              | Var(name: string) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr);

  |
3 |               | Add(e1: Expr, e2: Expr);
  |                                        ^

ex.dfy(3,39): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['              | Add(e1: Expr, e2: Expr);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr);


  |
3 |               | Add(e1: Expr, e2: Expr);
  |                                        ^

ex.dfy(3,39): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr);

function int Evaluate(e: Expr, env: string -> int): int {

  |
3 |               | Add(e1: Expr, e2: Expr);
  |                                        ^

ex.dfy(3,39): Error: this symbol not expected in Dafny
1 parse errors detected in ex.dfy

SCORE
-1.0
['function int Evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {

  |
5 | function Eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val

  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)

  |
9 |     case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  |                                                      ^

ex.dfy(9,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {

   |
13 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {

   |
14 |   match e {
   |            ^

ex.dfy(14,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)

   |
15 |     case Add(Const(0), e2) => Optimize(e2)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => Optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)

   |
16 |     case Add(e1, Const(0)) => Optimize(e1)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => Optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
17 |     case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                        ^

ex.dfy(17,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e

   |
18 |     case _ => e
   |                ^

ex.dfy(18,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }

   |
19 |   }
   |    ^

ex.dfy(19,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)

SCORE
1.0
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) => 

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) => 
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) => 
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['  ensures Eval(Optimize(e), env) == Eval(e, env)\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>

   |
26 |     case Const(_) =>
   |                     ^

ex.dfy(26,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>

   |
27 |     case Var(_) =>
   |                   ^

ex.dfy(27,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);

   |
30 |       OptimizePreservesSemantics(e2, env);
   |                                           ^

ex.dfy(30,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizePreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int) 
              | Var(name: string) 
              | Add(e1: Expr, e2: Expr)

function Eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => Optimize(e2)
    case Add(e1, Const(0)) => Optimize(e1)
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Eval(Optimize(e), env) == Eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);
      OptimizePreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 33
number of gen nodes: 17 (including leaves: 4)
number of back nodes: 16 (including leaves: 13)

expansion count: 23 (including failed: 7)

cache stats {'hit': 13, 'miss': 55}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140]

Trial calls: [67, 101, 35, 125, 39, 68]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 148.00 sec, Standard Deviation: 56.16 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 72.50 calls, Standard Deviation: 32.01 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140]

Trial calls: [67, 101, 35, 125, 39, 68]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 148.00 sec, Standard Deviation: 56.16 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 72.50 calls, Standard Deviation: 32.01 calls

Trial  7
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {

  |
7 | function evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(7,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {

  |
8 |   match e {
  |            ^

ex.dfy(8,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val,

  |
9 |     case Const(val) => val,
  |                           ^

ex.dfy(9,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val,
    case Var(name) => env(name),

  |
9 |     case Const(val) => val,
  |                           ^

ex.dfy(9,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val,
    case Var(name) => env(name),
    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env),

  |
9 |     case Const(val) => val,
  |                           ^

ex.dfy(9,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => evaluate(e1, env) + evaluate(e2, env),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
7 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(7,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {

  |
8 |     match e {
  |              ^

ex.dfy(8,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val

  |
9 |         case Const(val) => val
  |                               ^

ex.dfy(9,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)

   |
10 |         case Var(name) => env(name)
   |                                    ^

ex.dfy(10,35): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
11 |         case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                          ^

ex.dfy(11,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }

   |
12 |     }
   |      ^

ex.dfy(12,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
16 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(16,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {

   |
17 |     match e {
   |              ^

ex.dfy(17,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)

   |
18 |         case Add(Const(0), e2) => optimize(e2)
   |                                               ^

ex.dfy(18,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)

   |
19 |         case Add(e1, Const(0)) => optimize(e1)
   |                                               ^

ex.dfy(19,46): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
20 |         case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                            ^

ex.dfy(20,59): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e

   |
21 |         case _ => e
   |                    ^

ex.dfy(21,19): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }

   |
22 |     }
   |      ^

ex.dfy(22,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics

SCORE
1.0
['// Lemma to prove that the optimizer preserves the semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['    ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{

   |
28 | {
   |  ^

ex.dfy(28,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {

   |
29 |     match e {
   |              ^

ex.dfy(29,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>

   |
30 |         case Const(_) =>
   |                         ^

ex.dfy(30,24): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>

   |
31 |         case Var(_) =>
   |                       ^

ex.dfy(31,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>

   |
32 |         case Add(e1, e2) =>
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['        case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizerSemantics(e1, env);

   |
33 |             OptimizerSemantics(e1, env);
   |                                         ^

ex.dfy(33,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);

   |
34 |             OptimizerSemantics(e2, env);
   |                                         ^

ex.dfy(34,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['            OptimizerSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
    }

   |
35 |     }
   |      ^

ex.dfy(35,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
    }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
    }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
    match e {
        case Const(val) => val
        case Var(name) => env(name)
        case Add(e1, e2) => eval(e1, env) + eval(e2, env)
    }
}

// Optimizer
function optimize(e: Expr): Expr {
    match e {
        case Add(Const(0), e2) => optimize(e2)
        case Add(e1, Const(0)) => optimize(e1)
        case Add(e1, e2) => Add(optimize(e1), optimize(e2))
        case _ => e
    }
}

// Lemma to prove that the optimizer preserves the semantics
lemma OptimizerSemantics(e: Expr, env: string -> int)
    ensures eval(optimize(e), env) == eval(e, env)
{
    match e {
        case Const(_) =>
        case Var(_) =>
        case Add(e1, e2) =>
            OptimizerSemantics(e1, env);
            OptimizerSemantics(e2, env);
    }
}
```


STATS

number of nodes: 33
number of gen nodes: 17 (including leaves: 1)
number of back nodes: 16 (including leaves: 16)

expansion count: 17 (including failed: 1)

cache stats {'hit': 0, 'miss': 42}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99]

Trial calls: [67, 101, 35, 125, 39, 68, 42]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 141.00 sec, Standard Deviation: 54.75 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 68.14 calls, Standard Deviation: 31.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99]

Trial calls: [67, 101, 35, 125, 39, 68, 42]


Time Statistics:

  Min: 84.00 sec, Max: 226.00 sec, Average: 141.00 sec, Standard Deviation: 54.75 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 68.14 calls, Standard Deviation: 31.50 calls

Trial  8
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.

SCORE
1.0
['// The abstract syntax tree for arithmetic expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 

  |
2 | datatype Expr =
  |                ^

ex.dfy(2,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 

SCORE
1.0
['  | Const(val: int) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 

SCORE
1.0
['  | Var(name: string) \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.

SCORE
1.0
['// The evaluator for arithmetic expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {

  |
8 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(8,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {

  |
9 |   match e {
  |            ^

ex.dfy(9,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val,

   |
10 |     case Const(val) => val,
   |                           ^

ex.dfy(10,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val,\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val,
    case Var(name) => env(name),

   |
10 |     case Const(val) => val,
   |                           ^

ex.dfy(10,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val,
    case Var(name) => env(name),
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
10 |     case Const(val) => val,
   |                           ^

ex.dfy(10,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
['function eval(e: Expr, env: string -> int): int {\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val

   |
10 |     case Const(val) => val
   |                           ^

ex.dfy(10,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)

   |
11 |     case Var(name) => env(name)
   |                                ^

ex.dfy(11,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

   |
12 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
   |                                                      ^

ex.dfy(12,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }

   |
13 |   }
   |    ^

ex.dfy(13,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.

SCORE
1.0
['// The optimizer for arithmetic expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {

   |
17 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(17,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {

   |
18 |   match e {
   |            ^

ex.dfy(18,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
19 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(19,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
20 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(20,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
21 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(21,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
22 |     case _ => e
   |                ^

ex.dfy(22,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
23 |   }
   |    ^

ex.dfy(23,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.

SCORE
1.0
['// Lemma: The optimizer preserves the semantics of the evaluator.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
30 |   match e {
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants have no subexpressions.

   |
31 |     case Const(_) => () // Base case: Constants have no subexpressions.
   |                                                                        ^

ex.dfy(31,71): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => () // Base case: Constants have no subexpressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants have no subexpressions.
    case Var(_) => () // Base case: Variables have no subexpressions.

   |
32 |     case Var(_) => () // Base case: Variables have no subexpressions.
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => () // Base case: Constants have no subexpressions.
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
32 |     case Var(_) => () // Base case: Variables have no subexpressions.
   |                                                                      ^

ex.dfy(32,69): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => () // Base case: Variables have no subexpressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants have no subexpressions.
    case Var(_) => () // Base case: Variables have no subexpressions.
    case Add(e1, e2) =>

   |
32 |     case Var(_) => () // Base case: Variables have no subexpressions.
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => () // Base case: Constants have no subexpressions.
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |     ^

ex.dfy(33,4): Error: invalid Suffix
   |
32 |     case Var(_) => () // Base case: Variables have no subexpressions.
   |                    ^

ex.dfy(32,19): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(33,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: Constants have no subexpressions.
    case Var(_) => () // Base case: Variables have no subexpressions.
    case Add(e1, e2) =>
      // Recursive case: Use the induction hypothesis.

   |
32 |     case Var(_) => () // Base case: Variables have no subexpressions.
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => () // Base case: Constants have no subexpressions.
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |     ^

ex.dfy(33,4): Error: invalid Suffix
   |
32 |     case Var(_) => () // Base case: Variables have no subexpressions.
   |                    ^

ex.dfy(32,19): Error: missing semicolon at end of statement
   |
34 |       // Recursive case: Use the induction hypothesis.
   |                                                       ^

ex.dfy(34,54): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      // Recursive case: Use the induction hypothesis.\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()

   |
31 |     case Const(_) => ()
   |                        ^

ex.dfy(31,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
32 |     case Var(_) => ()
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => ()
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
32 |     case Var(_) => ()
   |                      ^

ex.dfy(32,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
32 |     case Var(_) => ()
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => ()
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |     ^

ex.dfy(33,4): Error: invalid Suffix
   |
32 |     case Var(_) => ()
   |                    ^

ex.dfy(32,19): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(33,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
32 |     case Var(_) => ()
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => ()
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |     ^

ex.dfy(33,4): Error: invalid Suffix
   |
32 |     case Var(_) => ()
   |                    ^

ex.dfy(32,19): Error: missing semicolon at end of statement
   |
34 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e1, env);\n']
['  ensures eval(optimize(e), env) == eval(e, env)\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 

   |
31 |     case Const(_) =>
   |                     ^

ex.dfy(31,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 

   |
32 |     case Var(_) =>
   |                   ^

ex.dfy(32,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>

   |
33 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(33,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).

   |
34 |       // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
   |                                                                       ^

ex.dfy(34,70): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);

   |
35 |       assert e == Add(e1, e2);
   |                               ^

ex.dfy(35,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert e == Add(e1, e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

   |
36 |       assert optimize(e) == Add(optimize(e1), optimize(e2));
   |                                                             ^

ex.dfy(36,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert optimize(e) == Add(optimize(e1), optimize(e2));\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));


   |
36 |       assert optimize(e) == Add(optimize(e1), optimize(e2));
   |                                                             ^

ex.dfy(36,60): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.

   |
38 |       // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
   |                                                                                   ^

ex.dfy(38,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);

   |
39 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(39,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
40 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(40,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);


   |
40 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(40,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 

   |
42 |       // By the induction hypothesis,
   |                                      ^

ex.dfy(42,37): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By the induction hypothesis, \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 
      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).

   |
43 |       // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).
   |                                                                                                ^

ex.dfy(43,95): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 
      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).
      // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)

   |
44 |       // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)
   |                                                                                         ^

ex.dfy(44,88): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 
      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).
      // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)
      //                                  == eval(Add(e1, e2), env)

   |
45 |       //                                  == eval(Add(e1, e2), env)
   |                                                                    ^

ex.dfy(45,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      //                                  == eval(Add(e1, e2), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 
      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).
      // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)
      //                                  == eval(Add(e1, e2), env)
      //                                  == eval(e, env)

   |
46 |       //                                  == eval(e, env)
   |                                                          ^

ex.dfy(46,57): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      //                                  == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 
      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).
      // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)
      //                                  == eval(Add(e1, e2), env)
      //                                  == eval(e, env)
  }

   |
47 |   }
   |    ^

ex.dfy(47,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      // The base case: optimize(e) = Add(optimize(e1), optimize(e2)).
      assert e == Add(e1, e2);
      assert optimize(e) == Add(optimize(e1), optimize(e2));

      // The inductive case: optimize(e1) and optimize(e2) have no additions by 0.
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

      // By the induction hypothesis, 
      // eval(optimize(e1), env) == eval(e1, env) and eval(optimize(e2), env) == eval(e2, env).
      // Therefore, eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env)
      //                                  == eval(Add(e1, e2), env)
      //                                  == eval(e, env)
  }
}

ex.dfy(36,13): Error: assertion might not hold
   |
36 |       assert optimize(e) == Add(optimize(e1), optimize(e2));
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 2 verified, 1 error

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerSemantics(e: Expr, env: string -> int) {

   |
27 | lemma OptimizerSemantics(e: Expr, env: string -> int) {
   |                                                        ^

ex.dfy(27,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['lemma OptimizerSemantics(e: Expr, env: string -> int) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)

   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)
}

   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)
}


   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics of the evaluator.
lemma OptimizerSemantics(e: Expr, env: string -> int) {
  eval(optimize(e), env) == eval(e, env)
}

// Proof of the lemma.

   |
28 |   eval(optimize(e), env) == eval(e, env)
   |                          ^

ex.dfy(28,25): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['// Proof of the lemma.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.

SCORE
1.0
['// Lemma: The optimizer preserves the semantics as defined by the evaluation function.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
29 | {
   |  ^

ex.dfy(29,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
30 |   match e {
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions to optimize.

   |
31 |     case Const(_) => () // Base case: constants have no sub-expressions to optimize.
   |                                                                                     ^

ex.dfy(31,84): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => () // Base case: constants have no sub-expressions to optimize.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions to optimize.
    case Var(_) => () // Base case: variables have no sub-expressions to optimize.

   |
32 |     case Var(_) => () // Base case: variables have no sub-expressions to optimize.
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => () // Base case: constants have no sub-expressions to optimize.
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
32 |     case Var(_) => () // Base case: variables have no sub-expressions to optimize.
   |                                                                                   ^

ex.dfy(32,82): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => () // Base case: variables have no sub-expressions to optimize.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions to optimize.
    case Var(_) => () // Base case: variables have no sub-expressions to optimize.
    case Add(e1, e2) =>

   |
32 |     case Var(_) => () // Base case: variables have no sub-expressions to optimize.
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => () // Base case: constants have no sub-expressions to optimize.
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |     ^

ex.dfy(33,4): Error: invalid Suffix
   |
32 |     case Var(_) => () // Base case: variables have no sub-expressions to optimize.
   |                    ^

ex.dfy(32,19): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(33,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => () // Base case: constants have no sub-expressions to optimize.
    case Var(_) => () // Base case: variables have no sub-expressions to optimize.
    case Add(e1, e2) =>
      // Recursive case: optimize the sub-expressions and then show that the optimized

   |
32 |     case Var(_) => () // Base case: variables have no sub-expressions to optimize.
   |     ^

ex.dfy(32,4): Error: invalid Suffix
   |
31 |     case Const(_) => () // Base case: constants have no sub-expressions to optimize.
   |                      ^

ex.dfy(31,21): Error: missing semicolon at end of statement
   |
33 |     case Add(e1, e2) =>
   |     ^

ex.dfy(33,4): Error: invalid Suffix
   |
32 |     case Var(_) => () // Base case: variables have no sub-expressions to optimize.
   |                    ^

ex.dfy(32,19): Error: missing semicolon at end of statement
   |
34 |       // Recursive case: optimize the sub-expressions and then show that the optimized
   |                                                                                       ^

ex.dfy(34,86): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      // Recursive case: optimize the sub-expressions and then show that the optimized\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>

   |
31 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(31,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;

   |
32 |       assert optimize(e) == e2;
   |                                ^

ex.dfy(32,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert optimize(e) == e2;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);

   |
33 |       assert eval(optimize(e), env) == eval(e2, env);
   |                                                      ^

ex.dfy(33,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);

   |
34 |       assert eval(e, env) == eval(Add(Const(0), e2), env);
   |                                                           ^

ex.dfy(34,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(Const(0), e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);

   |
35 |       assert eval(optimize(e), env) == eval(e, env);
   |                                                     ^

ex.dfy(35,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 

   |
36 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(36,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;

   |
37 |       assert optimize(e) == e1;
   |                                ^

ex.dfy(37,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert optimize(e) == e1;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);

   |
38 |       assert eval(optimize(e), env) == eval(e1, env);
   |                                                      ^

ex.dfy(38,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);

   |
39 |       assert eval(e, env) == eval(Add(e1, Const(0)), env);
   |                                                           ^

ex.dfy(39,58): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(e1, Const(0)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);

   |
40 |       assert eval(optimize(e), env) == eval(e, env);
   |                                                     ^

ex.dfy(40,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 

   |
41 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(41,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);

   |
42 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(42,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
43 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(43,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);

   |
44 |       assert eval(optimize(e1), env) == eval(e1, env);
   |                                                       ^

ex.dfy(44,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e1), env) == eval(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);

   |
45 |       assert eval(optimize(e2), env) == eval(e2, env);
   |                                                       ^

ex.dfy(45,54): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e2), env) == eval(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);

   |
46 |       assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
   |                                                                                   ^

ex.dfy(46,82): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);

   |
47 |       assert eval(e, env) == eval(Add(e1, e2), env);
   |                                                     ^

ex.dfy(47,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(e, env) == eval(Add(e1, e2), env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(optimize(e), env) == eval(e, env);

   |
48 |       assert eval(optimize(e), env) == eval(e, env);
   |                                                     ^

ex.dfy(48,52): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      assert eval(optimize(e), env) == eval(e, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case _ =>

   |
49 |     case _ =>
   |              ^

ex.dfy(49,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case _ =>
  }

   |
50 |   }
   |    ^

ex.dfy(50,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Add(Const(0), e2) =>
      assert optimize(e) == e2;
      assert eval(optimize(e), env) == eval(e2, env);
      assert eval(e, env) == eval(Add(Const(0), e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, Const(0)) => 
      assert optimize(e) == e1;
      assert eval(optimize(e), env) == eval(e1, env);
      assert eval(e, env) == eval(Add(e1, Const(0)), env);
      assert eval(optimize(e), env) == eval(e, env);
    case Add(e1, e2) => 
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
      assert eval(optimize(e1), env) == eval(e1, env);
      assert eval(optimize(e2), env) == eval(e2, env);
      assert eval(optimize(e), env) == eval(Add(optimize(e1), optimize(e2)), env);
      assert eval(e, env) == eval(Add(e1, e2), env);
      assert eval(optimize(e), env) == eval(e, env);
    case _ =>
  }
}

ex.dfy(31,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(4789,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['  ensures eval(optimize(e), env) == eval(e, env)\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 

   |
31 |     case Const(_) =>
   |                     ^

ex.dfy(31,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 

   |
32 |     case Var(_) =>
   |                   ^

ex.dfy(32,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>

   |
33 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(33,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
34 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(34,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
35 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(35,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }

   |
36 |   }
   |    ^

ex.dfy(36,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// The abstract syntax tree for arithmetic expressions.
datatype Expr = 
  | Const(val: int) 
  | Var(name: string) 
  | Add(e1: Expr, e2: Expr)

// The evaluator for arithmetic expressions.
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// The optimizer for arithmetic expressions.
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma: The optimizer preserves the semantics as defined by the evaluation function.
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => 
    case Var(_) => 
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 43
number of gen nodes: 22 (including leaves: 4)
number of back nodes: 21 (including leaves: 18)

expansion count: 29 (including failed: 8)

cache stats {'hit': 18, 'miss': 102}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99, 264]

Trial calls: [67, 101, 35, 125, 39, 68, 42, 120]


Time Statistics:

  Min: 84.00 sec, Max: 264.00 sec, Average: 156.38 sec, Standard Deviation: 65.40 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 74.62 calls, Standard Deviation: 34.09 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99, 264]

Trial calls: [67, 101, 35, 125, 39, 68, 42, 120]


Time Statistics:

  Min: 84.00 sec, Max: 264.00 sec, Average: 156.38 sec, Standard Deviation: 65.40 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 74.62 calls, Standard Deviation: 34.09 calls

Trial  9
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions

SCORE
1.0
['// ADT for arithmetic expressions\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator

SCORE
1.0
['// Evaluator\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {

  |
5 | function eval(e: Expr, env: string -> int): int {
  |                                                  ^

ex.dfy(5,49): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function eval(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v

  |
7 |     case Const(v) => v
  |                       ^

ex.dfy(7,22): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(v) => v\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)

  |
8 |     case Var(n) => env(n)
  |                          ^

ex.dfy(8,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(n) => env(n)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)

  |
9 |     case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  |                                                      ^

ex.dfy(9,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => eval(e1, env) + eval(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer

SCORE
1.0
['// Optimizer\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics

SCORE
1.0
['// Lemma that the optimizer preserves the semantics\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)

SCORE
1.0
['  ensures eval(optimize(e), env) == eval(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()

   |
28 |     case Const(_) => ()
   |                        ^

ex.dfy(28,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
29 |     case Var(_) => ()
   |     ^

ex.dfy(29,4): Error: invalid Suffix
   |
28 |     case Const(_) => ()
   |                      ^

ex.dfy(28,21): Error: missing semicolon at end of statement
   |
29 |     case Var(_) => ()
   |                      ^

ex.dfy(29,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
29 |     case Var(_) => ()
   |     ^

ex.dfy(29,4): Error: invalid Suffix
   |
28 |     case Const(_) => ()
   |                      ^

ex.dfy(28,21): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |     ^

ex.dfy(30,4): Error: invalid Suffix
   |
29 |     case Var(_) => ()
   |                    ^

ex.dfy(29,19): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
29 |     case Var(_) => ()
   |     ^

ex.dfy(29,4): Error: invalid Suffix
   |
28 |     case Const(_) => ()
   |                      ^

ex.dfy(28,21): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |     ^

ex.dfy(30,4): Error: invalid Suffix
   |
29 |     case Var(_) => ()
   |                    ^

ex.dfy(29,19): Error: missing semicolon at end of statement
   |
31 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(31,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>

   |
28 |     case Const(_) =>
   |                     ^

ex.dfy(28,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>

   |
29 |     case Var(_) =>
   |                   ^

ex.dfy(29,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
31 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(31,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
32 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(32,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
// ADT for arithmetic expressions
datatype Expr = Const(v: int) | Var(n: string) | Add(e1: Expr, e2: Expr)

// Evaluator
function eval(e: Expr, env: string -> int): int {
  match e {
    case Const(v) => v
    case Var(n) => env(n)
    case Add(e1, e2) => eval(e1, env) + eval(e2, env)
  }
}

// Optimizer
function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

// Lemma that the optimizer preserves the semantics
lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures eval(optimize(e), env) == eval(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 29
number of gen nodes: 15 (including leaves: 1)
number of back nodes: 14 (including leaves: 14)

expansion count: 15 (including failed: 1)

cache stats {'hit': 2, 'miss': 39}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99, 264, 94]

Trial calls: [67, 101, 35, 125, 39, 68, 42, 120, 41]


Time Statistics:

  Min: 84.00 sec, Max: 264.00 sec, Average: 149.44 sec, Standard Deviation: 64.70 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 70.89 calls, Standard Deviation: 33.83 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99, 264, 94]

Trial calls: [67, 101, 35, 125, 39, 68, 42, 120, 41]


Time Statistics:

  Min: 84.00 sec, Max: 264.00 sec, Average: 149.44 sec, Standard Deviation: 64.70 sec

Call Statistics:

  Min: 35 calls, Max: 125 calls, Average: 70.89 calls, Standard Deviation: 33.83 calls

Trial  10
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)

SCORE
1.0
['datatype Expr = Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)

SCORE
1.0
['              | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {

  |
5 | function Evaluate(e: Expr, env: string -> int): int {
  |                                                      ^

ex.dfy(5,53): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Evaluate(e: Expr, env: string -> int): int {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val

  |
7 |     case Const(val) => val
  |                           ^

ex.dfy(7,26): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(val) => val\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)

  |
8 |     case Var(name) => env(name)
  |                                ^

ex.dfy(8,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(name) => env(name)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)

  |
9 |     case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  |                                                              ^

ex.dfy(9,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }

   |
10 |   }
   |    ^

ex.dfy(10,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {

   |
13 | function Optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function Optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {

   |
14 |   match e {
   |            ^

ex.dfy(14,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2

   |
15 |     case Add(Const(0), e2) => e2
   |                                 ^

ex.dfy(15,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1

   |
16 |     case Add(e1, Const(0)) => e1
   |                                 ^

ex.dfy(16,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))

   |
17 |     case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
   |                                                        ^

ex.dfy(17,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e

   |
18 |     case _ => e
   |                ^

ex.dfy(18,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }

   |
19 |   }
   |    ^

ex.dfy(19,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesEvaluation(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesEvaluation(e1, env);
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesEvaluation(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesEvaluation(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      if e1 == Const(0) {

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       if e1 == Const(0) {
   |                          ^

ex.dfy(29,25): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      if e1 == Const(0) {\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['\n']
['lemma OptimizePreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)

SCORE
1.0
['  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizePreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(e, env) == Evaluate(Optimize(e), env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizePreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizePreservesSemantics(e1, env);
   |                                           ^

ex.dfy(29,42): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesSemantics(e1, env);\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesEvaluation(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizePreservesEvaluation(e1, env);\n']
['\n']
['function Optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => e2\n']
['    case Add(e1, Const(0)) => e1\n']
['    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)

SCORE
1.0
['lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)

SCORE
1.0
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {

   |
25 |   match e {
   |            ^

ex.dfy(25,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()

   |
26 |     case Const(_) => ()
   |                        ^

ex.dfy(26,23): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
27 |     case Var(_) => ()
   |                      ^

ex.dfy(27,21): Error: invalid Suffix
3 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) => ()
    case Var(_) => ()
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
27 |     case Var(_) => ()
   |     ^

ex.dfy(27,4): Error: invalid Suffix
   |
26 |     case Const(_) => ()
   |                      ^

ex.dfy(26,21): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, e2) =>
   |     ^

ex.dfy(28,4): Error: invalid Suffix
   |
27 |     case Var(_) => ()
   |                    ^

ex.dfy(27,19): Error: missing semicolon at end of statement
   |
29 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
5 parse errors detected in ex.dfy

SCORE
-1.0
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizerPreservesSemantics(e1, env);\n']
['  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)\n']
['{\n']
['  match e {\n']
['    case Const(_) => ()\n']
['    case Var(_) => ()\n']
['    case Add(e1, e2) =>\n']
['      OptimizerPreservesSemantics(e1, env);\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>

   |
26 |     case Const(_) =>
   |                     ^

ex.dfy(26,20): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Const(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>

   |
27 |     case Var(_) =>
   |                   ^

ex.dfy(27,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Var(_) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>

   |
28 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(28,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);

   |
29 |       OptimizerPreservesSemantics(e1, env);
   |                                            ^

ex.dfy(29,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e1, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);

   |
30 |       OptimizerPreservesSemantics(e2, env);
   |                                            ^

ex.dfy(30,43): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerPreservesSemantics(e2, env);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```

SCORE
1.0
['```\n']
CHOSEN SOLUTION
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.



```dafny
datatype Expr = Const(val: int)
              | Var(name: string)
              | Add(e1: Expr, e2: Expr)

function Evaluate(e: Expr, env: string -> int): int {
  match e {
    case Const(val) => val
    case Var(name) => env(name)
    case Add(e1, e2) => Evaluate(e1, env) + Evaluate(e2, env)
  }
}

function Optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => e2
    case Add(e1, Const(0)) => e1
    case Add(e1, e2) => Add(Optimize(e1), Optimize(e2))
    case _ => e
  }
}

lemma OptimizerPreservesSemantics(e: Expr, env: string -> int)
  ensures Evaluate(Optimize(e), env) == Evaluate(e, env)
{
  match e {
    case Const(_) =>
    case Var(_) =>
    case Add(e1, e2) =>
      OptimizerPreservesSemantics(e1, env);
      OptimizerPreservesSemantics(e2, env);
  }
}
```


STATS

number of nodes: 53
number of gen nodes: 27 (including leaves: 8)
number of back nodes: 26 (including leaves: 19)

expansion count: 42 (including failed: 16)

cache stats {'hit': 89, 'miss': 61}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99, 264, 94, 238]

Trial calls: [67, 101, 35, 125, 39, 68, 42, 120, 41, 150]


Time Statistics:

  Min: 84.00 sec, Max: 264.00 sec, Average: 158.30 sec, Standard Deviation: 66.88 sec

Call Statistics:

  Min: 35 calls, Max: 150 calls, Average: 78.80 calls, Standard Deviation: 39.92 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [134, 226, 84, 217, 87, 140, 99, 264, 94, 238]

Trial calls: [67, 101, 35, 125, 39, 68, 42, 120, 41, 150]


Time Statistics:

  Min: 84.00 sec, Max: 264.00 sec, Average: 158.30 sec, Standard Deviation: 66.88 sec

Call Statistics:

  Min: 35 calls, Max: 150 calls, Average: 78.80 calls, Standard Deviation: 39.92 calls

To complete all experiments, 27 minutes and 0 seconds elapsed.


