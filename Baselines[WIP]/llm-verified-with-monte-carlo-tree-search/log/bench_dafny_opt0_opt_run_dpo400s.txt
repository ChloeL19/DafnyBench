

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Dafny --problem_name problem_opt0_opt --seed 42 --base_model_name ./my_dpo_model 


[2024-01-12 15:50:13,681] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)

SCORE
1.0
['  | Const(i: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)

SCORE
1.0
['  | Var(s: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(30,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(30,46): Error: missing semicolon at end of statement
   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(30,46): Error: missing semicolon at end of statement
   |
32 |   }
   |    ^

ex.dfy(32,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ => \n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ => \n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => 

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(30,46): Error: missing semicolon at end of statement
   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => 
  }

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(30,46): Error: missing semicolon at end of statement
   |
32 |   }
   |    ^

ex.dfy(32,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
['    case _ =>\n']
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |                                                                    ^

ex.dfy(30,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
    case _ =>

   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
    case _ =>
  }

   |
32 |   }
   |    ^

ex.dfy(32,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ => \n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
8 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
9 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(9,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
11 |   case _ => true
   |                 ^

ex.dfy(11,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
26 |   match e {
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(i: int)
  | Var(s: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 107
number of gen nodes: 54 (including leaves: 18)
number of back nodes: 53 (including leaves: 36)

expansion count: 92 (including failed: 39)

cache stats {'hit': 301, 'miss': 102}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615]

Trial calls: [403]


Time Statistics:

  Min: 615.00 sec, Max: 615.00 sec, Average: 615.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 403 calls, Max: 403 calls, Average: 403.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615]

Trial calls: [403]


Time Statistics:

  Min: 615.00 sec, Max: 615.00 sec, Average: 615.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 403 calls, Max: 403 calls, Average: 403.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)

SCORE
1.0
['datatype Expr = Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)

SCORE
1.0
['              | Var(x: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

SCORE
1.0
['              | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
5 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(5,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
6 |   match e {
  |            ^

ex.dfy(6,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
7 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(7,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
8 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
9 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(9,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
10 |     case _ => true
   |                   ^

ex.dfy(10,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
11 |   }
   |    ^

ex.dfy(11,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
26 |   match e {
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);

   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |                                                                    ^

ex.dfy(29,67): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2);
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(27,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
27 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts

   |
28 |       // Here we use the lemma recursively without adding asserts
   |                                                                  ^

ex.dfy(28,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here we use the lemma recursively without adding asserts\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }

   |
30 |     }
   |      ^

ex.dfy(30,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
31 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(31,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts

   |
32 |       // Here we use the lemma recursively without adding asserts
   |                                                                  ^

ex.dfy(32,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here we use the lemma recursively without adding asserts\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);

   |
33 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
35 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(35,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts

   |
36 |       // Here we use the lemma recursively without adding asserts
   |                                                                  ^

ex.dfy(36,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here we use the lemma recursively without adding asserts\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);

   |
37 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(37,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
38 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(38,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
39 |     }
   |      ^

ex.dfy(39,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}

   |
40 |     case _ => {}
   |                 ^

ex.dfy(40,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }

   |
41 |   }
   |    ^

ex.dfy(41,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively without adding asserts
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }
}

ex.dfy(27,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,29): Related location
  |
7 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).

   |
28 |       // The optimization rule for "0 + e2" is applied, so we optimize(e2).
   |                                                                            ^

ex.dfy(28,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The optimization rule for "0 + e2" is applied, so we optimize(e2).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }

   |
30 |     }
   |      ^

ex.dfy(30,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
31 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(31,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).

   |
32 |       // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
   |                                                                            ^

ex.dfy(32,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);

   |
33 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
35 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(35,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.

   |
36 |       // Both sub-expressions are optimized.
   |                                             ^

ex.dfy(36,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Both sub-expressions are optimized.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.
      OptimizerOptimal(e1);

   |
37 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(37,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
38 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(38,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
39 |     }
   |      ^

ex.dfy(39,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}

   |
40 |     case _ => {}
   |                 ^

ex.dfy(40,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }

   |
41 |   }
   |    ^

ex.dfy(41,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // The optimization rule for "0 + e2" is applied, so we optimize(e2).
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // The optimization rule for "e1 + 0" is applied, so we optimize(e1).
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Both sub-expressions are optimized.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }
}

ex.dfy(27,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(29,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(29,46): Error: missing semicolon at end of statement
   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
29 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(29,46): Error: missing semicolon at end of statement
   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(27,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ => ()
   |                 ^

ex.dfy(28,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
29 |   }
   |   ^

ex.dfy(29,2): Error: invalid Suffix
   |
28 |     case _ => ()
   |               ^

ex.dfy(28,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
6 |   match e
  |          ^

ex.dfy(6,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
7 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(7,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
8 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
9 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                 ^

ex.dfy(9,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
10 |   case _ => true
   |                 ^

ex.dfy(10,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
13 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(13,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
14 |   match e
   |          ^

ex.dfy(14,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
15 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(15,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
16 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
17 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(17,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
18 |   case _ => e
   |              ^

ex.dfy(18,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
24 |   match e
   |          ^

ex.dfy(24,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
25 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(25,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
26 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
27 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
28 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
29 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
30 |   case _ =>
   |            ^

ex.dfy(30,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,2): Error: a postcondition could not be proved on this return path
   |
27 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
25 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(25,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
26 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(26,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
27 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
28 |   case _ =>
   |            ^

ex.dfy(28,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  {}

   |
29 |   {}
   |     ^

ex.dfy(29,4): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  {}
}

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(7,27): Related location
  |
7 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                 ^

ex.dfy(25,48): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(25,28): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                 ^

ex.dfy(26,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) => 

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(25,28): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) => \n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int)
              | Var(x: string)
              | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) =>

   |
25 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(25,28): Error: missing semicolon at end of statement
   |
26 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(27,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) =>\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['  case Add(e1, e2) =>\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 93
number of gen nodes: 47 (including leaves: 17)
number of back nodes: 46 (including leaves: 30)

expansion count: 84 (including failed: 38)

cache stats {'hit': 288, 'miss': 121}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606]

Trial calls: [403, 409]


Time Statistics:

  Min: 606.00 sec, Max: 615.00 sec, Average: 610.50 sec, Standard Deviation: 4.50 sec

Call Statistics:

  Min: 403 calls, Max: 409 calls, Average: 406.00 calls, Standard Deviation: 3.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606]

Trial calls: [403, 409]


Time Statistics:

  Min: 606.00 sec, Max: 615.00 sec, Average: 610.50 sec, Standard Deviation: 4.50 sec

Call Statistics:

  Min: 403 calls, Max: 409 calls, Average: 406.00 calls, Standard Deviation: 3.00 calls

Trial  3
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
5 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(5,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
6 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(6,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(7,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

  |
8 |     case _ => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

  |
9 |   }
  |    ^

ex.dfy(9,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
12 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
13 |   match e {
   |            ^

ex.dfy(13,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
14 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
15 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
16 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(16,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
17 |     case _ => e
   |                ^

ex.dfy(17,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
18 |   }
   |    ^

ex.dfy(18,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
24 |   match e {
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
25 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
26 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(26,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
25 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(25,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
26 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(25,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ =>
   |              ^

ex.dfy(26,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
27 |   }
   |    ^

ex.dfy(27,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(26,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
['    case _ =>\n']
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
25 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(25,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.

   |
26 |       // Base case: Add(0, e) is not optimal.
   |                                              ^

ex.dfy(26,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: Add(0, e) is not optimal.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.

   |
27 |       // The optimized expression is just e.
   |                                             ^

ex.dfy(27,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The optimized expression is just e.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }

   |
28 |     }
   |      ^

ex.dfy(28,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {

   |
29 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(29,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.

   |
30 |       // Base case: Add(e, 0) is not optimal.
   |                                              ^

ex.dfy(30,45): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: Add(e, 0) is not optimal.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.

   |
31 |       // The optimized expression is just e.
   |                                             ^

ex.dfy(31,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // The optimized expression is just e.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {

   |
33 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.

   |
34 |       // Recursive case: The expression is addition of two sub-expressions.
   |                                                                            ^

ex.dfy(34,75): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursive case: The expression is addition of two sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.

   |
35 |       // Recursively prove the lemma for the sub-expressions.
   |                                                              ^

ex.dfy(35,61): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursively prove the lemma for the sub-expressions.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);

   |
36 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(36,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
37 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(37,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
38 |     }
   |      ^

ex.dfy(38,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {

   |
39 |     case _ => {
   |                ^

ex.dfy(39,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // Other cases: The expression is a constant or a variable.

   |
40 |       // Other cases: The expression is a constant or a variable.
   |                                                                  ^

ex.dfy(40,65): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Other cases: The expression is a constant or a variable.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // Other cases: The expression is a constant or a variable.
      // It is already optimized and trivially optimal.

   |
41 |       // It is already optimized and trivially optimal.
   |                                                        ^

ex.dfy(41,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // It is already optimized and trivially optimal.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // Other cases: The expression is a constant or a variable.
      // It is already optimized and trivially optimal.
    }

   |
42 |     }
   |      ^

ex.dfy(42,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // Other cases: The expression is a constant or a variable.
      // It is already optimized and trivially optimal.
    }
  }

   |
43 |   }
   |    ^

ex.dfy(43,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: Add(0, e) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, Const(0)) => {
      // Base case: Add(e, 0) is not optimal.
      // The optimized expression is just e.
    }
    case Add(e1, e2) => {
      // Recursive case: The expression is addition of two sub-expressions.
      // Recursively prove the lemma for the sub-expressions.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {
      // Other cases: The expression is a constant or a variable.
      // It is already optimized and trivially optimal.
    }
  }
}

ex.dfy(25,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ => ()
   |                 ^

ex.dfy(26,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
27 |   }
   |   ^

ex.dfy(27,2): Error: invalid Suffix
   |
26 |     case _ => ()
   |               ^

ex.dfy(26,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
['    case _ => ()\n']
['  }\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)

   |
26 |       // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
   |                                                               ^

ex.dfy(26,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }

   |
28 |     }
   |      ^

ex.dfy(28,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
29 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(29,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)

   |
30 |       // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
   |                                                               ^

ex.dfy(30,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
33 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
34 |       // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                                 ^

ex.dfy(34,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);

   |
35 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
36 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(36,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
37 |     }
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
38 |     case _ => ()
   |                 ^

ex.dfy(38,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => ()
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => ()
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Recursive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` #include <stdio.h>

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => ()
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['``` #include <stdio.h>\n']
['\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
4 |   match e
  |          ^

ex.dfy(4,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
5 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(5,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
6 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(6,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                 ^

ex.dfy(7,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

  |
8 |   case _ => true
  |                 ^

ex.dfy(8,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
11 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
12 |   match e
   |          ^

ex.dfy(12,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
13 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(13,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
14 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(14,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
15 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(15,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
16 |   case _ => e
   |              ^

ex.dfy(16,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(v: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 97
number of gen nodes: 49 (including leaves: 18)
number of back nodes: 48 (including leaves: 31)

expansion count: 86 (including failed: 38)

cache stats {'hit': 332, 'miss': 97}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601]

Trial calls: [403, 409, 429]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.33 sec, Standard Deviation: 5.79 sec

Call Statistics:

  Min: 403 calls, Max: 429 calls, Average: 413.67 calls, Standard Deviation: 11.12 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601]

Trial calls: [403, 409, 429]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.33 sec, Standard Deviation: 5.79 sec

Call Statistics:

  Min: 403 calls, Max: 429 calls, Average: 413.67 calls, Standard Deviation: 11.12 calls

Trial  4
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)

SCORE
1.0
['  | Const(n: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)

SCORE
1.0
['  | Var(x: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
8 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
9 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(9,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
11 |   case _ => true
   |                 ^

ex.dfy(11,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
16 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
17 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(18,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
19 |   case _ => e
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
25 |   match e
   |          ^

ex.dfy(25,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}

   |
26 |   case Add(Const(0), e2) => {}
   |                               ^

ex.dfy(26,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}

   |
27 |   case Add(e1, Const(0)) => {}
   |                               ^

ex.dfy(27,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => {}

   |
31 |   case _ => {}
   |               ^

ex.dfy(31,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => {}
}

ex.dfy(26,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                 ^

ex.dfy(26,48): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                 ^

ex.dfy(27,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) =>

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(27,28): Error: missing semicolon at end of statement
   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) =>\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
26 |   match e {
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) => 
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
27 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(27,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.

   |
28 |       // In this case, optimize(e) = optimize(e2) because of the match pattern.
   |                                                                                ^

ex.dfy(28,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, optimize(e) = optimize(e2) because of the match pattern.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.

   |
29 |       // So we recursively call the lemma on e2.
   |                                                 ^

ex.dfy(29,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // So we recursively call the lemma on e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);

   |
30 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }

   |
31 |     }
   |      ^

ex.dfy(31,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
32 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(32,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.

   |
33 |       // In this case, optimize(e) = optimize(e1) because of the match pattern.
   |                                                                                ^

ex.dfy(33,79): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, optimize(e) = optimize(e1) because of the match pattern.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.

   |
34 |       // So we recursively call the lemma on e1.
   |                                                 ^

ex.dfy(34,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // So we recursively call the lemma on e1.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);

   |
35 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }

   |
36 |     }
   |      ^

ex.dfy(36,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
37 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(37,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),

   |
38 |       // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
   |                                                                      ^

ex.dfy(38,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.

   |
39 |       // so we recursively call the lemma on e1 and e2.
   |                                                        ^

ex.dfy(39,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // so we recursively call the lemma on e1 and e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.
      OptimizerOptimal(e1);

   |
40 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(40,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
41 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(41,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
42 |     }
   |      ^

ex.dfy(42,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}

   |
43 |     case _ => {}
   |                 ^

ex.dfy(43,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }

   |
44 |   }
   |    ^

ex.dfy(44,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // In this case, optimize(e) = optimize(e2) because of the match pattern.
      // So we recursively call the lemma on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // In this case, optimize(e) = optimize(e1) because of the match pattern.
      // So we recursively call the lemma on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // In this case, optimize(e) = Add(optimize(e1), optimize(e2)),
      // so we recursively call the lemma on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }
}

ex.dfy(27,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(27,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['function optimize(e: Expr): Expr {\n']
['  match e\n']
['  case Add(Const(0), e2) => optimize(e2)\n']
['  case Add(e1, Const(0)) => optimize(e1)\n']
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['  case _ => e\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
27 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
28 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(30,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => 

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(30,46): Error: missing semicolon at end of statement
   |
31 |     case _ =>
   |              ^

ex.dfy(31,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => 
  }

   |
30 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(30,46): Error: missing semicolon at end of statement
   |
32 |   }
   |    ^

ex.dfy(32,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(n: int)
  | Var(x: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 81
number of gen nodes: 41 (including leaves: 14)
number of back nodes: 40 (including leaves: 27)

expansion count: 71 (including failed: 31)

cache stats {'hit': 177, 'miss': 176}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609]

Trial calls: [403, 409, 429, 353]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.75 sec, Standard Deviation: 5.07 sec

Call Statistics:

  Min: 353 calls, Max: 429 calls, Average: 398.50 calls, Standard Deviation: 27.98 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609]

Trial calls: [403, 409, 429, 353]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.75 sec, Standard Deviation: 5.07 sec

Call Statistics:

  Min: 353 calls, Max: 429 calls, Average: 398.50 calls, Standard Deviation: 27.98 calls

Trial  5
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
5 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(5,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
6 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(6,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(7,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

  |
8 |     case _ => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

  |
9 |   }
  |    ^

ex.dfy(9,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
12 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
13 |   match e {
   |            ^

ex.dfy(13,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
14 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
15 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
16 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(16,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
17 |     case _ => e
   |                ^

ex.dfy(17,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
18 |   }
   |    ^

ex.dfy(18,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
24 |   match e {
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
25 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(25,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
26 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(26,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(25,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ =>
   |              ^

ex.dfy(26,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
27 |   }
   |    ^

ex.dfy(27,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
25 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
26 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(26,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(27,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
4 |   match e
  |          ^

ex.dfy(4,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
5 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(5,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
6 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(6,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                 ^

ex.dfy(7,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

  |
8 |   case _ => true
  |                 ^

ex.dfy(8,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
11 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(11,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
12 |   match e
   |          ^

ex.dfy(12,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
13 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(13,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
14 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(14,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
15 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(15,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
16 |   case _ => e
   |              ^

ex.dfy(16,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
21 | {
   |  ^

ex.dfy(21,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
22 |   match e
   |          ^

ex.dfy(22,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
23 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(23,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
24 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(24,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
25 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(25,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
26 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(26,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
27 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
28 |   case _ =>
   |            ^

ex.dfy(28,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(25,2): Error: a postcondition could not be proved on this return path
   |
25 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
23 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(23,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
24 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(24,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
25 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(25,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
26 |   case _ =>
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(23,2): Error: a postcondition could not be proved on this return path
   |
23 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(23,2): Error: a postcondition could not be proved on this return path
   |
23 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(23,2): Error: a postcondition could not be proved on this return path
   |
23 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(23,2): Error: a postcondition could not be proved on this return path
   |
23 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(23,2): Error: a postcondition could not be proved on this return path
   |
23 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(20,10): Related location: this is the postcondition that could not be proved
   |
20 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
23 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                 ^

ex.dfy(23,48): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
23 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(23,28): Error: missing semicolon at end of statement
   |
24 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                 ^

ex.dfy(24,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) =>

   |
23 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(23,28): Error: missing semicolon at end of statement
   |
24 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(24,28): Error: missing semicolon at end of statement
   |
25 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(25,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) =>\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['\n']
['predicate optimal(e: Expr) {\n']
['  match e\n']
['  case Add(Const(0), _) => false\n']
['  case Add(_, Const(0)) => false\n']
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['  case _ => true\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
12 |   match e {
   |            ^

ex.dfy(12,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
13 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(13,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
14 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
15 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(15,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
16 |     case _ => e
   |                ^

ex.dfy(16,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
17 |   }
   |    ^

ex.dfy(17,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
22 | {
   |  ^

ex.dfy(22,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
23 |   match e {
   |            ^

ex.dfy(23,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(24,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
24 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(24,30): Error: missing semicolon at end of statement
   |
25 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
24 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(24,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
25 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
26 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(26,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
27 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
29 |     case _ =>
   |              ^

ex.dfy(29,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
30 |   }
   |    ^

ex.dfy(30,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(i: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,27): Related location
  |
6 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,4): Error: a postcondition could not be proved on this return path
   |
26 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(21,10): Related location: this is the postcondition that could not be proved
   |
21 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,27): Related location
  |
5 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 105
number of gen nodes: 53 (including leaves: 19)
number of back nodes: 52 (including leaves: 34)

expansion count: 93 (including failed: 41)

cache stats {'hit': 307, 'miss': 105}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607]

Trial calls: [403, 409, 429, 353, 412]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.60 sec, Standard Deviation: 4.54 sec

Call Statistics:

  Min: 353 calls, Max: 429 calls, Average: 401.20 calls, Standard Deviation: 25.60 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607]

Trial calls: [403, 409, 429, 353, 412]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.60 sec, Standard Deviation: 4.54 sec

Call Statistics:

  Min: 353 calls, Max: 429 calls, Average: 401.20 calls, Standard Deviation: 25.60 calls

Trial  6
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
5 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(5,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
6 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(6,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(7,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

  |
8 |     case _ => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

  |
9 |   }
  |    ^

ex.dfy(9,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
12 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
13 |   match e {
   |            ^

ex.dfy(13,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
14 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
15 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
16 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(16,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
17 |     case _ => e
   |                ^

ex.dfy(17,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
18 |   }
   |    ^

ex.dfy(18,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
24 |   match e {
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
25 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(25,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
26 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
25 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
26 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(26,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(25,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ => ()
   |                 ^

ex.dfy(26,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
27 |   }
   |   ^

ex.dfy(27,2): Error: invalid Suffix
   |
26 |     case _ => ()
   |               ^

ex.dfy(26,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(26,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
25 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(25,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }

   |
27 |     }
   |      ^

ex.dfy(27,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
28 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);

   |
29 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }

   |
30 |     }
   |      ^

ex.dfy(30,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
31 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(31,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
33 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}

   |
35 |     case _ => {}
   |                 ^

ex.dfy(35,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }

   |
36 |   }
   |    ^

ex.dfy(36,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }
}

ex.dfy(25,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)

   |
26 |       // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
   |                                                               ^

ex.dfy(26,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize

   |
27 |       // By definition of optimize
   |                                   ^

ex.dfy(27,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }

   |
29 |     }
   |      ^

ex.dfy(29,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
30 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(30,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)

   |
31 |       // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
   |                                                               ^

ex.dfy(31,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize

   |
32 |       // By definition of optimize
   |                                   ^

ex.dfy(32,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);

   |
33 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
35 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(35,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
36 |       // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                                 ^

ex.dfy(36,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize

   |
37 |       // By definition of optimize
   |                                   ^

ex.dfy(37,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);

   |
38 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(38,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
39 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(39,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
40 |     }
   |      ^

ex.dfy(40,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
41 |     case _ => ()
   |                 ^

ex.dfy(41,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => ()
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => ()
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` package com.github.misterchangray.service.platform;

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => ()
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['``` package com.github.misterchangray.service.platform;\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2

   |
26 |       // nothing to optimize here, so we just recursively optimize e2
   |                                                                      ^

ex.dfy(26,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // nothing to optimize here, so we just recursively optimize e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }

   |
28 |     }
   |      ^

ex.dfy(28,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
29 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(29,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1

   |
30 |       // nothing to optimize here, so we just recursively optimize e1
   |                                                                      ^

ex.dfy(30,69): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // nothing to optimize here, so we just recursively optimize e1\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
33 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2

   |
34 |       // recursively optimize both e1 and e2
   |                                             ^

ex.dfy(34,44): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // recursively optimize both e1 and e2\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);

   |
35 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
36 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(36,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
37 |     }
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // base case: nothing to optimize

   |
38 |     case _ => () // base case: nothing to optimize
   |                                                   ^

ex.dfy(38,50): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => () // base case: nothing to optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // base case: nothing to optimize
  }

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => () // base case: nothing to optimize
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // base case: nothing to optimize
  }
}

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => () // base case: nothing to optimize
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // nothing to optimize here, so we just recursively optimize e2
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // nothing to optimize here, so we just recursively optimize e1
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // recursively optimize both e1 and e2
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => () // base case: nothing to optimize
  }
}
``` import { Component, OnInit, Input } from '@angular/core';

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => () // base case: nothing to optimize
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
["``` import { Component, OnInit, Input } from '@angular/core';\n"]
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 103
number of gen nodes: 52 (including leaves: 18)
number of back nodes: 51 (including leaves: 34)

expansion count: 91 (including failed: 40)

cache stats {'hit': 360, 'miss': 93}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608]

Trial calls: [403, 409, 429, 353, 412, 453]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.67 sec, Standard Deviation: 4.15 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 409.83 calls, Standard Deviation: 30.31 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608]

Trial calls: [403, 409, 429, 353, 412, 453]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.67 sec, Standard Deviation: 4.15 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 409.83 calls, Standard Deviation: 30.31 calls

Trial  7
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)

SCORE
1.0
['  | Const(i: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
8 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
9 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(9,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
11 |   case _ => true
   |                 ^

ex.dfy(11,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
16 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
17 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(18,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
19 |   case _ => e
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
25 |   match e
   |          ^

ex.dfy(25,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
27 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
28 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;

   |
30 |   ;
   |   ^

ex.dfy(30,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
None
['  ;\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}

   |
30 |   ;
   |   ^

ex.dfy(30,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(i: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  ;
}
``` package com.github.yamamotoj.singlemoduleapp.package08

   |
30 |   ;
   |   ^

ex.dfy(30,2): Error: this symbol not expected in CaseStmt
1 parse errors detected in ex.dfy

SCORE
-1.0
['``` package com.github.yamamotoj.singlemoduleapp.package08\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 107
number of gen nodes: 54 (including leaves: 18)
number of back nodes: 53 (including leaves: 36)

expansion count: 93 (including failed: 40)

cache stats {'hit': 381, 'miss': 71}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603]

Trial calls: [403, 409, 429, 353, 412, 453, 452]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.00 sec, Standard Deviation: 4.17 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 415.86 calls, Standard Deviation: 31.71 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603]

Trial calls: [403, 409, 429, 353, 412, 453, 452]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.00 sec, Standard Deviation: 4.17 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 415.86 calls, Standard Deviation: 31.71 calls

Trial  8
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

SCORE
1.0
['datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
3 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(3,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
4 |   match e {
  |            ^

ex.dfy(4,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
5 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(5,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
6 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(6,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

  |
7 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
  |                                                   ^

ex.dfy(7,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

  |
8 |     case _ => true
  |                   ^

ex.dfy(8,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

  |
9 |   }
  |    ^

ex.dfy(9,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
12 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(12,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
13 |   match e {
   |            ^

ex.dfy(13,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
14 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(14,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
15 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(15,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
16 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(16,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
17 |     case _ => e
   |                ^

ex.dfy(17,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
18 |   }
   |    ^

ex.dfy(18,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
23 | {
   |  ^

ex.dfy(23,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
24 |   match e {
   |            ^

ex.dfy(24,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
25 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(25,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
26 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(26,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(25,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(26,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(27,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ =>
  }

   |
27 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(27,46): Error: missing semicolon at end of statement
   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
2 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
25 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(25,30): Error: missing semicolon at end of statement
   |
26 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(26,30): Error: missing semicolon at end of statement
   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {

   |
25 |     case Add(Const(0), e2) => {
   |                                ^

ex.dfy(25,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.

   |
26 |       // Here we use the lemma recursively on e2.
   |                                                  ^

ex.dfy(26,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here we use the lemma recursively on e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }

   |
28 |     }
   |      ^

ex.dfy(28,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
29 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(29,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.

   |
30 |       // Here we use the lemma recursively on e1.
   |                                                  ^

ex.dfy(30,49): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here we use the lemma recursively on e1.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }

   |
32 |     }
   |      ^

ex.dfy(32,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
33 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(33,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.

   |
34 |       // Here we use the lemma recursively on e1 and e2.
   |                                                         ^

ex.dfy(34,56): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Here we use the lemma recursively on e1 and e2.\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);

   |
35 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(35,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
36 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(36,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
37 |     }
   |      ^

ex.dfy(37,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
38 |     case _ => ()
   |                 ^

ex.dfy(38,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => ()
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => ()
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Here we use the lemma recursively on e2.
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Here we use the lemma recursively on e1.
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Here we use the lemma recursively on e1 and e2.
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` import 'package:flutter/material.dart';

   |
39 |   }
   |   ^

ex.dfy(39,2): Error: invalid Suffix
   |
38 |     case _ => ()
   |               ^

ex.dfy(38,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
["``` import 'package:flutter/material.dart';\n"]
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
25 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(25,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
26 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
27 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
28 |     case _ =>
   |              ^

ex.dfy(28,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
29 |   }
   |    ^

ex.dfy(29,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(6,29): Related location
  |
6 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(25,4): Error: a postcondition could not be proved on this return path
   |
25 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(22,10): Related location: this is the postcondition that could not be proved
   |
22 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(5,29): Related location
  |
5 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);

   |
26 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }

   |
27 |     }
   |      ^

ex.dfy(27,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
28 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(28,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);

   |
29 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }

   |
30 |     }
   |      ^

ex.dfy(30,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
31 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(31,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
33 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}

   |
35 |     case _ => {}
   |                 ^

ex.dfy(35,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }

   |
36 |   }
   |    ^

ex.dfy(36,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => {}
  }
}

ex.dfy(25,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)

   |
26 |       // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
   |                                                               ^

ex.dfy(26,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize

   |
27 |       // By definition of optimize
   |                                   ^

ex.dfy(27,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }

   |
29 |     }
   |      ^

ex.dfy(29,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {

   |
30 |     case Add(e1, Const(0)) => {
   |                                ^

ex.dfy(30,31): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)

   |
31 |       // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
   |                                                               ^

ex.dfy(31,62): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize

   |
32 |       // By definition of optimize
   |                                   ^

ex.dfy(32,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);

   |
33 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }

   |
34 |     }
   |      ^

ex.dfy(34,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {

   |
35 |     case Add(e1, e2) => {
   |                          ^

ex.dfy(35,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))

   |
36 |       // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
   |                                                                                 ^

ex.dfy(36,80): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize

   |
37 |       // By definition of optimize
   |                                   ^

ex.dfy(37,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      // By definition of optimize\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);

   |
38 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(38,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
39 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(39,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }

   |
40 |     }
   |      ^

ex.dfy(40,5): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()

   |
41 |     case _ => ()
   |                 ^

ex.dfy(41,16): Error: invalid Suffix
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => ()
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => ()
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
None
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => {
      // Base case: optimize(Add(Const(0), e2)) = optimize(e2)
      // By definition of optimize
      OptimizerOptimal(e2);
    }
    case Add(e1, Const(0)) => {
      // Base case: optimize(Add(e1, Const(0))) = optimize(e1)
      // By definition of optimize
      OptimizerOptimal(e1);
    }
    case Add(e1, e2) => {
      // Inductive case: optimize(Add(e1, e2)) = Add(optimize(e1), optimize(e2))
      // By definition of optimize
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    }
    case _ => ()
  }
}
``` <?php

   |
42 |   }
   |   ^

ex.dfy(42,2): Error: invalid Suffix
   |
41 |     case _ => ()
   |               ^

ex.dfy(41,14): Error: missing semicolon at end of statement
2 parse errors detected in ex.dfy

SCORE
-1.0
['``` <?php\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                                                   ^

ex.dfy(25,66): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
26 |     case _ => ()
   |                 ^

ex.dfy(26,16): Error: invalid Suffix
2 parse errors detected in ex.dfy

SCORE
None
['    case _ => ()\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = Const(n: int) | Var(name: string) | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
    case _ => ()
  }

   |
25 |     case Add(e1, e2) => OptimizerOptimal(e1); OptimizerOptimal(e2)
   |                                               ^^^^^^^^^^^^^^^^

ex.dfy(25,46): Error: missing semicolon at end of statement
   |
27 |   }
   |   ^

ex.dfy(27,2): Error: invalid Suffix
   |
26 |     case _ => ()
   |               ^

ex.dfy(26,14): Error: missing semicolon at end of statement
3 parse errors detected in ex.dfy

SCORE
-1.0
['  }\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 97
number of gen nodes: 49 (including leaves: 18)
number of back nodes: 48 (including leaves: 31)

expansion count: 86 (including failed: 38)

cache stats {'hit': 350, 'miss': 96}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603, 605]

Trial calls: [403, 409, 429, 353, 412, 453, 452, 446]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 606.75 sec, Standard Deviation: 3.96 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 419.62 calls, Standard Deviation: 31.29 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603, 605]

Trial calls: [403, 409, 429, 353, 412, 453, 452, 446]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 606.75 sec, Standard Deviation: 3.96 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 419.62 calls, Standard Deviation: 31.29 calls

Trial  9
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr = \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)

SCORE
1.0
['  | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e

  |
7 |   match e
  |          ^

ex.dfy(7,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false

  |
8 |   case Add(Const(0), _) => false
  |                                 ^

ex.dfy(8,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false

  |
9 |   case Add(_, Const(0)) => false
  |                                 ^

ex.dfy(9,32): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |   case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                 ^

ex.dfy(10,48): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true

   |
11 |   case _ => true
   |                 ^

ex.dfy(11,16): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {

   |
14 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(14,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e

   |
15 |   match e
   |          ^

ex.dfy(15,9): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)

   |
16 |   case Add(Const(0), e2) => optimize(e2)
   |                                         ^

ex.dfy(16,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)

   |
17 |   case Add(e1, Const(0)) => optimize(e1)
   |                                         ^

ex.dfy(17,40): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |   case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                      ^

ex.dfy(18,53): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e

   |
19 |   case _ => e
   |              ^

ex.dfy(19,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
24 | {
   |  ^

ex.dfy(24,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e

   |
25 |   match e
   |          ^

ex.dfy(25,9): Error: invalid MatchStmt
1 parse errors detected in ex.dfy

SCORE
None
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}

   |
26 |   case Add(Const(0), e2) => {}
   |                               ^

ex.dfy(26,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}

   |
27 |   case Add(e1, Const(0)) => {}
   |                               ^

ex.dfy(27,30): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => {}

   |
31 |   case _ => {}
   |               ^

ex.dfy(31,14): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => {}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => {}
  case Add(e1, Const(0)) => {}
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => {}
}

ex.dfy(26,21): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5299,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => {}\n']
['  case Add(e1, Const(0)) => {}\n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ => {}\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>

   |
26 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(26,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
27 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(27,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
28 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(28,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) =>
  case Add(e1, Const(0)) =>
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>

   |
29 |   case _ =>
   |            ^

ex.dfy(29,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
  }

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['  }\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 

   |
26 |   case Add(Const(0), e2) =>
   |                            ^

ex.dfy(26,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 

   |
27 |   case Add(e1, Const(0)) =>
   |                            ^

ex.dfy(27,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) => 
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) => 
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ => \n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['  }\n']
['\n']
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {

   |
15 |   match e {
   |            ^

ex.dfy(15,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
16 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(16,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
17 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
18 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(18,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
19 |     case _ => e
   |                ^

ex.dfy(19,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
20 |   }
   |    ^

ex.dfy(20,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
25 | {
   |  ^

ex.dfy(25,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
26 |   match e {
   |            ^

ex.dfy(26,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);

   |
28 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 

   |
31 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(31,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 
      OptimizerOptimal(e1);

   |
32 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
33 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(33,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
34 |     case _ =>
   |              ^

ex.dfy(34,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
35 |   }
   |    ^

ex.dfy(35,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
      OptimizerOptimal(e2);
    case Add(e1, Const(0)) => 
      OptimizerOptimal(e1);
    case Add(e1, e2) => 
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(27,23): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

*** Encountered internal translation error - re-running Boogie to get better debug information

/tmp/ex__module.bpl(5304,6): Error: more than one declaration of variable name: e2#0_2_0_2_0_0
1 name resolution errors detected in /tmp/ex__module.bpl

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
27 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(27,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
['      OptimizerOptimal(e2);\n']
['    case Add(e1, Const(0)) => \n']
['      OptimizerOptimal(e1);\n']
['    case Add(e1, e2) => \n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ => \n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>

   |
27 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(27,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
28 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(28,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
29 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(29,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 

   |
30 |     case _ =>
   |              ^

ex.dfy(30,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }

   |
31 |   }
   |    ^

ex.dfy(31,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ => 
  }
}

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(27,4): Error: a postcondition could not be proved on this return path
   |
27 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(27,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) => 

   |
27 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(27,30): Error: missing semicolon at end of statement
   |
28 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) => \n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 

   |
28 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>

   |
29 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(29,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
30 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(30,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
31 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
32 |     case _ =>
   |              ^

ex.dfy(32,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
33 |   }
   |    ^

ex.dfy(33,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => 
    case Add(e1, Const(0)) => 
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(29,4): Error: a postcondition could not be proved on this return path
   |
29 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(24,10): Related location: this is the postcondition that could not be proved
   |
24 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['function optimize(e: Expr): Expr {\n']
['  match e\n']
['  case Add(Const(0), e2) => optimize(e2)\n']
['  case Add(e1, Const(0)) => optimize(e1)\n']
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['  case _ => e\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                 ^

ex.dfy(26,48): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                 ^

ex.dfy(27,48): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => OptimizerOptimal(e2)
  case Add(e1, Const(0)) => OptimizerOptimal(e1)
  case Add(e1, e2) =>

   |
26 |   case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(26,28): Error: missing semicolon at end of statement
   |
27 |   case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                             ^^^^^^^^^^^^^^^^

ex.dfy(27,28): Error: missing semicolon at end of statement
   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['  case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['  }\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ => \n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['predicate optimal(e: Expr) {\n']
['  match e\n']
['  case Add(Const(0), _) => false\n']
['  case Add(_, Const(0)) => false\n']
['  case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['  case _ => true\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e\n']
['  case Add(Const(0), e2) => optimize(e2)\n']
['  case Add(e1, Const(0)) => optimize(e1)\n']
['  case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['  case _ => e\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ => \n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>

   |
28 |   case Add(e1, e2) =>
   |                      ^

ex.dfy(28,21): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);

   |
29 |     OptimizerOptimal(e1);
   |                          ^

ex.dfy(29,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);

   |
30 |     OptimizerOptimal(e2);
   |                          ^

ex.dfy(30,25): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 

   |
31 |   case _ =>
   |            ^

ex.dfy(31,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  case _ => \n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(Const(0), e2) => 
  case Add(e1, Const(0)) => 
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ => 
}

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(28,2): Error: a postcondition could not be proved on this return path
   |
28 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}

function optimize(e: Expr): Expr {
  match e
  case Add(Const(0), e2) => optimize(e2)
  case Add(e1, Const(0)) => optimize(e1)
  case Add(e1, e2) => Add(optimize(e1), optimize(e2))
  case _ => e
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e
  case Add(e1, e2) =>
    OptimizerOptimal(e1);
    OptimizerOptimal(e2);
  case _ =>
}

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,27): Related location
  |
9 |   case Add(_, Const(0)) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^

ex.dfy(26,2): Error: a postcondition could not be proved on this return path
   |
26 |   case Add(e1, e2) =>
   |   ^^^^

ex.dfy(23,10): Related location: this is the postcondition that could not be proved
   |
23 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,27): Related location
  |
8 |   case Add(Const(0), _) => false
  |                            ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ => \n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) => \n']
['  case Add(e1, Const(0)) => \n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ => \n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) =>\n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['{\n']
['  match e\n']
['  case Add(Const(0), e2) =>\n']
['  case Add(e1, Const(0)) =>\n']
['  case Add(e1, e2) => \n']
['    OptimizerOptimal(e1);\n']
['    OptimizerOptimal(e2);\n']
['  case _ =>\n']
['}\n']
['\n']
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr = 
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 97
number of gen nodes: 49 (including leaves: 18)
number of back nodes: 48 (including leaves: 31)

expansion count: 86 (including failed: 38)

cache stats {'hit': 300, 'miss': 123}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603, 605, 614]

Trial calls: [403, 409, 429, 353, 412, 453, 452, 446, 423]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.56 sec, Standard Deviation: 4.37 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 420.00 calls, Standard Deviation: 29.52 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603, 605, 614]

Trial calls: [403, 409, 429, 353, 412, 453, 452, 446, 423]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.56 sec, Standard Deviation: 4.37 sec

Call Statistics:

  Min: 353 calls, Max: 453 calls, Average: 420.00 calls, Standard Deviation: 29.52 calls

Trial  10
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =

  |
1 | datatype Expr =
  |                ^

ex.dfy(1,15): Error: invalid NoUSIdentOrDigits
1 parse errors detected in ex.dfy

SCORE
None
['datatype Expr =\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)

SCORE
1.0
['  | Const(val: int)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)

SCORE
1.0
['  | Var(name: string)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

SCORE
1.0
['  | Add(e1: Expr, e2: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {

  |
6 | predicate optimal(e: Expr) {
  |                             ^

ex.dfy(6,28): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['predicate optimal(e: Expr) {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {

  |
7 |   match e {
  |            ^

ex.dfy(7,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false

  |
8 |     case Add(Const(0), _) => false
  |                                   ^

ex.dfy(8,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), _) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false

  |
9 |     case Add(_, Const(0)) => false
  |                                   ^

ex.dfy(9,34): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(_, Const(0)) => false\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)

   |
10 |     case Add(e1, e2) => optimal(e1) && optimal(e2)
   |                                                   ^

ex.dfy(10,50): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true

   |
11 |     case _ => true
   |                   ^

ex.dfy(11,18): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => true\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }

   |
12 |   }
   |    ^

ex.dfy(12,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {

   |
15 | function optimize(e: Expr): Expr {
   |                                   ^

ex.dfy(15,34): Error: invalid UnaryExpression
1 parse errors detected in ex.dfy

SCORE
None
['function optimize(e: Expr): Expr {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {

   |
16 |   match e {
   |            ^

ex.dfy(16,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)

   |
17 |     case Add(Const(0), e2) => optimize(e2)
   |                                           ^

ex.dfy(17,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => optimize(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)

   |
18 |     case Add(e1, Const(0)) => optimize(e1)
   |                                           ^

ex.dfy(18,42): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => optimize(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))

   |
19 |     case Add(e1, e2) => Add(optimize(e1), optimize(e2))
   |                                                        ^

ex.dfy(19,55): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e

   |
20 |     case _ => e
   |                ^

ex.dfy(20,15): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ => e\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }

   |
21 |   }
   |    ^

ex.dfy(21,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

SCORE
1.0
['}\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}


SCORE
1.0
['\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)

SCORE
1.0
['lemma OptimizerOptimal(e: Expr)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))

SCORE
1.0
['  ensures optimal(optimize(e))\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{

   |
26 | {
   |  ^

ex.dfy(26,1): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['{\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {

   |
27 |   match e {
   |            ^

ex.dfy(27,11): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>

   |
28 |     case Add(Const(0), e2) =>
   |                              ^

ex.dfy(28,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>

   |
29 |     case Add(e1, Const(0)) =>
   |                              ^

ex.dfy(29,29): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>

   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, e2) =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);

   |
31 |       OptimizerOptimal(e1);
   |                            ^

ex.dfy(31,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e1);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);

   |
32 |       OptimizerOptimal(e2);
   |                            ^

ex.dfy(32,27): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['      OptimizerOptimal(e2);\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>

   |
33 |     case _ =>
   |              ^

ex.dfy(33,13): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['    case _ =>\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }

   |
34 |   }
   |    ^

ex.dfy(34,3): Error: rbrace expected
1 parse errors detected in ex.dfy

SCORE
None
['  }\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) =>
    case Add(e1, Const(0)) =>
    case Add(e1, e2) =>
      OptimizerOptimal(e1);
      OptimizerOptimal(e2);
    case _ =>
  }
}

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(9,29): Related location
  |
9 |     case Add(_, Const(0)) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^

ex.dfy(30,4): Error: a postcondition could not be proved on this return path
   |
30 |     case Add(e1, e2) =>
   |     ^^^^

ex.dfy(25,10): Related location: this is the postcondition that could not be proved
   |
25 |   ensures optimal(optimize(e))
   |           ^^^^^^^^^^^^^^^^^^^^

ex.dfy(8,29): Related location
  |
8 |     case Add(Const(0), _) => false
  |                              ^^^^^


Dafny program verifier finished with 2 verified, 5 errors

SCORE
-1.0
['}\n']
['{\n']
['  match e {\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                                                   ^

ex.dfy(28,50): Error: invalid UpdateStmt
1 parse errors detected in ex.dfy

SCORE
None
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                                                   ^

ex.dfy(29,50): Error: invalid UpdateStmt
2 parse errors detected in ex.dfy

SCORE
None
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
TEXT
### Spec: In Dafny, write an ADT for arithmetic expressions comprising constants, variables and binary addition. Then write a predicate `optimal` that holds on an expression if it has no additions by 0. Then write an optimizer `optimize` that removes all additions by 0. Then write a lemma `OptimizerOptimal` that ensures `optimal(optimize(e))` for all expressions `e`.
### Hint: This is the definiton of the `optimal` predicate:
predicate optimal(e: Expr) {
  match e
  case Add(Const(0), _) => false
  case Add(_, Const(0)) => false
  case Add(e1, e2) => optimal(e1) && optimal(e2)
  case _ => true
}
### Hint: Don't use the same structure for `optimize` as for `optimal`. Instead, follow the next hint.
### Hint: In the addition case, the `optimize` function should recursively optimize the sub-expressions and then match on the optimized sub-expressions.
### Hint: Do NOT use `requires` anywhere.
### Hint: Write the lemma as
lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
### Hint: Recall that in Dafny, pattern match takes the form
match e
case Foo(x, y) => 1
case Bar(x) => 2
case _ => 3
### Hint: For the proof, just do a simple pattern match (match not if) and call the lemma recursively without adding asserts.

```dafny
datatype Expr =
  | Const(val: int)
  | Var(name: string)
  | Add(e1: Expr, e2: Expr)

predicate optimal(e: Expr) {
  match e {
    case Add(Const(0), _) => false
    case Add(_, Const(0)) => false
    case Add(e1, e2) => optimal(e1) && optimal(e2)
    case _ => true
  }
}

function optimize(e: Expr): Expr {
  match e {
    case Add(Const(0), e2) => optimize(e2)
    case Add(e1, Const(0)) => optimize(e1)
    case Add(e1, e2) => Add(optimize(e1), optimize(e2))
    case _ => e
  }
}

lemma OptimizerOptimal(e: Expr)
  ensures optimal(optimize(e))
{
  match e {
    case Add(Const(0), e2) => OptimizerOptimal(e2)
    case Add(e1, Const(0)) => OptimizerOptimal(e1)
    case Add(e1, e2) =>

   |
28 |     case Add(Const(0), e2) => OptimizerOptimal(e2)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(28,30): Error: missing semicolon at end of statement
   |
29 |     case Add(e1, Const(0)) => OptimizerOptimal(e1)
   |                               ^^^^^^^^^^^^^^^^

ex.dfy(29,30): Error: missing semicolon at end of statement
   |
30 |     case Add(e1, e2) =>
   |                        ^

ex.dfy(30,23): Error: rbrace expected
3 parse errors detected in ex.dfy

SCORE
-1.0
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['\n']
['predicate optimal(e: Expr) {\n']
['  match e {\n']
['    case Add(Const(0), _) => false\n']
['    case Add(_, Const(0)) => false\n']
['    case Add(e1, e2) => optimal(e1) && optimal(e2)\n']
['    case _ => true\n']
['  }\n']
['}\n']
['\n']
['function optimize(e: Expr): Expr {\n']
['  match e {\n']
['    case Add(Const(0), e2) => optimize(e2)\n']
['    case Add(e1, Const(0)) => optimize(e1)\n']
['    case Add(e1, e2) => Add(optimize(e1), optimize(e2))\n']
['    case _ => e\n']
['  }\n']
['}\n']
['\n']
['lemma OptimizerOptimal(e: Expr)\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['  ensures optimal(optimize(e))\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) =>\n']
['    case Add(e1, Const(0)) =>\n']
['    case Add(e1, e2) =>\n']
['      OptimizerOptimal(e1);\n']
['      OptimizerOptimal(e2);\n']
['    case _ =>\n']
['  }\n']
['}\n']
['{\n']
['  match e {\n']
['    case Add(Const(0), e2) => OptimizerOptimal(e2)\n']
['    case Add(e1, Const(0)) => OptimizerOptimal(e1)\n']
['    case Add(e1, e2) =>\n']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 109
number of gen nodes: 55 (including leaves: 19)
number of back nodes: 54 (including leaves: 36)

expansion count: 96 (including failed: 42)

cache stats {'hit': 448, 'miss': 38}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603, 605, 614, 605]

Trial calls: [403, 409, 429, 353, 412, 453, 452, 446, 423, 486]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.30 sec, Standard Deviation: 4.22 sec

Call Statistics:

  Min: 353 calls, Max: 486 calls, Average: 426.60 calls, Standard Deviation: 34.30 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [615, 606, 601, 609, 607, 608, 603, 605, 614, 605]

Trial calls: [403, 409, 429, 353, 412, 453, 452, 446, 423, 486]


Time Statistics:

  Min: 601.00 sec, Max: 615.00 sec, Average: 607.30 sec, Standard Deviation: 4.22 sec

Call Statistics:

  Min: 353 calls, Max: 486 calls, Average: 426.60 calls, Standard Deviation: 34.30 calls

To complete all experiments, 101 minutes and 53 seconds elapsed.


