

========
Experiment configuration: python experiments.py --experiment_name run.py --n_trials 10 --mins_timeout 10 --language Coq --problem_name problem_opt0 --seed 42 


[2024-01-13 10:52:48,809] [INFO] [real_accelerator.py:158:get_accelerator] Setting ds_accelerator to cuda (auto detect)
Trial  1
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.
File "./ex.v", line 4, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.
File "./ex.v", line 5, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.
File "./ex.v", line 5, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.
File "./ex.v", line 18, characters 19-20:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive AExp :=\n| AConst (n : Z)\n| AVar (x : string)\n| AAdd (e1 e2 : AExp).\n\nFixpoint eval (e : AExp) (env : string -> Z) : Z :=\n  match e with\n  | AConst n => n\n  | AVar x => env x\n  | AAdd e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2

File "./ex.v", line 30, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AConst _ => e\n  | AVar _ => e\n  | AAdd e1 e2 =>\n    match optimize e1, optimize e2 with\n    | AConst 0, e2 => e2\n    | e1, AConst 0 => e1\n    | e1, e2 => AAdd e1 e2\n']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.
SCORE
1.0
['    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nLemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),\n  eval e env = eval (optimize e) env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHa1.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
None
['\n    rewrite IHa1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHa1.
    rewrite IHa2.
File "./ex.v", line 41, characters 12-16:
Error: The variable IHa1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite IHa2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 41, characters 4-19:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n    rewrite <- IHe1.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 11-26:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct IHexp1; destruct IHexp2; try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 40, characters 13-19:
Error: The variable IHexp1 was not found in the current environment.


SCORE
-1.0
['\n  - destruct IHexp1; destruct IHexp2; try destruct n; try destruct n0; eauto using PeanoNat.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite IHa1.']
['\n    rewrite IHa2.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite IHe1.
    rewrite IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 37, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 39, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. reflexivity.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 41, characters 4-19:
Error: Cannot find a relation to rewrite.


SCORE
-1.0
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [|n x | e1 e2 IHe1 IHe2]; simpl.
  - reflexivity.
  - rewrite <- IHe1.
File "./ex.v", line 37, characters 2-49:
Warning: Unused introduction pattern: x
[unused-intro-pattern,tactics,default]
File "./ex.v", line 39, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
['\n  - rewrite <- IHe1.']
['\n    rewrite IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2]; try simpl.
File "./ex.v", line 37, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2]; try simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 41, characters 4-19:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Lemma optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval e env = eval (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 11-26:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\n  - simpl.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - destruct (optimize e0); simpl; try reflexivity.
File "./ex.v", line 38, characters 23-25:
Error: The variable e0 was not found in the current environment.


SCORE
-1.0
['\n  - destruct (optimize e0); simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - eauto.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - eauto.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
  - reflexivity.
File "./ex.v", line 41, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - reflexivity.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1, optimize e2 with
    | AConst 0, e2 => e2
    | e1, AConst 0 => e1
    | e1, e2 => AAdd e1 e2
    end
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - destruct n; try reflexivity.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct n; try reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1
File "./ex.v", line 31, characters 30-31:
Error:
Syntax error: '|' or ',' or ')' expected after [term level 200] (in [term]).


SCORE
None
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AConst _ => e\n  | AVar _ => e\n  | AAdd e1 e2 =>\n    match optimize e1 with\n    | AConst 0 => optimize e2\n    | _ =>\n      match optimize e2 with\n      | AConst 0 => optimize e1\n      | _ => AAdd (optimize e1']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.
SCORE
1.0
[') (optimize e2)\n      end\n    end\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [| x e1 e2 | e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 42, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe1.']
[' reflexivity.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 43, characters 39-43:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 45, characters 15-19:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import ZArith.

Inductive AExp :=
| AConst (n : Z)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> Z) : Z :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AConst _ => e
  | AVar _ => e
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | _ =>
      match optimize e2 with
      | AConst 0 => optimize e1
      | _ => AAdd (optimize e1) (optimize e2)
      end
    end
  end.

Theorem optimize_preserves_semantics : forall (e : AExp) (env : string -> Z),
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2 | e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite IHe1.
File "./ex.v", line 40, characters 2-37:
Warning: Unused introduction patterns: e1 e2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 42, characters 19-23:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite IHe1.']
[' rewrite <- IHe1.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Import StringNotations.
File "./ex.v", line 7, characters 7-22:
Error: Cannot find module StringNotations


SCORE
-1.0
['\nImport StringNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.
SCORE
1.0
['\n\nInductive Exp : Type :=\n  | Const : nat -> Exp\n  | Var : string -> Exp\n  | Add : Exp -> Exp -> Exp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Definition evaluate (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 17, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition evaluate (e : Exp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Definition evaluate (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
File "./ex.v", line 17, characters 24-32:
Error: The reference evaluate was not found in the current environment.


SCORE
-1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Definition evaluate (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
File "./ex.v", line 17, characters 17-25:
Error: The reference evaluate was not found in the current environment.


SCORE
-1.0
['\n\nDefinition evaluate (e : Exp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
SCORE
1.0
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.List.
File "./ex.v", line 8, characters 7-16:
Error: Cannot find module List.List


SCORE
-1.0
['List.']
['List.']
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : Z -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.
File "./ex.v", line 20, characters 18-19:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add e1 (Const 0) => optimize e1\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *) reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *) reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite IHexpr1.
File "./ex.v", line 39, characters 12-19:
Error: The variable IHexpr1 was not found in the current environment.


SCORE
None
['\n  - (* Add e1 e2 *)\n    rewrite IHexpr1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite IHexpr1.
    rewrite IHexpr2.
File "./ex.v", line 39, characters 12-19:
Error: The variable IHexpr1 was not found in the current environment.


SCORE
-1.0
['\n    rewrite IHexpr2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite IHe1.
File "./ex.v", line 39, characters 4-16:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - (* Add e1 e2 *)\n    rewrite IHe1.']
['\n  - (* Var x *) reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.
File "./ex.v", line 43, characters 16-22:
Error: The variable ZArith was not found in the current environment.


SCORE
None
['\n    eauto using ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.Nat.
File "./ex.v", line 43, characters 16-26:
Error: The reference ZArith.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using ZArith.Nat.add_0_r.
File "./ex.v", line 43, characters 16-34:
Error: The reference ZArith.Nat.add_0_r was not found in the current
environment.


SCORE
-1.0
['add_0_r.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *) reflexivity.
  - (* Var x *) reflexivity.
  - (* Add e1 e2 *)
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n  - (* Add e1 e2 *)\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
  - rewrite He1.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - rewrite He1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
  - destruct n; try destruct n0; eauto using Z.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.add_0_r.
  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.
File "./ex.v", line 39, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - destruct n; destruct n0; try (destruct IHexpr); try (destruct IHexpr0); try (destruct IHexpr1); try (destruct IHexpr01); eauto using PeanoNat.
File "./ex.v", line 38, characters 13-14:
Error: The variable n was not found in the current environment.


SCORE
-1.0
['\n  - destruct n; destruct n0; try (destruct IHexpr); try (destruct IHexpr0); try (destruct IHexpr1); try (destruct IHexpr01); eauto using PeanoNat.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import List.
Import ZArith.

Inductive Expr : Type :=
  | Const : Z -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Z.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n x e1 e2].
  - simpl.
File "./ex.v", line 35, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2].\n  - simpl.']
['\nRequire Import Coq.']
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
SCORE
1.0
['BinInt.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.
SCORE
1.0
['\nImport Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.
File "./ex.v", line 18, characters 22-23:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.
SCORE
1.0
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n    | Const _ => e\n    | Var _ => e\n    | Add e1 e2 =>\n      match optimize e1, optimize e2 with\n        | Const 0, _ => e2\n        | _, Const 0 => e1\n        | e1', e2' => Add e1' e2'\n      end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n\nTheorem optimize_preserves_eval:\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 45, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 46, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_eval.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_eval): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - reflexivity.']
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.BinInt.
Import ListNotations.
Import Nat.

Inductive expr :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Const _ => e
    | Var _ => e
    | Add e1 e2 =>
      match optimize e1, optimize e2 with
        | Const 0, _ => e2
        | _, Const 0 => e1
        | e1', e2' => Add e1' e2'
      end
  end.

Theorem optimize_preserves_eval:
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite IHe1.
File "./ex.v", line 40, characters 4-16:
Error:
Found no subterm matching "eval (optimize e1) env" in the current goal.


SCORE
-1.0
['\n  - rewrite IHe1.']
['\n  - rewrite IHe1.']
['\n  - reflexivity.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 335
number of gen nodes: 168 (including leaves: 55)
number of back nodes: 167 (including leaves: 113)

expansion count: 293 (including failed: 126)

cache stats {'hit': 134, 'miss': 232}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601]

Trial calls: [366]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 366 calls, Max: 366 calls, Average: 366.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601]

Trial calls: [366]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 366 calls, Max: 366 calls, Average: 366.00 calls, Standard Deviation: 0.00 calls

Trial  2
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
SCORE
1.0
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.List.
File "./ex.v", line 5, characters 7-16:
Error: Cannot find module List.List


SCORE
-1.0
['List.']
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import ListStringNotations.
File "./ex.v", line 5, characters 7-26:
Error: Cannot find module ListStringNotations


SCORE
-1.0
['\nImport ListStringNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListStringNotations.
File "./ex.v", line 6, characters 7-26:
Error: Cannot find module ListStringNotations


SCORE
-1.0
['\nImport ListStringNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Definition eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 16, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Definition eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 16, characters 26-30:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.
File "./ex.v", line 16, characters 22-23:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n    | Add (Const 0) e2 => optimize e2\n    | Add e1 (Const 0) => optimize e1\n    | Add e1 e2 => Add (optimize e1) (optimize e2)\n    | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-28:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 30, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - (* Var x *)\n    simpl.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
SCORE
1.0
['\nImport Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.
SCORE
1.0
['\nImport PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.
SCORE
1.0
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.
SCORE
1.0
['\n\nInductive AExp : Type :=\n  | Const : nat -> AExp\n  | Var : string -> AExp\n  | Add : AExp -> AExp -> AExp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 18, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : AExp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'

File "./ex.v", line 31, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.
SCORE
1.0
["    | _, _ => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n\nTheorem optimize_preserves_evaluate :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 45, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_evaluate.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
```

This script defines an abstract syntax tree (ADT) for arithmetic expressions, an evaluator function that takes an expression and an environment and returns the evaluated result, and an optimizer function that removes additions by 0.
SCORE
1.0
['\n```\n\nThis script defines an abstract syntax tree (ADT) for arithmetic expressions, an evaluator function that takes an expression and an environment and returns the evaluated result, and an optimizer function that removes additions by 0.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Import Nat.
Import PeanoNat.Nat.

Inductive AExp : Type :=
  | Const : nat -> AExp
  | Var : string -> AExp
  | Add : AExp -> AExp -> AExp.

Fixpoint evaluate (e : AExp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_evaluate :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
```

This script defines an abstract syntax tree (ADT) for arithmetic expressions, an evaluator function that takes an expression and an environment and returns the evaluated result, and an optimizer function that removes additions by 0.

STATS

number of nodes: 161
number of gen nodes: 81 (including leaves: 20)
number of back nodes: 80 (including leaves: 61)

expansion count: 127 (including failed: 47)

cache stats {'hit': 103, 'miss': 70}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289]

Trial calls: [366, 173]


Time Statistics:

  Min: 289.00 sec, Max: 601.00 sec, Average: 445.00 sec, Standard Deviation: 156.00 sec

Call Statistics:

  Min: 173 calls, Max: 366 calls, Average: 269.50 calls, Standard Deviation: 96.50 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601]

Trial calls: [366]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 366 calls, Max: 366 calls, Average: 366.00 calls, Standard Deviation: 0.00 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289]

Trial calls: [173]


Time Statistics:

  Min: 289.00 sec, Max: 289.00 sec, Average: 289.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 173 calls, Max: 173 calls, Average: 173.00 calls, Standard Deviation: 0.00 calls

Trial  3
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
SCORE
1.0
['\nImport List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.List.
File "./ex.v", line 5, characters 7-16:
Error: Cannot find module List.List


SCORE
-1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.
File "./ex.v", line 17, characters 21-22:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive AExp : Type :=\n| ANum (n : nat)\n| AVar (x : string)\n| AAdd (e1 e2 : AExp).\n\nFixpoint eval (e : AExp) (env : string -> nat) : nat :=\n  match e with\n  | ANum n => n\n  | AVar x => env x\n  | AAdd e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AAdd (ANum 0) e2 => optimize e2\n  | AAdd e1 (ANum 0) => optimize e1\n  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 36, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\n  - simpl.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  induction e.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\n  - simpl.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 32, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2].\n  - reflexivity.']
['\nProof.']
['\n  intros e env.']
['\n  induction e.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n\nFixpoint optimize (e : AExp) : AExp :=\n  match e with\n  | AAdd (ANum 0) e2 => optimize e2\n  | AAdd e1 (ANum 0) => optimize e1\n  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)\n  | _ => e\n  end.']
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  eval (optimize e) env = eval e env.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2 IHe1 IHe2].
  - simpl.
File "./ex.v", line 32, characters 17-44:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2 IHe1 IHe2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n x e1 e2]; simpl.
File "./ex.v", line 32, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; try reflexivity.
File "./ex.v", line 32, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Import List.
Require Import Arith.

Inductive AExp : Type :=
| ANum (n : nat)
| AVar (x : string)
| AAdd (e1 e2 : AExp).

Fixpoint eval (e : AExp) (env : string -> nat) : nat :=
  match e with
  | ANum n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExp) : AExp :=
  match e with
  | AAdd (ANum 0) e2 => optimize e2
  | AAdd e1 (ANum 0) => optimize e1
  | AAdd e1 e2 => AAdd (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e; simpl.
  - reflexivity.
  - reflexivity.
  - rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 343
number of gen nodes: 172 (including leaves: 59)
number of back nodes: 171 (including leaves: 113)

expansion count: 298 (including failed: 127)

cache stats {'hit': 319, 'miss': 98}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601]

Trial calls: [366, 173, 417]


Time Statistics:

  Min: 289.00 sec, Max: 601.00 sec, Average: 497.00 sec, Standard Deviation: 147.08 sec

Call Statistics:

  Min: 173 calls, Max: 417 calls, Average: 318.67 calls, Standard Deviation: 105.09 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601]

Trial calls: [366, 417]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 366 calls, Max: 417 calls, Average: 391.50 calls, Standard Deviation: 25.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289]

Trial calls: [173]


Time Statistics:

  Min: 289.00 sec, Max: 289.00 sec, Average: 289.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 173 calls, Max: 173 calls, Average: 173.00 calls, Standard Deviation: 0.00 calls

Trial  4
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.
SCORE
1.0
['\n\nInductive Exp : Type :=\n  | Const : nat -> Exp\n  | Var : string -> Exp\n  | Add : Exp -> Exp -> Exp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Definition evaluate (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
File "./ex.v", line 14, characters 17-25:
Error: The reference evaluate was not found in the current environment.


SCORE
-1.0
['\n\nDefinition evaluate (e : Exp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Fixpoint eval (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Exp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Fixpoint eval (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 17-24:
Error: The reference nat.add was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
['\nRequire Import Arith.']
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.
SCORE
1.0
['\n\nInductive AExpr : Type :=\n  | AConst : nat -> AExpr\n  | AVar : string -> AExpr\n  | AAdd : AExpr -> AExpr -> AExpr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Definition eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.
File "./ex.v", line 14, characters 21-22:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : AExpr) (env : string -> nat) : nat :=\n  match e with\n  | AConst n => n\n  | AVar x => env x\n  | AAdd e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Definition eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 27-31:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.
File "./ex.v", line 14, characters 21-22:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : AExpr) (env : string -> nat) : nat :=\n  match e with\n  | AConst n => n\n  | AVar x => env x\n  | AAdd e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2'
File "./ex.v", line 27, characters 11-12:
Error: Syntax error: '|' or '=>' expected (in [eqn]).


SCORE
None
["\n\nFixpoint optimize (e : AExpr) : AExpr :=\n  match e with\n  | AConst n => AConst n\n  | AVar x => AVar x\n  | AAdd e1 e2 =>\n    match optimize e1 with\n    | AConst 0 => optimize e2\n    | e1' =>\n      match optimize e2 with\n      | AConst 0 => e1'\n      | e2'"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.
SCORE
1.0
[" => AAdd e1' e2'\n      end\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall (e : AExpr) (env : string -> nat),\n    eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
```

In this Coq script, we first define an ADT `AExpr` for arithmetic expressions.
SCORE
1.0
['\n```\n\nIn this Coq script, we first define an ADT `AExpr` for arithmetic expressions.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive AExpr : Type :=
  | AConst : nat -> AExpr
  | AVar : string -> AExpr
  | AAdd : AExpr -> AExpr -> AExpr.

Fixpoint eval (e : AExpr) (env : string -> nat) : nat :=
  match e with
  | AConst n => n
  | AVar x => env x
  | AAdd e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : AExpr) : AExpr :=
  match e with
  | AConst n => AConst n
  | AVar x => AVar x
  | AAdd e1 e2 =>
    match optimize e1 with
    | AConst 0 => optimize e2
    | e1' =>
      match optimize e2 with
      | AConst 0 => e1'
      | e2' => AAdd e1' e2'
      end
    end
  end.

Theorem optimize_preserves_semantics :
  forall (e : AExpr) (env : string -> nat),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
```

In this Coq script, we first define an ADT `AExpr` for arithmetic expressions.

STATS

number of nodes: 43
number of gen nodes: 22 (including leaves: 2)
number of back nodes: 21 (including leaves: 20)

expansion count: 26 (including failed: 5)

cache stats {'hit': 2, 'miss': 32}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92]

Trial calls: [366, 173, 417, 34]


Time Statistics:

  Min: 92.00 sec, Max: 601.00 sec, Average: 395.75 sec, Standard Deviation: 216.75 sec

Call Statistics:

  Min: 34 calls, Max: 417 calls, Average: 247.50 calls, Standard Deviation: 153.22 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601]

Trial calls: [366, 417]


Time Statistics:

  Min: 601.00 sec, Max: 601.00 sec, Average: 601.00 sec, Standard Deviation: 0.00 sec

Call Statistics:

  Min: 366 calls, Max: 417 calls, Average: 391.50 calls, Standard Deviation: 25.50 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92]

Trial calls: [173, 34]


Time Statistics:

  Min: 92.00 sec, Max: 289.00 sec, Average: 190.50 sec, Standard Deviation: 98.50 sec

Call Statistics:

  Min: 34 calls, Max: 173 calls, Average: 103.50 calls, Standard Deviation: 69.50 calls

Trial  5
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Set :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 31, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 31, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 32, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 32, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 32, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 33, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 33, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 33, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 32, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 32, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 33, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 33, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 34, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| n | x | e1 e2]; try reflexivity.
File "./ex.v", line 29, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; try reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 34, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1). destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1). destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1). destruct (optimize e2).
    try destruct n. try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1). destruct (optimize e2).
    try destruct n. try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1). destruct (optimize e2).
    try destruct n. try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1). destruct (optimize e2).
    try destruct n. try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1). destruct (optimize e2).
    try destruct n. try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2].
  - (* Const n *) simpl.
File "./ex.v", line 29, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2].\n  - (* Const n *) simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n    eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 34, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Arith.Arith.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 369
number of gen nodes: 185 (including leaves: 63)
number of back nodes: 184 (including leaves: 122)

expansion count: 319 (including failed: 135)

cache stats {'hit': 272, 'miss': 176}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92, 606]

Trial calls: [366, 173, 417, 34, 448]


Time Statistics:

  Min: 92.00 sec, Max: 606.00 sec, Average: 437.80 sec, Standard Deviation: 211.32 sec

Call Statistics:

  Min: 34 calls, Max: 448 calls, Average: 287.60 calls, Standard Deviation: 158.79 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601, 606]

Trial calls: [366, 417, 448]


Time Statistics:

  Min: 601.00 sec, Max: 606.00 sec, Average: 602.67 sec, Standard Deviation: 2.36 sec

Call Statistics:

  Min: 366 calls, Max: 448 calls, Average: 410.33 calls, Standard Deviation: 33.81 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92]

Trial calls: [173, 34]


Time Statistics:

  Min: 92.00 sec, Max: 289.00 sec, Average: 190.50 sec, Standard Deviation: 98.50 sec

Call Statistics:

  Min: 34 calls, Max: 173 calls, Average: 103.50 calls, Standard Deviation: 69.50 calls

Trial  6
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n| Const : nat -> Expr\n| Var : string -> Expr\n| Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 15, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 33, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 34, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 35, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' destruct (optimize e1). destruct (optimize e2). try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n. try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n. try destruct n0. eauto using PeanoNat.
File "./ex.v", line 33, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n. try destruct n0. eauto using PeanoNat.Nat.
File "./ex.v", line 33, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n. try destruct n0. eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n. try destruct n0. eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 34, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1). destruct (optimize e2). try destruct n. try destruct n0. eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 34, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\nQed.']
[' try destruct n0.']
[' eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\n  - simpl.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e as [| n x e1 e2]; simpl.
File "./ex.v", line 30, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2]; simpl.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x e1 e2].
  - simpl.
File "./ex.v", line 30, characters 17-28:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| x e1 e2].\n  - simpl.']
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 38, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'

File "./ex.v", line 28, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const n => e\n  | Var x => e\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.
SCORE
1.0
["    | _, _ => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 46, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 46, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
``` <?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class UserController extends Controller
{
    public function login()
    {
        return view('user.
SCORE
1.0
["\n``` <?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Models\\User;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass UserController extends Controller\n{\n    public function login()\n    {\n        return view('user."]
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.

Inductive Expr : Type :=
| Const : nat -> Expr
| Var : string -> Expr
| Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e.
  - (* Const *)
    simpl. reflexivity.
  - (* Var *)
    simpl. reflexivity.
  - (* Add *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
``` <?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class UserController extends Controller
{
    public function login()
    {
        return view('user.

STATS

number of nodes: 319
number of gen nodes: 160 (including leaves: 52)
number of back nodes: 159 (including leaves: 108)

expansion count: 270 (including failed: 111)

cache stats {'hit': 258, 'miss': 120}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92, 606, 491]

Trial calls: [366, 173, 417, 34, 448, 378]


Time Statistics:

  Min: 92.00 sec, Max: 606.00 sec, Average: 446.67 sec, Standard Deviation: 193.92 sec

Call Statistics:

  Min: 34 calls, Max: 448 calls, Average: 302.67 calls, Standard Deviation: 148.81 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601, 606]

Trial calls: [366, 417, 448]


Time Statistics:

  Min: 601.00 sec, Max: 606.00 sec, Average: 602.67 sec, Standard Deviation: 2.36 sec

Call Statistics:

  Min: 366 calls, Max: 448 calls, Average: 410.33 calls, Standard Deviation: 33.81 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92, 491]

Trial calls: [173, 34, 378]


Time Statistics:

  Min: 92.00 sec, Max: 491.00 sec, Average: 290.67 sec, Standard Deviation: 162.90 sec

Call Statistics:

  Min: 34 calls, Max: 378 calls, Average: 195.00 calls, Standard Deviation: 141.30 calls

Trial  7
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.
File "./ex.v", line 4, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.
File "./ex.v", line 4, characters 0-26:
Error: Cannot find a physical path bound to logical path Coq.ZArith.


SCORE
None
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.
SCORE
1.0
['\nImport ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
SCORE
1.0
['ZArith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
SCORE
1.0
['\nImport Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.
SCORE
1.0
['\nImport PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.
SCORE
1.0
['\n\nInductive aexp : Type :=\n  | Const : Z -> aexp\n  | Var : string -> aexp\n  | Add : aexp -> aexp -> aexp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.
SCORE
1.0
['\n\nFixpoint evaluate (e : aexp) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => evaluate e1 env + evaluate e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e as [|x |n e1 e2 IHe1 IHe2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. reflexivity.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 37, characters 39-43:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |n e1 e2 IHe1 IHe2].
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
File "./ex.v", line 34, characters 2-41:
Warning: Unused introduction pattern: IHe2
[unused-intro-pattern,tactics,default]
File "./ex.v", line 39, characters 15-19:
Error: The variable IHe2 was not found in the current environment.


SCORE
-1.0
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
File "./ex.v", line 34, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2].
  - simpl.
File "./ex.v", line 34, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2].\n  - simpl.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - destruct n; try reflexivity.
File "./ex.v", line 38, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct n; try reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 37, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - eauto.
File "./ex.v", line 37, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - eauto.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 38, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - eauto.
File "./ex.v", line 38, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - eauto.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
  - destruct (optimize e2); try destruct n; try destruct n0.
File "./ex.v", line 38, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - destruct (optimize e2); try destruct n; try destruct n0.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 38, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl; try reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [| n x e1 e2].
  - simpl.
File "./ex.v", line 34, characters 17-30:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n x e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.
File "./ex.v", line 34, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e; simpl.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : aexp) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall (e : aexp) (env : string -> Z),\n    eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 39, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 40, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 45, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 46, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 40, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
  - simpl.
File "./ex.v", line 42, characters 2-3:
Error: [Focus] Wrong bullet -: Current bullet - is not finished.


SCORE
-1.0
['\n  - simpl.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 40, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint eval (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall (e : aexp) (env : string -> Z),
    eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : Z -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr : Type :=
  | Const : Z -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Definition eval (e : expr) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => (eval e1 env) + (eval e2 env)
  end.
File "./ex.v", line 19, characters 18-22:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['\n\nDefinition eval (e : expr) (env : string -> Z) : Z :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => (eval e1 env) + (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : aexp) : aexp :=\n  match e with\n  | Add e1 (Const 0) => optimize e1\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Error: There are pending proofs in file ./ex.v: optimize_correctness.

SCORE
1.0
['\n\nTheorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_correctness.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_correctness.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x n e1 e2 IHe1 IHe2].
  - (* Const x *) reflexivity.
File "./ex.v", line 33, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x n e1 e2 IHe1 IHe2].\n  - (* Const x *) reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_correctness.

SCORE
1.0
['\n  induction e as [|x |e1 e2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_correctness.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_correctness.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 36, characters 15-19:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
File "./ex.v", line 35, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
None
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive aexp : Type :=
  | Const : Z -> aexp
  | Var : string -> aexp
  | Add : aexp -> aexp -> aexp.

Fixpoint evaluate (e : aexp) (env : string -> Z) : Z :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => evaluate e1 env + evaluate e2 env
  end.

Fixpoint optimize (e : aexp) : aexp :=
  match e with
  | Add e1 (Const 0) => optimize e1
  | Add (Const 0) e2 => optimize e2
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_correctness : forall e env, evaluate (optimize e) env = evaluate e env.
Proof.
  intros e env.
  induction e as [|x |e1 e2].
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
File "./ex.v", line 35, characters 22-26:
Error: The variable IHe1 was not found in the current environment.


SCORE
-1.0
[' rewrite <- IHe2.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\nImport ListNotations.']
['\nImport PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.
File "./ex.v", line 19, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nInductive expr :=\n  | Const (n:Z)\n  | Var (x:string)\n  | Add (e1 e2:expr).\n\nFixpoint evaluate (e:expr) (env:string -> Z) : Z :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => Z.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.
SCORE
1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e:expr) : expr :=\n  match e with\n    | Add (Const 0) e2 => optimize e2\n    | Add e1 (Const 0) => optimize e1\n    | Add e1 e2 => Add (optimize e1) (optimize e2)\n    | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env,\n  evaluate e env = evaluate (optimize e) env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [|x |e1 e2 |e1 e2 IHe1 IHe2].
  - reflexivity.
File "./ex.v", line 34, characters 17-45:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x |e1 e2 |e1 e2 IHe1 IHe2].\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e as [|x n e1 e2]; simpl.
File "./ex.v", line 34, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|x n e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Import ZArith.ZArith.
Import ListNotations.
Import Nat.
Import PeanoNat.

Inductive expr :=
  | Const (n:Z)
  | Var (x:string)
  | Add (e1 e2:expr).

Fixpoint evaluate (e:expr) (env:string -> Z) : Z :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => Z.add (evaluate e1 env) (evaluate e2 env)
  end.

Fixpoint optimize (e:expr) : expr :=
  match e with
    | Add (Const 0) e2 => optimize e2
    | Add e1 (Const 0) => optimize e1
    | Add e1 e2 => Add (optimize e1) (optimize e2)
    | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env,
  evaluate e env = evaluate (optimize e) env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
File "./ex.v", line 38, characters 4-19:
Error:
Found no subterm matching "evaluate (optimize e1) env" in the current goal.


SCORE
-1.0
['\n    rewrite <- IHe1.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 347
number of gen nodes: 174 (including leaves: 58)
number of back nodes: 173 (including leaves: 116)

expansion count: 300 (including failed: 127)

cache stats {'hit': 219, 'miss': 167}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92, 606, 491, 601]

Trial calls: [366, 173, 417, 34, 448, 378, 386]


Time Statistics:

  Min: 92.00 sec, Max: 606.00 sec, Average: 468.71 sec, Standard Deviation: 187.48 sec

Call Statistics:

  Min: 34 calls, Max: 448 calls, Average: 314.57 calls, Standard Deviation: 140.83 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601, 606, 601]

Trial calls: [366, 417, 448, 386]


Time Statistics:

  Min: 601.00 sec, Max: 606.00 sec, Average: 602.25 sec, Standard Deviation: 2.17 sec

Call Statistics:

  Min: 366 calls, Max: 448 calls, Average: 404.25 calls, Standard Deviation: 31.12 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92, 491]

Trial calls: [173, 34, 378]


Time Statistics:

  Min: 92.00 sec, Max: 491.00 sec, Average: 290.67 sec, Standard Deviation: 162.90 sec

Call Statistics:

  Min: 34 calls, Max: 378 calls, Average: 195.00 calls, Standard Deviation: 141.30 calls

Trial  8
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.
File "./ex.v", line 5, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.
File "./ex.v", line 5, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Arith.


SCORE
None
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
SCORE
1.0
['Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.
SCORE
1.0
['\nImport Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n| Const : nat -> expr\n| Var : string -> expr\n| Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.
SCORE
1.0
['\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add (Const 0) e2 => optimize e2\n  | Add e1 (Const 0) => optimize e1\n  | Add e1 e2 => Add (optimize e1) (optimize e2)\n  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 38, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 38, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 39, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 37, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 36, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 37, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 37, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 38, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 35, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 35, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 36, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 34, characters 138-146:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
[' destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 34, characters 138-150:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 35, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 36, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 36, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 37, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe1.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 39, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 39, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 40, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 41, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1).
    destruct (optimize e2).
    try destruct n.
    try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.
File "./ex.v", line 40, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n;\n    try destruct n0;\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.
File "./ex.v", line 40, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n;
    try destruct n0;
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 41, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2]; simpl.
File "./ex.v", line 31, characters 17-31:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2]; simpl.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n|x|e1 e2]; simpl.
File "./ex.v", line 31, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n|x|e1 e2]; simpl.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
[' reflexivity.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1).\n    destruct (optimize e2).\n    try destruct n.']
['\n    try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nProof.']
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n |x |e1 e2 IHe1 IHe2].
  - simpl.
File "./ex.v", line 31, characters 17-41:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n |x |e1 e2 IHe1 IHe2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [| x | e1 e2 | e1 e2 IHe1 IHe2].
  - simpl.
File "./ex.v", line 31, characters 17-48:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| x | e1 e2 | e1 e2 IHe1 IHe2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e as [| n | x | e1 e2]; simpl.
File "./ex.v", line 32, characters 17-34:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [| n | x | e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 41, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 41, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 42, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 42, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add (Const 0) e2 => optimize e2
  | Add e1 (Const 0) => optimize e1
  | Add e1 e2 => Add (optimize e1) (optimize e2)
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e.
  - (* Const n *)
    reflexivity.
  - (* Var x *)
    reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 43, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
[' rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.
SCORE
1.0
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Const n => e\n  | Var x => e\n  | Add e1 e2 =>\n    match optimize e1, optimize e2 with\n    | Const 0, _ => e2\n    | _, Const 0 => e1\n    | e1', e2' => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e as [|n x e1 e2 IHe1 IHe2].
  - simpl.
File "./ex.v", line 35, characters 17-39:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2 IHe1 IHe2].\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Const n *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Var x *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - (* Add e1 e2 *)\n    simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 44, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 44, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 44, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 45, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\nQed.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 45, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 45, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 46, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' reflexivity.']
['\n  - (* Add e1 e2 *)\n    simpl.']
['\n    rewrite <- IHe1.']
['\n    rewrite <- IHe2.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
[' rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 97-105:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 97-109:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Arith.Arith.
Import Arith.

Inductive expr : Type :=
| Const : nat -> expr
| Var : string -> expr
| Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Const n => e
  | Var x => e
  | Add e1 e2 =>
    match optimize e1, optimize e2 with
    | Const 0, _ => e2
    | _, Const 0 => e1
    | e1', e2' => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics : forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - (* Const n *)
    simpl. reflexivity.
  - (* Var x *)
    simpl. reflexivity.
  - (* Add e1 e2 *)
    simpl.
    rewrite <- IHe1. rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\nQed.']
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
reached timelimit, stopping expansion on current node
CHOSEN SOLUTION
None

STATS

number of nodes: 365
number of gen nodes: 183 (including leaves: 63)
number of back nodes: 182 (including leaves: 120)

expansion count: 320 (including failed: 138)

cache stats {'hit': 313, 'miss': 133}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92, 606, 491, 601, 605]

Trial calls: [366, 173, 417, 34, 448, 378, 386, 446]


Time Statistics:

  Min: 92.00 sec, Max: 606.00 sec, Average: 485.75 sec, Standard Deviation: 181.08 sec

Call Statistics:

  Min: 34 calls, Max: 448 calls, Average: 331.00 calls, Standard Deviation: 138.72 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601, 606, 601, 605]

Trial calls: [366, 417, 448, 386, 446]


Time Statistics:

  Min: 601.00 sec, Max: 606.00 sec, Average: 602.80 sec, Standard Deviation: 2.23 sec

Call Statistics:

  Min: 366 calls, Max: 448 calls, Average: 412.60 calls, Standard Deviation: 32.46 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92, 491]

Trial calls: [173, 34, 378]


Time Statistics:

  Min: 92.00 sec, Max: 491.00 sec, Average: 290.67 sec, Standard Deviation: 162.90 sec

Call Statistics:

  Min: 34 calls, Max: 378 calls, Average: 195.00 calls, Standard Deviation: 141.30 calls

Trial  9
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.
SCORE
1.0
['\n\nInductive Exp : Type :=\n  | Const : nat -> Exp\n  | Var : string -> Exp\n  | Add : Exp -> Exp -> Exp.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Definition eval (e : Exp) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => eval e1 env + eval e2 env
  end.
File "./ex.v", line 14, characters 19-23:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['\n\nDefinition eval (e : Exp) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Fixpoint evaluate (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint evaluate (e : Exp) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Exp : Type :=
  | Const : nat -> Exp
  | Var : string -> Exp
  | Add : Exp -> Exp -> Exp.

Fixpoint evaluate (e : Exp) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.add (evaluate e1 env) (evaluate e2 env)
  end.
File "./ex.v", line 14, characters 17-24:
Error: The reference nat.add was not found in the current environment.


SCORE
-1.0
['add (evaluate e1 env) (evaluate e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Type :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.
File "./ex.v", line 14, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 17-24:
Error: The reference nat.add was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.
SCORE
1.0
['\n\nFixpoint eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => eval e1 env + eval e2 env\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'

File "./ex.v", line 27, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : Expr) : Expr :=\n  match e with\n  | Const _ => e\n  | Var _ => e\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.
SCORE
1.0
["    | _, _ => Add e1' e2'\n    end\n  end."]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  induction e.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 42, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 42, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` import { useState } from 'react';
import { useHistory } from 'react-router-dom';

import { makeStyles } from '@material-ui/core/styles';
import { Button, TextField, Typography } from '@material-ui/core';
import { ArrowBack } from '@material-ui/icons';

import { create } from '../api/user';
import { useAuth } from '
SCORE
1.0
["\n``` import { useState } from 'react';\nimport { useHistory } from 'react-router-dom';\n\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Button, TextField, Typography } from '@material-ui/core';\nimport { ArrowBack } from '@material-ui/icons';\n\nimport { create } from '../api/user';\nimport { useAuth } from '"]
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.

Inductive Expr : Type :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Fixpoint eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => eval e1 env + eval e2 env
  end.

Fixpoint optimize (e : Expr) : Expr :=
  match e with
  | Const _ => e
  | Var _ => e
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros e env.
  induction e.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` import { useState } from 'react';
import { useHistory } from 'react-router-dom';

import { makeStyles } from '@material-ui/core/styles';
import { Button, TextField, Typography } from '@material-ui/core';
import { ArrowBack } from '@material-ui/icons';

import { create } from '../api/user';
import { useAuth } from '

STATS

number of nodes: 37
number of gen nodes: 19 (including leaves: 2)
number of back nodes: 18 (including leaves: 17)

expansion count: 21 (including failed: 3)

cache stats {'hit': 0, 'miss': 28}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92, 606, 491, 601, 605, 86]

Trial calls: [366, 173, 417, 34, 448, 378, 386, 446, 28]


Time Statistics:

  Min: 86.00 sec, Max: 606.00 sec, Average: 441.33 sec, Standard Deviation: 211.96 sec

Call Statistics:

  Min: 28 calls, Max: 448 calls, Average: 297.33 calls, Standard Deviation: 161.78 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601, 606, 601, 605]

Trial calls: [366, 417, 448, 386, 446]


Time Statistics:

  Min: 601.00 sec, Max: 606.00 sec, Average: 602.80 sec, Standard Deviation: 2.23 sec

Call Statistics:

  Min: 366 calls, Max: 448 calls, Average: 412.60 calls, Standard Deviation: 32.46 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92, 491, 86]

Trial calls: [173, 34, 378, 28]


Time Statistics:

  Min: 86.00 sec, Max: 491.00 sec, Average: 239.50 sec, Standard Deviation: 166.60 sec

Call Statistics:

  Min: 28 calls, Max: 378 calls, Average: 153.25 calls, Standard Deviation: 142.14 calls

Trial  10
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.
File "./ex.v", line 2, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['Require Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.
File "./ex.v", line 2, characters 0-27:
Error: Cannot find a physical path bound to logical path Coq.Strings.


SCORE
None
['Strings.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
SCORE
1.0
['String.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.
SCORE
1.0
['PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.
SCORE
1.0
['\n\nInductive Expr : Set :=\n  | Const : nat -> Expr\n  | Var : string -> Expr\n  | Add : Expr -> Expr -> Expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => PeanoNat.
File "./ex.v", line 14, characters 27-28:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n    | Const n => n\n    | Var x => env x\n    | Add e1 e2 => PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => PeanoNat.Nat.
File "./ex.v", line 14, characters 31-32:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
    | Const n => n
    | Var x => env x
    | Add e1 e2 => PeanoNat.Nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 37-41:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => PeanoNat.
File "./ex.v", line 14, characters 25-26:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nDefinition eval (e : Expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => PeanoNat.Nat.
File "./ex.v", line 14, characters 29-30:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.

Inductive Expr : Set :=
  | Const : nat -> Expr
  | Var : string -> Expr
  | Add : Expr -> Expr -> Expr.

Definition eval (e : Expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => PeanoNat.Nat.add (eval e1 env) (eval e2 env)
  end.
File "./ex.v", line 14, characters 35-39:
Error: The reference eval was not found in the current environment.


SCORE
-1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Arith.PeanoNat.
Import ListNotations.
File "./ex.v", line 4, characters 7-20:
Error: Cannot find module ListNotations


SCORE
-1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.
File "./ex.v", line 3, characters 0-19:
Error: Cannot find a physical path bound to logical path Coq.


SCORE
None
['\nRequire Import Coq.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.
File "./ex.v", line 3, characters 0-25:
Error: Cannot find a physical path bound to logical path Coq.Lists.


SCORE
None
['Lists.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
SCORE
1.0
['List.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
SCORE
1.0
['\nRequire Import Arith.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.
SCORE
1.0
['\nImport ListNotations.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.
SCORE
1.0
['\n\nInductive expr : Type :=\n  | Const : nat -> expr\n  | Var : string -> expr\n  | Add : expr -> expr -> expr.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.
File "./ex.v", line 17, characters 20-21:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
['\n\nFixpoint eval (e : expr) (env : string -> nat) : nat :=\n  match e with\n  | Const n => n\n  | Var x => env x\n  | Add e1 e2 => Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.
SCORE
1.0
['add (eval e1 env) (eval e2 env)\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end

File "./ex.v", line 30, characters 0-1:
Error: Syntax error: 'end' expected after [branches] (in [term_match]).


SCORE
None
["\n\nFixpoint optimize (e : expr) : expr :=\n  match e with\n  | Add e1 e2 =>\n    let e1' := optimize e1 in\n    let e2' := optimize e2 in\n    match e1', e2' with\n    | Const 0, _ => e2'\n    | _, Const 0 => e1'\n    | _, _ => Add e1' e2'\n    end\n"]
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.
SCORE
1.0
['  | _ => e\n  end.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n\nTheorem optimize_preserves_semantics :\n  forall e env, eval (optimize e) env = eval e env.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\nProof.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  intros.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros.
  induction e as [|n x e1 e2]; simpl.
File "./ex.v", line 37, characters 17-29:
Error: Expects a disjunctive pattern with 3 branches.


SCORE
-1.0
['\n  induction e as [|n x e1 e2]; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
[' induction e; simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - reflexivity.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n  - simpl.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe1.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    rewrite <- IHe2.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['\n    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.
File "./ex.v", line 43, characters 16-24:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 16-28:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0.
    eauto using PeanoNat.Nat.add_0_r.
Qed.
File "./ex.v", line 44, characters 0-4:
Error:
 (in proof optimize_preserves_semantics): Attempt to save an incomplete proof


SCORE
-1.0
['\nQed.']
['\nQed.']
['\n    eauto using PeanoNat.']
['Nat.']
['add_0_r.']
['\nQed.']
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.
File "./ex.v", line 43, characters 49-57:
Error: The variable PeanoNat was not found in the current environment.


SCORE
None
['\n    destruct (optimize e1); destruct (optimize e2);\n    try destruct n; try destruct n0; eauto using PeanoNat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.
File "./ex.v", line 43, characters 49-61:
Error: The reference PeanoNat.Nat was not found in the current environment.


SCORE
None
['Nat.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Error: There are pending proofs in file ./ex.v: optimize_preserves_semantics.

SCORE
1.0
['add_0_r.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
SCORE
1.0
['\nQed.']
TEXT
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` 
#include "repository/ISwiftMtParser.
SCORE
1.0
['\n``` \n#include "repository/ISwiftMtParser.']
CHOSEN SOLUTION
### Spec: In Coq, write an ADT for arithmetic expressions comprising constants, variables and binary additions. Then write an evaluator taking an expression and an environment (a function that takes a variable name and returns a number) and returning the number resulting from evaluation. Then write an optimizer taking an expression and returning an expression with all additions by 0 removed. Then prove that the optimizer preserves the semantics as defined by the evaluation function.
### Hint: In the optimizer, recursively optimize the sub-expressions.
### Hint: You can import the `string` datatype with the line `Require Import Coq.Strings.String.`.
### Hint: Use Fixpoint instead of Definition for recursive functions.
### Hint: With tactics like `induction` and `destruct`, _avoid_ naming with `as` and let Coq pick the names for you. For example, use `induction e.` but _not_ `induction e as [...]`.

### Hint: For the proof, do `induction e.`. Do NOT name the hypotheses with `as`.
### Hint: The simple cases are by `simpl. reflexivity.`.
### Hint: The addition case is by `simpl. rewrite <- IHe1. rewrite <- IHe2. destruct (optimize e1); destruct (optimize e2); try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.`.
### Hint: You'll need `Require Import Arith`.

```coq
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Arith.
Import ListNotations.
Import ListNotations.

Inductive expr : Type :=
  | Const : nat -> expr
  | Var : string -> expr
  | Add : expr -> expr -> expr.

Fixpoint eval (e : expr) (env : string -> nat) : nat :=
  match e with
  | Const n => n
  | Var x => env x
  | Add e1 e2 => Nat.add (eval e1 env) (eval e2 env)
  end.

Fixpoint optimize (e : expr) : expr :=
  match e with
  | Add e1 e2 =>
    let e1' := optimize e1 in
    let e2' := optimize e2 in
    match e1', e2' with
    | Const 0, _ => e2'
    | _, Const 0 => e1'
    | _, _ => Add e1' e2'
    end
  | _ => e
  end.

Theorem optimize_preserves_semantics :
  forall e env, eval (optimize e) env = eval e env.
Proof.
  intros. induction e; simpl.
  - reflexivity.
  - reflexivity.
  - simpl.
    rewrite <- IHe1.
    rewrite <- IHe2.
    destruct (optimize e1); destruct (optimize e2);
    try destruct n; try destruct n0; eauto using PeanoNat.Nat.add_0_r.
Qed.
``` 
#include "repository/ISwiftMtParser.

STATS

number of nodes: 53
number of gen nodes: 27 (including leaves: 4)
number of back nodes: 26 (including leaves: 23)

expansion count: 35 (including failed: 9)

cache stats {'hit': 6, 'miss': 45}
=====SUMMARY STATISTICS FOR ALL TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 289, 601, 92, 606, 491, 601, 605, 86, 105]

Trial calls: [366, 173, 417, 34, 448, 378, 386, 446, 28, 51]


Time Statistics:

  Min: 86.00 sec, Max: 606.00 sec, Average: 407.70 sec, Standard Deviation: 224.98 sec

Call Statistics:

  Min: 28 calls, Max: 448 calls, Average: 272.70 calls, Standard Deviation: 170.34 calls

=====SUMMARY STATISTICS FOR TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [601, 601, 606, 601, 605]

Trial calls: [366, 417, 448, 386, 446]


Time Statistics:

  Min: 601.00 sec, Max: 606.00 sec, Average: 602.80 sec, Standard Deviation: 2.23 sec

Call Statistics:

  Min: 366 calls, Max: 448 calls, Average: 412.60 calls, Standard Deviation: 32.46 calls

=====SUMMARY STATISTICS FOR NON_TIMED OUT TRIALS=====

Experiment: run.py for 10 trials

Trial times: [289, 92, 491, 86, 105]

Trial calls: [173, 34, 378, 28, 51]


Time Statistics:

  Min: 86.00 sec, Max: 491.00 sec, Average: 212.60 sec, Standard Deviation: 158.43 sec

Call Statistics:

  Min: 28 calls, Max: 378 calls, Average: 132.80 calls, Standard Deviation: 133.55 calls

To complete all experiments, 68 minutes and 36 seconds elapsed.


